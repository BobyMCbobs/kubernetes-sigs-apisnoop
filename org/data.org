#+TITLE: APISnoop v3 Database

* Ensure connectivity to right database

#+NAME: Start Postgresql Connection
#+BEGIN_SRC emacs-lisp :results silent
  ;; (sql-connect connection (concat "*SQL: postgres:data*"))
  (sql-connect "hasura" (concat "*SQL: postgres:data*"))
#+END_SRC

#+BEGIN_SRC sql-mode
  \conninfo
#+END_SRC

#+RESULTS:
: You are connected to database "data" as user "postgres" on host "172.17.0.1" at port "5432".
: SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)

#+BEGIN_SRC sql-mode
select 'drop table if exists "' || tablename || '" cascade;' from pg_tables;
#+END_SRC

#+BEGIN_SRC sql-mode
  drop table if exists "event_log" cascade;
  drop table if exists "job_logs" cascade;
  drop table if exists "audit_events" cascade;
  drop table if exists "object_refs" cascade;
  drop table if exists "response_statuses" cascade;
  drop table if exists "users_info" cascade;
#+END_SRC

#+RESULTS:
#+begin_example
NOTICE:  table "event_log" does not exist, skipping
DROP TABLE
NOTICE:  table "job_logs" does not exist, skipping
DROP TABLE
NOTICE:  table "audit_events" does not exist, skipping
DROP TABLE
NOTICE:  table "object_refs" does not exist, skipping
DROP TABLE
NOTICE:  table "response_statuses" does not exist, skipping
DROP TABLE
NOTICE:  table "users_info" does not exist, skipping
DROP TABLE
#+end_example
* Exploring our first dataset
#+BEGIN_SRC sql-mode
select count(*) from audit_events;
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
 count  
--------
 301875
(1 row)

#+end_src

#+BEGIN_SRC sql-mode
\dt
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
           List of relations
 Schema |     Name     | Type  | Owner 
--------+--------------+-------+-------
 public | audit_events | table | hh
(1 row)

#+end_src

#+BEGIN_SRC sql-mode
\dt audit_events

#+END_SRC

#+RESULTS:
#+begin_src sql-mode
           List of relations
 Schema |     Name     | Type  | Owner 
--------+--------------+-------+-------
 public | audit_events | table | hh
(1 row)

#+end_src

* Audit Events
** columns
*** auditID
#+NAME: auditID
#+BEGIN_SRC sql-mode
    "auditID" uuid,
#+END_SRC

This is a UUID!
**** Examples
#+BEGIN_SRC json
  auditID: "c0793350-e7fe-42ce-93e6-8436a0eb3b39",
#+END_SRC
**** 285593 times each one occurs once
#+BEGIN_SRC shell
cat kube-apiserver-audit.log | jq .auditID | sort | uniq -c | grep -v '2 "' | wc -l
#+END_SRC
**** 8141 times a single uuid shows up twice
#+BEGIN_SRC shell
cat kube-apiserver-audit.log | jq .auditID | sort | uniq -c | grep -v '1 "' | wc -l
#+END_SRC
**** When a UUID shows up twice, the only diff is stage and stageTimestamp
#+BEGIN_SRC shell
 cat kube-apiserver-audit.log | jq -c '. | select( .auditID | contains("ffe9adb2-6917-49ed-b823-72c4fe4355e0"))' | jq 
#+END_SRC

  "stage": "ResponseStarted => ResponseComplete"
  "stageTimestamp": "2019-06-17T05:19:17.898138Z",

#+BEGIN_SRC shell
cat kube-apiserver-audit.log | jq .auditID | sort | uniq -c | grep -v '1 "' | wc -l
#+END_SRC

*** level
#+NAME: level
#+BEGIN_SRC sql-mode
  level text NOT NULL,
#+END_SRC

level: "Request", "Metadata", "RequestResponse"

I'm not sure here, but I feel like we should only be looking at RequestResponse... not all three.
Huh, that was wrong.. the counts differ wildly:

**** 171724 Requests
#+BEGIN_SRC shell
cat kube-apiserver-audit.log | jq -c '. | select( .level | contains("Request"))' | jq -r .auditID | sort | uniq | wc -l
#+END_SRC
**** 122010 Metadata
#+BEGIN_SRC shell
cat kube-apiserver-audit.log | jq -c '. | select( .level | contains("RequestResponse"))' | jq -r .auditID | sort | uniq | wc -l
#+END_SRC

**** 26016 RequestResponse
#+BEGIN_SRC shell
cat kube-apiserver-audit.log | jq -c '. | select( .level | contains("RequestResponse"))' | jq -r .auditID | sort | uniq | wc -l
#+END_SRC

*** verb
#+NAME: verb
#+BEGIN_SRC sql-mode
  verb text NOT NULL,
#+END_SRC
An http verb != endpoint verb:
stage has quite a few values
- create
- delete
- deletecollection,
- get
- list
- patch
- update
- watch
*** requestURI
#+NAME: requestURI
#+BEGIN_SRC sql-mode
  "requestURI" text NOT NULL,
#+END_SRC

We'll need to use this to match against the OpenAPISpec to find the endpoint.

requestURI: "/api/v1/namespaces/kube-system/pods/etcd-empty-dir-cleanup-bootstrap-e2e-master",
*** userAgent
#+NAME: userAgent
#+BEGIN_SRC sql-mode
  "userAgent" text,
#+END_SRC
For e2e.test we added support to append -- and the test name at that point it time:

userAgent: "kubelet/v1.16.0 (linux/amd64) kubernetes/0e499be",

It may make sense to split on '--' an store what follows as the testName.
*** testName
#+NAME: testName
#+BEGIN_SRC sql-mode
  "testName" text,
#+END_SRC

This isn't a direct mapping, we create it if the userAgent contains '--' followed by the test name.
For now we only see this with e2e.test.
*** timeStamp
    "requestReceivedTimestamp"
#+NAME: timeStamp
#+BEGIN_SRC sql-mode
  "timeStamp" timestamp with time zone
#+END_SRC
*** stage / stageTimestamp                                           :unused:

Noting that when we have a responseComplete, it's always paid with a responseStarted.
The UUID and everything else is the same, other than the timestamp.
I suspect this is only generated for requests that take a while.

stage: "ResponseComplete", "ResponseStarted"
#+NAME: stage
#+BEGIN_SRC sql-mode
  stage text NOT NULL,
  "stageTimestamp" timestamp with time zone,
#+END_SRC
*** Kind / apiVersion                                                :unused:

For every singe one the values are the same:
kind: "Event"
apiVersion: "audit.k8s.io/v1"

#+NAME: kind
#+BEGIN_SRC sql-mode
  kind text,
  "apiVersion" text,
#+END_SRC
*** annotations                                                      :unused:

This is a json blog... not sure how to handle yet
https://blog.hasura.io/postgres-json-and-jsonb-type-support-on-graphql-41f586e47536/

Unsure we need annotations for now as they may be good for understanding a
specific test, the data doesn't aggregate well.

#+BEGIN_SRC shell
cat kube-apiserver-audit.log | jq -r .annotations | sort | uniq
#+END_SRC

A good number of them seem to be allow or deny + reason:

#+BEGIN_SRC json
  "annotations": {
    "authorization.k8s.io/decision": "allow",
    "authorization.k8s.io/reason": ""
  }
#+END_SRC

#+BEGIN_SRC sql-mode
  annotations jsonb,
#+END_SRC
*** sourceIPs                                                        :unused:
#+BEGIN_SRC sql-mode
  "sourceIP" text,
#+END_SRC

Could likely identify pods in this way, but not useful at this time.
sourceIPs: ["1.1.1.1"],
*** Unused Fields                                                    :unused:
The id could probably be dropped in favor of UUID, if we only capture ResponseStarted.
#+BEGIN_SRC sql-mode
  -- I'm unsure what this is
  -- This is to point back to the job that created these logs
  job_log_id integer NOT NULL
  -- should it be an iteger?
  -- maybe get rid of it completely?
  id integer NOT NULL,
#+END_SRC

** table


#+BEGIN_SRC tmate
  cd ~/ii/apisnoop_v3
  python3 import_entries.py
#+END_SRC

#+NAME: CREATE TABLE audit_events
#+BEGIN_SRC sql-mode :noweb yes :tangle ../hasura/migrations/10_table_audit_events.up.sql
  CREATE TABLE public.audit_events (
    <<auditID>>
    <<level>>
    <<verb>>
    <<requestURI>>
    <<userAgent>>
    <<testName>>
    <<requestObject.kind>>
    <<requestObject.apiVersion>>
    <<requestObject.metadata>>
    <<requestObject.spec>>
    <<requestObject.status>>
    <<responseObject.kind>>
    <<responseObject.apiVersion>>
    <<responseObject.metadata>>
    <<responseObject.spec>>
    <<responseObject.status>>
    <<timeStamp>>
  );
#+END_SRC

#+NAME: DROP TABLE audit_events
#+BEGIN_SRC sql-mode :noweb yes :tangle ../hasura/migrations/10_table_audit_events.down.sql
  DROP TABLE IF EXISTS audit_events
#+END_SRC

#+NAME: track_table audit_events
#+BEGIN_SRC sql-mode :noweb yes :tangle ../hasura/migrations/20_track_audit_events.up.yaml
- type: track_table
  args:
    schema: public
    name: audit_events
#+END_SRC

#+NAME: untrack_table audit_events
#+BEGIN_SRC sql-mode :noweb yes :tangle ../hasura/migrations/20_track_audit_events.down.yaml
- type: untrack_table
  args:
    schema: public
    name: audit_events
#+END_SRC

After creating the table, we have to go to the console:
http://localhost:8080/console/data/schema/public
And click on [Track All] or [Track] for the table.

I also tracked the following in network traffic, but have yet to execute them
via a directy grahpql query.

#+BEGIN_SRC shell :directory ~/apisnoop_v3
hasura init --endpoint http://localhost:8080/v1/graphql
export HASURA_GRAPHQL_ADMIN_SECRET=X
# --admin-secret "X"
#+END_SRC

#+RESULTS:
#+begin_EXAMPLE
#+end_EXAMPLE

#+NAME: add_existing_table_or_view
#+BEGIN_SRC graphql :tangle add_audit_events_to_hasura.graphql
{"type": "bulk",
 "args":[
   {"type":"add_existing_table_or_view",
    "args":{"name":"audit_events","schema":"public"}}]}
#+END_SRC

#+NAME: untrack_table
#+BEGIN_SRC graphql
{"type":"bulk",
 "args":[
   {"type":"untrack_table",
    "args":{"table":{"name":"audit_events","schema":"public"}}}]}
#+END_SRC

*** one big json blob
This has one column... event which is a jsonb.

#+BEGIN_SRC sql-mode
CREATE OR REPLACE VIEW "public"."events" AS 
 SELECT audit_events.auditID AS uuid,
    audit_events.level AS level,
    audit_events.verb AS verb,
    audit_events.requestURI AS uri,
    audit_events.userAgent AS useragent,
    audit_events.testName AS testName,
    -- ((audit_events.event -> 'requestObject'::text) ->> 'apiVersion'::text) AS apiversion,
    ((audit_events.event -> 'requestObject'::text) ->> 'kind'::text) AS kind,
    ((audit_events.event -> 'requestObject'::text) ->> 'metadata'::text) AS metadata,
    ((audit_events.event -> 'requestObject'::text) ->> 'spec'::text) AS spec,
    ((audit_events.event -> 'requestObject'::text) ->> 'status'::text) AS requeststatus,
    ((audit_events.event -> 'responseObject'::text) ->> 'status'::text) AS status,
    ((audit_events.event -> 'responseObject'::text) ->> 'kind'::text) AS responsekind,
    ((audit_events.event -> 'responseObject'::text) ->> 'metadata'::text) AS responsemetadata,
    ((audit_events.event -> 'responseObject'::text) ->> 'spec'::text) AS responsespec
   FROM audit_events;
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
ERROR:  column audit_events.event does not exist
LINE 2:  SELECT (audit_events.event -> 'auditID'::text) AS uuid,
                 ^
#+end_src

** sequence

#+BEGIN_SRC sql-mode
CREATE SEQUENCE public.audit_events_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE public.audit_events_id_seq OWNED BY public.audit_events.id;
#+END_SRC

#+RESULTS:
: CREATE SEQUENCE
: ALTER SEQUENCE
** constraints

#+BEGIN_SRC sql-mode
ALTER TABLE ONLY public.audit_events
    ADD CONSTRAINT "audit_events_auditID_key" UNIQUE ("auditID");
ALTER TABLE ONLY public.audit_events
    ADD CONSTRAINT audit_events_pkey PRIMARY KEY (id);
#+END_SRC

#+RESULTS:
: ALTER TABLE
: ALTER TABLE

* Prow Job Artifacts

#+BEGIN_SRC python
  prow_something="prow.k8s.io"
  gcs_logs="https://storage.googleapis.com/kubernetes-jenkins/logs/"
  buckets = [
      "ci-kubernetes-e2e-gce-cos-k8sbeta-default",
      "ci-kubernetes-e2e-gce-cos-k8sstable1-default",
      "ci-kubernetes-e2e-gce-cos-k8sstable2-default",
      "ci-kubernetes-e2e-gce-cos-k8sstable3-default",
      "ci-kubernetes-e2e-gci-gce"
  ]
  bucket="ci-kubernetes-e2e-gci-gce"
  testgrid_history_url = gcs_logs + bucket + "/jobResultsCache.json"
  # look for latest_success
#+END_SRC

** table
#+BEGIN_SRC sql-mode
CREATE TABLE public.audit_session (
    version text NOT NULL,
    passed text NOT NULL,
    result text NOT NULL,
    infra_commit text NOT NULL,
    id integer NOT NULL,
    "timestamp" integer NOT NULL
);
#+END_SRC

#+RESULTS:
: CREATE TABLE

** sequence
#+BEGIN_SRC sql-mode
CREATE SEQUENCE public.job_log_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
ALTER TABLE ONLY public.job_logs
    ALTER COLUMN id SET DEFAULT nextval('public.job_log_id_seq'::regclass);
#+END_SRC

#+RESULTS:

** primary key

#+BEGIN_SRC sql-mode
ALTER TABLE ONLY public.job_logs
    ADD CONSTRAINT job_log_pkey PRIMARY KEY (id);
#+END_SRC

#+RESULTS:
: ALTER TABLE

** force each audit_event to point reference a job_log
#+NAME: audit_events => job_logs
#+BEGIN_SRC sql-mode
ALTER TABLE ONLY public.audit_events
    ADD CONSTRAINT audit_events_job_log_id_fkey
    FOREIGN KEY (job_log_id)
    REFERENCES public.job_logs(id)
    ON UPDATE RESTRICT ON DELETE RESTRICT;
#+END_SRC

#+RESULTS: audit_events => job_logs
: ALTER TABLE

* Audit Session
** table
#+BEGIN_SRC sql-mode
CREATE TABLE public.audit_session (
    version text NOT NULL,
    passed text NOT NULL,
    result text NOT NULL,
    infra_commit text NOT NULL,
    id integer NOT NULL,
    "timestamp" integer NOT NULL
);
#+END_SRC

#+RESULTS:
: CREATE TABLE

** sequence
#+BEGIN_SRC sql-mode
CREATE SEQUENCE public.job_log_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
ALTER TABLE ONLY public.job_logs
    ALTER COLUMN id SET DEFAULT nextval('public.job_log_id_seq'::regclass);
#+END_SRC

#+RESULTS:

** primary key

#+BEGIN_SRC sql-mode
ALTER TABLE ONLY public.job_logs
    ADD CONSTRAINT job_log_pkey PRIMARY KEY (id);
#+END_SRC

#+RESULTS:
: ALTER TABLE

** force each audit_event to point reference a job_log
#+NAME: audit_events => job_logs
#+BEGIN_SRC sql-mode
ALTER TABLE ONLY public.audit_events
    ADD CONSTRAINT audit_events_job_log_id_fkey
    FOREIGN KEY (job_log_id)
    REFERENCES public.job_logs(id)
    ON UPDATE RESTRICT ON DELETE RESTRICT;
#+END_SRC

#+RESULTS: audit_events => job_logs
: ALTER TABLE

* Job Logs
** table
#+BEGIN_SRC sql-mode
CREATE TABLE public.job_logs (
    version text NOT NULL,
    id integer NOT NULL,
    result text NOT NULL,
    passed text NOT NULL,
    job_version text NOT NULL,
    node_os_image text NOT NULL,
    infra_commit text NOT NULL,
    master_os_image text NOT NULL,
    pod text NOT NULL,
    revision text NOT NULL,
    "timestamp" integer NOT NULL
);
#+END_SRC

#+RESULTS:
: CREATE TABLE

** sequence
#+BEGIN_SRC sql-mode
CREATE SEQUENCE public.job_log_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
ALTER TABLE ONLY public.job_logs
    ALTER COLUMN id SET DEFAULT nextval('public.job_log_id_seq'::regclass);
#+END_SRC

#+RESULTS:

** primary key

#+BEGIN_SRC sql-mode
ALTER TABLE ONLY public.job_logs
    ADD CONSTRAINT job_log_pkey PRIMARY KEY (id);
#+END_SRC

#+RESULTS:
: ALTER TABLE

** force each audit_event to point reference a job_log
#+NAME: audit_events => job_logs
#+BEGIN_SRC sql-mode
ALTER TABLE ONLY public.audit_events
    ADD CONSTRAINT audit_events_job_log_id_fkey
    FOREIGN KEY (job_log_id)
    REFERENCES public.job_logs(id)
    ON UPDATE RESTRICT ON DELETE RESTRICT;
#+END_SRC

#+RESULTS: audit_events => job_logs
: ALTER TABLE

* Object References
After looking at what is actually in the object references, I'm not sure it's
worth loading at this time.
** Example

#+BEGIN_SRC shell
cat kube-apiserver-audit.log | jq -c '. | select( .auditID | contains("65700178-2fb7-4ed9-a589-fd78ea9db2ae"))' | jq .
#+END_SRC

#+BEGIN_SRC json
  "objectRef": {
    "resource": "subjectaccessreviews",
    "apiGroup": "authorization.k8s.io",
    "apiVersion": "v1"
  },
#+END_SRC

** Data Set Inspection
*** apiGroup
 #+BEGIN_EXAMPLE
 admissionregistration.k8s.io
 apiextensions.k8s.io
 apiregistration.k8s.io
 apps
 authentication.k8s.io
 authorization.k8s.io
 autoscaling
 batch
 certificates.k8s.io
 coordination.k8s.io
 crd-publish-openapi-test-common-group.k8s.io
 crd-publish-openapi-test-empty.k8s.io
 crd-publish-openapi-test-foo.k8s.io
 crd-publish-openapi-test-multi-to-single-ver.k8s.io
 crd-publish-openapi-test-multi-ver.k8s.io
 crd-publish-openapi-test-waldo.k8s.io
 discovery-crd-test.k8s.io
 events.k8s.io
 extensions
 kubectl-crd-test.k8s.io
 metrics.k8s.io
 mygroup.example.com
 networking.k8s.io
 node.k8s.io
 null
 policy
 rbac.authorization.k8s.io
 resourcequota-crd-test.k8s.io
 scalingpolicy.kope.io
 scheduling.k8s.io
 settings.k8s.io
 snapshot.storage.k8s.io
 stable.example.com
 storage.k8s.io
 wardle.k8s.io
 webhook-crd-test.k8s.io
 webhook-multiversion-crd-test.k8s.io
 #+END_EXAMPLE

*** apiVersion
 #+BEGIN_EXAMPLE
 null
 v1
 v1alpha1
 v1beta1
 v2
 v2alpha1
 v3
 v4
 v5
 v6
 #+END_EXAMPLE

*** resource
 #+BEGIN_EXAMPLE
 apiservices
 certificatesigningrequests
 clusterrolebindings
 clusterroles
 componentstatuses
 configmaps
 controllerrevisions
 cronjobs
 csidrivers
 csinodes
 customresourcedefinitions
 daemonsets
 deployments
 e2e-test-crd-publish-openapi-1705-crds
 e2e-test-crd-publish-openapi-2576-crds
 e2e-test-crd-publish-openapi-3791-crds
 e2e-test-crd-publish-openapi-3893-crds
 e2e-test-crd-publish-openapi-4783-crds
 e2e-test-crd-publish-openapi-5430-crds
 e2e-test-crd-publish-openapi-9211-crds
 e2e-test-crd-publish-openapi-9322-crds
 e2e-test-crd-publish-openapi-9371-crds
 e2e-test-crd-publish-openapi-9757-crds
 e2e-test-crd-publish-openapi-9845-crds
 e2e-test-crd-webhook-1243-crds
 e2e-test-crd-webhook-4913-crds
 e2e-test-discovery-422-crds
 e2e-test-kubectl-2997-crds
 e2e-test-kubectl-6759-crds
 e2e-test-kubectl-8022-crds
 e2e-test-resourcequota-7776-crds
 e2e-test-webhook-5821-crds
 e2e-test-webhook-5890-crds
 e2e-test-webhook-7340-crds
 e2e-test-webhook-9447-crds
 endpoints
 events
 flunders
 foo9n5qhas
 fookfwthas
 foox9nb8as
 horizontalpodautoscalers
 ingresses
 jobs
 leases
 limitranges
 mutatingwebhookconfigurations
 namespaces
 networkpolicies
 nodes
 noxus
 null
 persistentvolumeclaims
 persistentvolumes
 poddisruptionbudgets
 podpresets
 pods
 podsecuritypolicies
 podtemplates
 priorityclasses
 replicasets
 replicationcontrollers
 resourcequotas
 rolebindings
 roles
 runtimeclasses
 scalingpolicies
 secrets
 selfsubjectaccessreviews
 serviceaccounts
 services
 statefulsets
 storageclasses
 subjectaccessreviews
 tokenreviews
 validatingwebhookconfigurations
 volumeattachments
 volumesnapshotclasses
 volumesnapshotcontents
 volumesnapshots
 #+END_EXAMPLE

*** subresource
 #+BEGIN_EXAMPLE
 approval
 attach
 binding
 eviction
 exec
 finalize
 log
 null
 portforward
 proxy
 rollback
 scale
 status
 token
 #+END_EXAMPLE

** table
#+BEGIN_SRC sql-mode
CREATE TABLE public.object_refs (
    id integer NOT NULL,
    audit_event_id integer NOT NULL,
    resource text,
    namespace text,
    name text,
    "apiVersion" text,
    "apiGroup" text
);
#+END_SRC

#+RESULTS:
: CREATE TABLE

** sequence
#+BEGIN_SRC sql-mode
CREATE SEQUENCE public.object_refs_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE public.object_refs_id_seq
    OWNED BY public.object_refs.id;
ALTER TABLE ONLY public.object_refs
    ALTER COLUMN id SET DEFAULT nextval('public.object_refs_id_seq'::regclass);
#+END_SRC

#+RESULTS:
: CREATE SEQUENCE
: ALTER SEQUENCE
: ALTER TABLE

** keys
#+BEGIN_SRC sql-mode
ALTER TABLE ONLY public.object_refs
    ADD CONSTRAINT object_refs_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.object_refs
    ADD CONSTRAINT object_refs_audit_event_id_fkey
    FOREIGN KEY (audit_event_id)
    REFERENCES public.audit_events(id)
    ON UPDATE RESTRICT ON DELETE RESTRICT;
#+END_SRC

#+RESULTS:
: ALTER TABLE

* requestObjects
** columns
*** requestKind
#+NAME: requestObject.kind
#+BEGIN_SRC sql-mode
    requestKind text NOT NULL,
#+END_SRC

**** Examples
#+BEGIN_SRC json
"requestObject": {
    "kind": "SubjectAccessReview",
#+END_SRC

#+BEGIN_SRC shell
cat kube-apiserver-audit.log | jq  -r .requestObject.kind | sort | uniq > kinds.txt
cat kube-apiserver-audit.log | jq  -r .responseObject.kind | sort | uniq > rkinds.txt
diff kinds.txt rkinds.txt
#+END_SRC

Only requestObjects include Binding, DeleteOptions, and DeploymentRollback
Only responsesObjects include Status and TokenRequest

#+BEGIN_SRC diff
2d1
< Binding
12d10
< DeleteOptions
14d11
< DeploymentRollback
39a37
> Status
41a40
> TokenRequest
#+END_SRC

*** requestApiVersion
#+NAME: requestObject.apiVersion
#+BEGIN_SRC sql-mode
  requestApiVersion text NOT NULL,
#+END_SRC
Might be tied to level = request, response etc
**** examples
#+BEGIN_SRC json
"requestObject": {
    "apiVersion": "authorization.k8s.io/v1",
#+END_SRC

I'm not sure here, but I feel like we should only be looking at RequestResponse... not all three.
Huh, that was wrong.. the counts differ wildly:

*** requestMeta
#+NAME: requestObject.metadata
#+BEGIN_SRC sql-mode
  requestMeta jsonb NOT NULL,
#+END_SRC
**** examples
#+BEGIN_SRC json
"requestObject": {
    "metadata": {
      "creationTimestamp": null
    },
#+END_SRC
*** requestSpec
#+NAME: requestObject.spec
#+BEGIN_SRC sql-mode
  requestSpec jsonb NOT NULL,
#+END_SRC
**** examples
#+BEGIN_SRC json
"requestObject": {
    "spec": {
      "resourceAttributes": {
        "namespace": "kubernetes-dashboard-6069",
        "verb": "use",
        "group": "extensions",
        "resource": "podsecuritypolicies",
        "name": "e2e-test-privileged-psp"
      },
      "user": "system:serviceaccount:kubernetes-dashboard-6069:default"
    },
#+END_SRC
*** requestStatus
#+NAME: requestObject.status
#+BEGIN_SRC sql-mode
  requestStatus jsonb NOT NULL,
#+END_SRC
**** examples
#+BEGIN_SRC json
  "responseObject": {
    "status": {
      "allowed": true,
      "reason": "RBAC: allowed by RoleBinding \"kubernetes-dashboard-6069--e2e-test-privileged-psp/kubernetes-dashboard-6069\" of ClusterRole \"e2e-test-privileged-psp\" to ServiceAccount \"default/kubernetes-dashboard-6069\""
    }
#+END_SRC

** table

From https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/

#+BEGIN_EXAMPLE
Resource objects typically have 3 components:

Resource ObjectMeta: This is metadata about the resource, such as its name, type, api version, annotations, and labels. This contains fields that maybe updated both by the end user and the system (e.g. annotations).

ResourceSpec: This is defined by the user and describes the desired state of system. Fill this in when creating or updating an object.

ResourceStatus: This is filled in by the server and reports the current state of the system. In most cases, users don't need to change this.
#+END_EXAMPLE



These have more information
#+BEGIN_SRC json
"requestObject": {
    "kind": "SubjectAccessReview",
    "apiVersion": "authorization.k8s.io/v1",
    "metadata": {
      "creationTimestamp": null
    },
    "spec": {
      "resourceAttributes": {
        "namespace": "kubernetes-dashboard-6069",
        "verb": "use",
        "group": "extensions",
        "resource": "podsecuritypolicies",
        "name": "e2e-test-privileged-psp"
      },
      "user": "system:serviceaccount:kubernetes-dashboard-6069:default"
    },
    "status": {
      "allowed": false
    }
  },
#+END_SRC

* responseObjects
** columns
*** responseKind
#+NAME: responseObject.kind
#+BEGIN_SRC sql-mode
    responseKind text NOT NULL,
#+END_SRC

**** Examples
#+BEGIN_SRC json
"responseObject": {
    "kind": "SubjectAccessReview",
#+END_SRC

#+BEGIN_SRC shell
cat kube-apiserver-audit.log | jq  -r .responseObject.kind | sort | uniq > kinds.txt
cat kube-apiserver-audit.log | jq  -r .responseObject.kind | sort | uniq > rkinds.txt
diff kinds.txt rkinds.txt
#+END_SRC

Only responseObjects include Binding, DeleteOptions, and DeploymentRollback
Only responsesObjects include Status and TokenResponse

#+BEGIN_SRC diff
2d1
< Binding
12d10
< DeleteOptions
14d11
< DeploymentRollback
39a37
> Status
41a40
> TokenResponse
#+END_SRC

*** responseApiVersion
#+NAME: responseObject.apiVersion
#+BEGIN_SRC sql-mode
  responseApiVersion text NOT NULL,
#+END_SRC
Might be tied to level = response, response etc
**** examples
#+BEGIN_SRC json
"responseObject": {
    "apiVersion": "authorization.k8s.io/v1",
#+END_SRC

I'm not sure here, but I feel like we should only be looking at ResponseResponse... not all three.
Huh, that was wrong.. the counts differ wildly:

*** responseMeta
#+NAME: responseObject.metadata
#+BEGIN_SRC sql-mode
  responseMeta jsonb NOT NULL,
#+END_SRC
**** examples
#+BEGIN_SRC json
"responseObject": {
    "metadata": {
      "creationTimestamp": null
    },
#+END_SRC
*** responseSpec
#+NAME: responseObject.spec
#+BEGIN_SRC sql-mode
  responseSpec jsonb NOT NULL,
#+END_SRC
**** examples
#+BEGIN_SRC json
"responseObject": {
    "spec": {
      "resourceAttributes": {
        "namespace": "kubernetes-dashboard-6069",
        "verb": "use",
        "group": "extensions",
        "resource": "podsecuritypolicies",
        "name": "e2e-test-privileged-psp"
      },
      "user": "system:serviceaccount:kubernetes-dashboard-6069:default"
    },
#+END_SRC
*** responseStatus
#+NAME: responseObject.status
#+BEGIN_SRC sql-mode
  responseStatus jsonb NOT NULL,
#+END_SRC
**** examples
#+BEGIN_SRC json
  "responseObject": {
    "status": {
      "allowed": true,
      "reason": "RBAC: allowed by RoleBinding \"kubernetes-dashboard-6069--e2e-test-privileged-psp/kubernetes-dashboard-6069\" of ClusterRole \"e2e-test-privileged-psp\" to ServiceAccount \"default/kubernetes-dashboard-6069\""
    }
#+END_SRC

** Notes
#+BEGIN_SRC json
  "responseObject": {
    "kind": "SubjectAccessReview",
    "apiVersion": "authorization.k8s.io/v1",
    "metadata": {
      "creationTimestamp": null
    },
    "spec": {
      "resourceAttributes": {
        "namespace": "kubernetes-dashboard-6069",
        "verb": "use",
        "group": "extensions",
        "resource": "podsecuritypolicies",
        "name": "e2e-test-privileged-psp"
      },
      "user": "system:serviceaccount:kubernetes-dashboard-6069:default"
    },
    "status": {
      "allowed": true,
      "reason": "RBAC: allowed by RoleBinding \"kubernetes-dashboard-6069--e2e-test-privileged-psp/kubernetes-dashboard-6069\" of ClusterRole \"e2e-test-privileged-psp\" to ServiceAccount \"default/kubernetes-dashboard-6069\""
    }
  },
#+END_SRC

* Response Statuses
Not useful for analytics
** Data Set Inspection
#+BEGIN_SRC json
{
  "metadata": {},
  "status": "Failure",
  "reason": "Forbidden",
  "code": 403
}
{
  "metadata": {},
  "code": 200
}
{
  "metadata": {},
  "code": 201
}
{
  "metadata": {},
  "status": "Failure",
  "reason": "NotFound",
  "code": 404
}
#+END_SRC

** table
#+BEGIN_SRC sql-mode
CREATE TABLE public.response_statuses (
    metadata json NOT NULL,
    status text,
    reason text,
    id integer NOT NULL,
    audit_event_id integer NOT NULL,
    code integer
);
#+END_SRC

#+RESULTS:
: CREATE TABLE

** sequences

#+BEGIN_SRC sql-mode
CREATE SEQUENCE public.response_statuses_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;

ALTER SEQUENCE public.response_statuses_id_seq
    OWNED BY public.response_statuses.id;
ALTER TABLE ONLY public.response_statuses
    ALTER COLUMN id SET DEFAULT nextval('public.response_statuses_id_seq'::regclass);
#+END_SRC

#+RESULTS:
: CREATE SEQUENCE
: ALTER SEQUENCE

** keys

#+BEGIN_SRC sql-mode
ALTER TABLE ONLY public.response_statuses
    ADD CONSTRAINT response_statuses_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.response_statuses
    ADD CONSTRAINT response_statuses_audit_event_id_fkey
    FOREIGN KEY (audit_event_id)
    REFERENCES public.audit_events(id)
    ON UPDATE RESTRICT ON DELETE RESTRICT;
#+END_SRC

#+RESULTS:
: ALTER TABLE

* Users

Not sure we need this at this time:

#+BEGIN_SRC shell :eval never
cat kube-apiserver-audit.log | jq -r .user | sort | uniq
#+END_SRC


** table
#+BEGIN_SRC sql-mode
CREATE TABLE public.users_info (
    id integer NOT NULL,
    username text NOT NULL,
    groups json NOT NULL,
    audit_event_id integer NOT NULL
);
#+END_SRC

#+RESULTS:
: CREATE TABLE

** sequence

#+BEGIN_SRC sql-mode
CREATE SEQUENCE public.user_info_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;
ALTER SEQUENCE public.user_info_id_seq OWNED BY public.users_info.id;
ALTER TABLE ONLY public.users_info
    ALTER COLUMN id SET DEFAULT nextval('public.user_info_id_seq'::regclass);
#+END_SRC

#+RESULTS:
: CREATE SEQUENCE
: ALTER SEQUENCE
: ALTER TABLE

** keys

#+BEGIN_SRC sql-mode
ALTER TABLE ONLY public.users_info ADD
    CONSTRAINT user_info_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.users_info ADD
    CONSTRAINT user_info_audit_event_id_fkey
    FOREIGN KEY (audit_event_id)
    REFERENCES public.audit_events(id)
    ON UPDATE RESTRICT ON DELETE RESTRICT;
#+END_SRC

#+RESULTS:
: ALTER TABLE

* Footnotes

# eval: (sql-connect connection (concat "*SQL: postgres:" connection "*"))
# sql-connection-alist: ((hasura (sql-product 'postgres) (sql-user "ygrrlqaucoxunc") (sql-database "d5a2ppmichmu74") (sql-port 5432) (sql-server "ec2-174-129-227-205.compute-1.amazonaws.com")))

# eval: (require 'ob-sql-mode)
# org-babel-load-languages: ((sql-mode . t)(sql . t)(tmate . t))
# org-babel-default-header-args:sql-mode: ((:product . "postgres")(:session . "data"))
# sql-connection-alist: ((hasura (sql-product 'postgres) (sql-user "postgres") (sql-database "data") (sql-port 5432) (sql-server "172.17.0.1")))
# connection: "hasura"
# sql-postgres-options: ("-P" "pager=off" "--no-password")

# Local Variables:
# End:

