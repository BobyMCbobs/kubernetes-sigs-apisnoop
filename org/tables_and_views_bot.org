#+TITLE: APIsnoop Tables and Views
#+AUTHOR: ii team
#+DATE: 07 October 2019
#+INCLUDE: "config.org"
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(b) | TADA(d)
#+ARCHIVE: archive/tables_and_views.archive.org::
#+PROPERTY: header-args:sql-mode+ :results silent

* Purpose
  This org houses all the tables and views that are migrated upon creation of apisnoop: BOT VERSION.  So these are the crucial parts for our prow pr bot.
  
  If you are working on a new view, it is best to do it in our ~explorations~ folder, where it can be iterated and reviewed.  Once that view is determined to be crucial for the database, it would be ported to here, and tangled to a migration file.
  
* 100: Raw Data Tables and Helper Functions
** 100: bucket_job_swagger table
  :PROPERTIES:
  :header-args:sql-mode+: :tangle ../apps/hasura/migrations/100_table_bucket_job_swagger.up.sql
  :END:
*** Create Table
    :PROPERTIES:
    :header-args:sql-mode+: :notangle ../apps/hasura/migrations/100_table_bucket_job_swagger.up.sql
    :END:
 #+NAME: bucket_job_swagger
 #+BEGIN_SRC sql-mode :results silent
   CREATE TABLE bucket_job_swagger (
       ingested_at timestamp DEFAULT CURRENT_TIMESTAMP,
       bucket text,
       job text,
       commit_hash text,
       passed text,
       job_result text,
       pod text,
       infra_commit text,
       job_version text,
       job_timestamp timestamp,
       node_os_image text,
       master_os_image text ,
       swagger jsonb,
       PRIMARY KEY (bucket, job)
   );
 #+END_SRC
*** Index Table
 #+NAME: general index the raw_swagger
 #+BEGIN_SRC sql-mode
   CREATE INDEX idx_swagger_jsonb_ops ON bucket_job_swagger
     USING GIN (swagger jsonb_ops);
   CREATE INDEX idx_swagger_jsonb_path_ops ON bucket_job_swagger
     USING GIN (swagger jsonb_path_ops);
 #+END_SRC
** 101: Function to Load bucket_job_swagger via curl
  :PROPERTIES:
  :header-args:sql-mode+: :tangle ../apps/hasura/migrations/105_function_load_bucket_job_swagger_via_curl.up.sql
  :END:
  
   #+NAME: load_bucket_job_swagger_via_curl.sql
   #+BEGIN_SRC sql-mode :noweb yes :results silent
     set role dba;
     DROP FUNCTION IF EXISTS load_bucket_job_swagger_via_curl;
     CREATE OR REPLACE FUNCTION load_bucket_job_swagger_via_curl(bucket text, job text)
     RETURNS text AS $$
     <<load_bucket_job_swagger_via_curl.py>>
     $$ LANGUAGE plpython3u ;
     reset role;
   #+END_SRC

 #+NAME: load_bucket_job_swagger_via_curl.py
 #+BEGIN_SRC python :eval never :exports code
   try:
       from urllib.request import urlopen, urlretrieve
       from string import Template
       import json
       metadata_url = ''.join(['https://storage.googleapis.com/kubernetes-jenkins/logs/', bucket, '/', job, '/finished.json'])
       metadata = json.loads(urlopen(metadata_url).read().decode('utf-8'))
       commit_hash = metadata["version"].split("+")[1]
       swagger_url =  ''.join(['https://raw.githubusercontent.com/kubernetes/kubernetes/', commit_hash, '/api/openapi-spec/swagger.json']) 
       swagger = json.loads(urlopen(swagger_url).read().decode('utf-8')) # may change this to ascii
       sql = """
    INSERT INTO bucket_job_swagger(
              bucket,
              job,
              commit_hash, 
              passed,
              job_result,
              pod,
              infra_commit,
              job_version,
              job_timestamp,
              node_os_image,
              master_os_image,
              swagger
       )
      SELECT
              $1 as bucket,
              $2 as job,
 s);
    CREATE INDEX api_operation_materialized_consumes_path  ON api_operation_material USING GIN  (consumes jsonb_path_ops);
    CREATE INDEX api_operation_materialized_parameters_ops   ON api_operation_material USING GIN  (parameters jsonb_ops);
    CREATE INDEX api_operation_materialized_parameters_path  ON api_operation_material USING GIN  (parameters jsonb_path_ops);
    CREATE INDEX api_operation_materialized_responses_ops   ON api_operation_material USING GIN  (responses jsonb_ops);
    CREATE INDEX api_operation_materialized_responses_path  ON api_operation_material USING GIN  (responses jsonb_path_ops);
#+END_SRC
** 220: api_operation_parameter_material
  :PROPERTIES:
  :header-args:sql-mode+: :tangle ../apps/hasura/migrations/220_view_api_operation_parameter_material.up.sql
  :END:
*** Create
Using our api_operation_material view, look into the parameters field in each one.     
#+NAME: api_operation_parameter_material view
#+BEGIN_SRC sql-mode
  CREATE MATERIALIZED VIEW "public"."api_operation_parameter_material" AS 
    SELECT ao.operation_id AS param_op,
    (param.entry ->> 'name'::text) AS param_name,
           -- for resource:
           -- if param is body in body, take its $ref from its schema
           -- otherwise, take its type
           replace(
             CASE
             WHEN ((param.entry ->> 'in'::text) = 'body'::text) 
              AND ((param.entry -> 'schema'::text) is not null)
               THEN ((param.entry -> 'schema'::text) ->> '$ref'::text)
             ELSE (param.entry ->> 'type'::text)
             END, '#/definitions/','') AS param_schema,
           CASE
           WHEN ((param.entry ->> 'required'::text) = 'true') THEN true
           ELSE false
            END AS required,
           (param.entry ->> 'description'::text) AS param_description,
           CASE
           WHEN ((param.entry ->> 'uniqueItems'::text) = 'true') THEN true
           ELSE false
           END AS unique_items,
           (param.entry ->> 'in'::text) AS "in",
           ao.bucket,
           ao.job,
           param.entry as entry
      FROM api_operation_material ao
           , jsonb_array_elements(ao.parameters) WITH ORDINALITY param(entry, index)
            WHERE ao.parameters IS NOT NULL;
#+END_SRC
*** Index
#+NAME: index the api_operation_material
#+BEGIN_SRC sql-mode
    CREATE INDEX api_parameters_materialized_schema      ON api_operation_parameter_material            (param_schema);
#+END_SRC

* 300: Audit Event Views
** 300: Audit Events View
  :PROPERTIES:
  :header-args:sql-mode+: :tangle ../apps/hasura/migrations/300_view_audit_event.up.sql
  :END:
*** Create
    #+NAME: view audit_event
    #+BEGIN_SRC sql-mode
      CREATE OR REPLACE VIEW "public"."audit_event" AS
        SELECT (raw.data ->> 'auditID') as audit_id,
               raw.bucket,
               raw.job,
               raw.data ->> 'level' as event_level,
               raw.data ->> 'stage' as event_stage,
               raw.operation_id,
               aop.param_schema,
               raw.data ->> 'verb' as event_verb,
               raw.data ->> 'apiVersion' as api_version,
               raw.data ->> 'requestURI' as request_uri,
               -- Always "Event"
               -- raw.data ->> 'kind' as kind,
               raw.data ->> 'userAgent' as useragent,
               raw.data -> 'user' as event_user,
               raw.data #>> '{objectRef,namespace}' as object_namespace,
               raw.data #>> '{objectRef,resource}' as object_type,
               raw.data #>> '{objectRef,apiGroup}' as object_group,
               raw.data #>> '{objectRef,apiVersion}' as object_ver,
               raw.data -> 'sourceIPs' as source_ips,
               raw.data -> 'annotations' as annotations,
               raw.data -> 'requestObject' as request_object,
               raw.data -> 'responseObject' as response_object,
               raw.data -> 'responseStatus' as response_status,
               raw.data ->> 'stageTimestamp' as stage_timestamp,
               raw.data ->> 'requestReceivedTimestamp' as request_received_timestamp,
               raw.data as data
          FROM raw_audit_event raw
                 LEFT JOIN (
                   select param_op, param_schema
                     from api_operation_parameter_material
                    WHERE param_name = 'body'
                 ) aop
                     ON (raw.operation_id = aop.param_op);
    #+END_SRC
* 500: Endpoint Coverage Views
   :PROPERTIES:
   :header-args:sql-mode+: :results silent
   :END:
** 500: Endpoint Coverage View
   :PROPERTIES:
   :header-args:sql-mode+: :tangle ../apps/hasura/migrations/500_view_endpoint_coverage.up.sql
   :END:
   
   developed in [[file:explorations/ticket_50_endpoint_coverage.org][ticket 50: endpoint coverage]] 
   
   #+NAME: Endpoint Coverage View
   #+BEGIN_SRC sql-mode
     CREATE OR REPLACE VIEW "public"."endpoint_coverage" AS
      SELECT DISTINCT
        bjs.job_timestamp::date as date,
        ao.bucket as bucket,
        ao.job as job,
        ao.operation_id as operation_id,
        ao.level,
        ao.category,
        ao.k8s_group as group,
        ao.k8s_kind as kind,
        ao.k8s_version as version,
        count(*) filter (where ae.useragent like 'e2e.test%') as test_hits,
        count(*) filter (where ae.useragent like 'e2e.test%' AND useragent like '%[Conformance]%') as conf_hits,
        count(*) filter (where ae.useragent not like 'e2e.test%') as other_hits,
        count(ae.useragent) total_hits
        FROM api_operation_material ao
               LEFT JOIN audit_event ae ON (ao.operation_id = ae.operation_id AND ao.bucket = ae.bucket AND ao.job = ae.job)
               LEFT JOIN bucket_job_swagger bjs ON (ao.bucket = bjs.bucket AND ao.job = bjs.job)
          WHERE ao.deprecated IS False
        GROUP BY ao.operation_id, ao.bucket, ao.job, date, ao.level, ao.category, ao.k8s_group, ao.k8s_kind, ao.k8s_version;
   #+END_SRC

** 520: stable endpoint_stats_view
   :PROPERTIES:
   :header-args:sql-mode+: :tangle ../apps/hasura/migrations/520_view_stable_endpoint_stats.up.sql
   :END:
   Based on the update we give to dan, developed in [[file:explorations/ticket_50_endpoint_coverage.org][ticket 50: endpoint coverage]] 
   #+NAME: Endpoint Stats View
   #+BEGIN_SRC sql-mode
     CREATE OR REPLACE VIEW "public"."stable_endpoint_stats" AS
     SELECT
       ec.job,
       ec.date,
       COUNT(1) as total_endpoints,
       COUNT(1) filter(WHERE test_hits > 0) as test_hits,
       COUNT(1) filter(WHERE conf_hits > 0) as conf_hits,
       ROUND(((count(*) filter(WHERE test_hits > 0)) * 100 )::numeric / count(*), 2) as percent_tested,
       ROUND(((count(*) filter(WHERE conf_hits > 0)) * 100 )::numeric / count(*), 2) as percent_conf_tested
       FROM endpoint_coverage ec
         WHERE ec.level = 'stable'
      GROUP BY ec.date, ec.job;
   #+END_SRC
** 530: Change in Coverage 
   :PROPERTIES:
   :header-args:sql-mode+: :tangle ../apps/hasura/migrations/530_view_change_in_coverage.up.sql
   :END:
   #+NAME: Change in Coverage
   #+BEGIN_SRC sql-mode :results replace 
   CREATE OR REPLACE VIEW "public"."change_in_coverage" AS
     with last_two_runs as (
       select
         ,*
         FROM
             stable_endpoint_stats
        ORDER BY 
          date DESC
        LIMIT 2
     ), new_coverage as (
       SELECT *
         FROM last_two_runs
        order by date desc
        limit 1
     ), old_coverage as (
       SELECT *
         FROM last_two_runs
        order by date asc
        limit 1
     )
         (
           select
             'test hits' as category,
             old_coverage.test_hits as old_coverage,
             new_coverage.test_hits as new_coverage,
             (new_coverage.test_hits - old_coverage.test_hits) as change_in_number,
             (new_coverage.percent_tested - old_coverage.percent_tested) as change_in_percent
             from old_coverage
                  , new_coverage
         )
         UNION
         (
           select
             'conf hits' as category,
             old_coverage.conf_hits as old_coverage,
             new_coverage.conf_hits as new_coverage,
             (new_coverage.conf_hits - old_coverage.conf_hits) as change_in_number,
             (new_coverage.percent_conf_tested - old_coverage.percent_conf_tested) as change_in_percent
             from 
                 old_coverage
               , new_coverage
         )
         ;
   #+END_SRC
   
** 540: Change in Tests 
   :PROPERTIES:
   :header-args:sql-mode+: :tangle ../apps/hasura/migrations/540_view_change_in_tests.up.sql
   :END:
   #+NAME: Change in Tests
   #+begin_src sql-mode
   CREATE OR REPLACE VIEW "public"."change_in_tests" AS
     with last_two_runs as (
       select
         job, job_timestamp
         FROM
             bucket_job_swagger
        ORDER BY 
          job_timestamp DESC
        LIMIT 2
     ),
       new_run as (
         SELECT 
           job
           FROM last_two_runs
          order by job_timestamp DESC
          limit 1
       ),
       old_run as (
         SELECT
           job
           FROM
               last_two_runs
          order by job_timestamp asc
          limit 1
       )
         (
           SELECT
             test,
             'added' as status
             FROM
                 (
                   (
                     SELECT DISTINCT
                       split_part(useragent, '--', 2) as test
                       FROM
                           audit_event
                           INNER JOIN new_run on (audit_event.job = new_run.job)
                   )
                   EXCEPT
                   (
                     SELECT DISTINCT
                       split_part(useragent, '--', 2) as test
                       FROM
                           audit_event
                           INNER JOIN old_run on (audit_event.job = old_run.job)
                   )
                 ) added_tests
         )
         UNION
         (
           SELECT
             test,
             'removed' as status
             FROM
                 (
                   (
                     SELECT DISTINCT
                       split_part(useragent, '--', 2) as test
                       FROM
                           audit_event
                           INNER JOIN old_run on (audit_event.job = old_run.job)
                   )
                   EXCEPT
                   (
                     SELECT DISTINCT
                       split_part(useragent, '--', 2) as test
                       FROM
                           audit_event
                           INNER JOIN new_run on (audit_event.job = new_run.job)
                   )
                 ) removed_tests
         )
         ;

   #+end_src
* 900: Tracking
** 900: Populate bucket_job_swagger Up
  :PROPERTIES:
  :header-args:sql-mode+: :tangle ../apps/hasura/migrations/900_load_and_populate_swaggers.up.sql
  :header-args:sql-mode+: :results silent
  :END:
  
  #+NAME: populate bucket_job_swagger
  #+begin_src sql-mode
    select * from load_bucket_job_swagger_via_curl('ci-kubernetes-e2e-gci-gce', '1183553991464718336');
  #+end_src
  
** 910: populate_audit_events.up.sql
  :PROPERTIES:
  :header-args:sql-mode+: :tangle ../apps/hasura/migrations/910_populate_audit_events.up.sql
  :END:
  
  #+NAME: Load Audit Events
  #+begin_src sql-mode
    select * from load_audit_events('ci-kubernetes-e2e-gci-gce', '1183553991464718336');
    REFRESH MATERIALIZED VIEW api_operation_material;
    REFRESH MATERIALIZED VIEW api_operation_parameter_material;
  #+end_src
  
** 999: Tracking Tables
   :PROPERTIES:
   :header-args:yaml+: :tangle ../apps/hasura/migrations/999_tracking.up.yaml
   :END:
*** bucket_job_swagger
#+NAME: track api_swagger
#+BEGIN_SRC yaml
- type: track_table
  args:
    schema: public
    name: bucket_job_swagger
#+END_SRC
*** raw_audit_event
#+NAME: track raw_audit_event
#+BEGIN_SRC yaml
- type: track_table
  args:
    schema: public
    name: raw_audit_event
#+END_SRC
*** audit_event
 #+NAME: track audit_event
 #+BEGIN_SRC yaml
 - type: track_table
   args:
     schema: public
     name: audit_event
 #+END_SRC

*** stable_endpoint_stats
 #+NAME: track endpoint_stats
 #+BEGIN_SRC yaml 
 - type: track_table
   args:
     schema: public
     name: stable_endpoint_stats
 #+END_SRC
*** Change in Coverage 
 #+NAME: track change_in_coverage 
 #+BEGIN_SRC yaml 
 - type: track_table
   args:
     schema: public
     name: change_in_coverage 
 #+END_SRC
*** stable_endpoint_stats
 #+NAME: track change_in_tests 
 #+BEGIN_SRC yaml 
 - type: track_table
   args:
     schema: public
     name: change_in_tests 
 #+END_SRC
* Footnotes
- [X] Connect to your postgres db from within this file
  You'll want execute this code block by moving your cursor within and typing =,,=
  
  #+NAME: Connect org to postgres
  #+BEGIN_SRC emacs-lisp :results silent
    (sql-connect "apisnoop" (concat "*SQL: postgres:data*"))
  #+END_SRC

- [X] Test your connection works
  You can run this sql block, and it see a message in your minbuffer like:
  : You are connected to database "apisnoop" as user "apisnoop" on host "localhost" at port "10041".

  #+NAME: Test Connection
  #+BEGIN_SRC sql-mode :results silent
    \conninfo
  #+END_SRC
  
 #+BEGIN_SRC sql-mode
 select * from stable_endpoint_stats;
 #+END_SRC

 #+RESULTS:
 #+begin_src sql-mode
          job         |    date    | total_endpoints | test_hits | conf_hits | percent_tested | percent_conf_tested 
 ---------------------+------------+-----------------+-----------+-----------+----------------+---------------------
  1181584183475048448 | 2019-10-08 |             430 |       165 |       114 |          38.37 |               26.51
  1178464478988079104 | 2019-09-30 |             430 |       171 |       124 |          39.77 |               28.84
  1173412183980118017 | 2019-09-16 |             430 |       171 |       118 |          39.77 |               27.44
 (3 rows)

 #+end_src
 
