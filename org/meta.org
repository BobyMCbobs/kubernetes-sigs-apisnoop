#+NAME: META
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(b) | TADA(d)

* Purpose
  This holds the authorative way to get setup and exploring with our hasura backend.

* Working with this repo/org file
** Work happens in Org first
   Within ii, our emphasis is on the documentation/org-file first.  
   We can document and craft the queries for our db, then tangle them into our migration files.
   as such: 
   *NOTE: Don't commit the hasura/migrations, they should be tangled from the org file.*
   In the future, we may add a commit hook that tangles org => hasura
* Iteration Loop
** listing tables
#+BEGIN_SRC sql-mode
  \conninfo
  \d+
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
You are connected to database "zz" as user "zz" on host "172.17.0.1" at port "5432".
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
Did not find any relations.
#+end_src

** dropping all data
#+NAME: do not run
#+BEGIN_SRC sql-mode
  drop table raw_swaggers cascade;
  drop table raw_audit_events cascade;
  drop table zraw_audit_events cascade;
  drop schema hdb_catalog cascade;
  drop schema hdb_views cascade;
#+END_SRC

#+RESULTS: do not run
#+begin_src sql-mode
NOTICE:  drop cascades to 7 other objects
DETAIL:  drop cascades to view api_operations
drop cascades to view api_operations_parameters
drop cascades to view api_operations_responses
drop cascades to view api_resources
drop cascades to view api_resources_fields
drop cascades to view over
drop cascades to materialized view api_operations_material
DROP TABLE
#+end_src

** Restart Hasura
   #+NAME: iteration loop
   #+BEGIN_SRC tmate 
     #:dir ~/ii/apisnoop_v3/apps/hasura
     cd ~/ii/apisnoop_v3/apps/hasura
     echo docker-compose down
     docker-compose down
     # drop all data while down
     echo 'drop table raw_swaggers cascade; drop table raw_audit_events cascade; drop schema hdb_views cascade; drop schema hdb_catalog cascade; drop table zraw_audit_events cascade;' | psql
     echo docker-compose up
     docker-compose up -d
   #+END_SRC

   #+RESULTS: iteration loop
   #+begin_EXAMPLE
   #+end_EXAMPLE

** setting up the hasura postgresql-permissions
   
Run the following as the postgres user via psql:
https://docs.hasura.io/1.0/graphql/manual/deployment/postgres-permissions.html

#+NAME: hasura-user
#+BEGIN_SRC shell :results silent
echo -n $USER
#+END_SRC

#+NAME: create database and granting all privs to a user
#+BEGIN_SRC sql-mode :noweb yes :tangle ../apps/hasura/db_setup.sql
create database <<hasura-user()>>;
-- create user myuser with encrypted password 'mypass';
grant all privileges on database <<hasura-user()>> to <<hasura-user()>>;
create role dba with superuser noinherit;
grant dba to <<hasura-user()>>;
\connect <<hasura-user()>>
-- we write python functions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS plpython3u;
CREATE EXTENSION IF NOT EXISTS plsh;
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS pg_trgm;
CREATE SCHEMA IF NOT EXISTS hdb_catalog;
CREATE SCHEMA IF NOT EXISTS hdb_views;
-- make the user an owner of system schemas
ALTER SCHEMA hdb_catalog OWNER TO <<hasura-user()>>;
ALTER SCHEMA hdb_views OWNER TO <<hasura-user()>>;
GRANT SELECT ON ALL TABLES IN SCHEMA information_schema TO <<hasura-user()>>;
GRANT SELECT ON ALL TABLES IN SCHEMA pg_catalog TO <<hasura-user()>>;
GRANT USAGE ON SCHEMA public TO <<hasura-user()>>;
GRANT ALL ON ALL TABLES IN SCHEMA public TO <<hasura-user()>>;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO <<hasura-user()>>;
GRANT pg_execute_server_program TO <<hasura-user()>>;
#+END_SRC

#+RESULTS: create database and granting all privs to a user
#+begin_src sql-mode
ERROR:  database "zz" already exists
WARNING:  no privileges were granted for "zz"
GRANT
ERROR:  must be superuser to create superusers
ERROR:  must be superuser to alter superusers
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
You are now connected to database "zz" as user "zz".
NOTICE:  extension "uuid-ossp" already exists, skipping
CREATE EXTENSION
NOTICE:  extension "plpython3u" already exists, skipping
CREATE EXTENSION
ERROR:  permission denied to create extension "plsh"
HINT:  Must be superuser to create this extension.
NOTICE:  extension "pgcrypto" already exists, skipping
CREATE EXTENSION
NOTICE:  schema "hdb_catalog" already exists, skipping
CREATE SCHEMA
NOTICE:  schema "hdb_views" already exists, skipping
CREATE SCHEMA
ALTER SCHEMA
ALTER SCHEMA
WARNING:  no privileges were granted for "sql_features"
WARNING:  no privileges were granted for "sql_implementation_info"
WARNING:  no privileges were granted for "sql_languages"
WARNING:  no privileges were granted for "sql_packages"
WARNING:  no privileges were granted for "sql_parts"
WARNING:  no privileges were granted for "sql_sizing"
WARNING:  no privileges were granted for "sql_sizing_profiles"
WARNING:  no privileges were granted for "collations"
WARNING:  no privileges were granted for "collation_character_set_applicability"
WARNING:  no privileges were granted for "column_domain_usage"
WARNING:  no privileges were granted for "constraint_column_usage"
WARNING:  no privileges were granted for "domains"
WARNING:  no privileges were granted for "constraint_table_usage"
WARNING:  no privileges were granted for "domain_constraints"
WARNING:  no privileges were granted for "role_column_grants"
WARNING:  no privileges were granted for "enabled_roles"
WARNING:  no privileges were granted for "referential_constraints"
WARNING:  no privileges were granted for "parameters"
WARNING:  no privileges were granted for "routine_privileges"
WARNING:  no privileges were granted for "role_routine_grants"
WARNING:  no privileges were granted for "routines"
WARNING:  no privileges were granted for "schemata"
WARNING:  no privileges were granted for "table_constraints"
WARNING:  no privileges were granted for "sequences"
WARNING:  no privileges were granted for "triggered_update_columns"
WARNING:  no privileges were granted for "table_privileges"
WARNING:  no privileges were granted for "role_table_grants"
WARNING:  no privileges were granted for "triggers"
WARNING:  no privileges were granted for "tables"
WARNING:  no privileges were granted for "transforms"
WARNING:  no privileges were granted for "role_udt_grants"
WARNING:  no privileges were granted for "udt_privileges"
WARNING:  no privileges were granted for "role_usage_grants"
WARNING:  no privileges were granted for "usage_privileges"
WARNING:  no privileges were granted for "user_defined_types"
WARNING:  no privileges were granted for "view_column_usage"
WARNING:  no privileges were granted for "view_routine_usage"
WARNING:  no privileges were granted for "view_table_usage"
WARNING:  no privileges were granted for "views"
WARNING:  no privileges were granted for "data_type_privileges"
WARNING:  no privileges were granted for "user_mapping_options"
WARNING:  no privileges were granted for "element_types"
WARNING:  no privileges were granted for "_pg_foreign_table_columns"
WARNING:  no privileges were granted for "column_options"
WARNING:  no privileges were granted for "_pg_foreign_data_wrappers"
WARNING:  no privileges were granted for "foreign_data_wrapper_options"
WARNING:  no privileges were granted for "user_mappings"
WARNING:  no privileges were granted for "foreign_data_wrappers"
WARNING:  no privileges were granted for "_pg_foreign_servers"
WARNING:  no privileges were granted for "foreign_server_options"
WARNING:  no privileges were granted for "foreign_servers"
WARNING:  no privileges were granted for "_pg_foreign_tables"
WARNING:  no privileges were granted for "key_column_usage"
WARNING:  no privileges were granted for 
#+end_src

#+NAME: as posgres admin, setup hasura user and db
#+BEGIN_SRC tmate
#+BEGIN_SRC shell  :var SUDO_ASKPASS="/usr/bin/ssh-askpass" :prologue "export SUDO_ASKPASS"
# :var DISPLAY=":0.0"
sudo su - postgres -c psql < ~/ii/apisnoop_v3/apps/hasura/db_setup.sql
#+END_SRC

#+RESULTS: as posgres admin, setup hasura user and db
#+begin_EXAMPLE
#+end_EXAMPLE

* Hasura
** config.yaml

Can be used by itself to run hasura cli or console from another host

#+BEGIN_SRC yaml :tangle ../apps/hasura/config.yaml
endpoint: http://sharing.io:8888
#+END_SRC

** docker-compose.yml
#+BEGIN_SRC yaml :tangle ../apps/hasura/docker-compose.yaml
  # hasura/docker-compose.yaml
  version: "3.7"

  services:
   hasura:
      #image: hasura/graphql-engine:v1.0.0-beta.3
      # append '.cli-migrations' to auto run 'hasura migrations apply'
      container_name: "${USER}-hasura"
      image: hasura/graphql-engine:v1.0.0-beta.4.cli-migrations
      restart: always
      networks:
        - web
      environment:
        # Should try and set database be read only for public
        #- HASURA_GRAPHQL_DATABASE_URL=postgres://non-priv-user@172.17.0.1:5432/database-name
        #- HASURA_GRAPHQL_DATABASE_URL=postgres://non-priv-user@172.17.0.1:5432/$OUTER-USER
        # https://docs.docker.com/compose/compose-file/#variable-substitution
        # https://docs.docker.com/compose/env-file/
        - "HASURA_GRAPHQL_DATABASE_URL=postgres://${USER}@172.17.0.1:5432/${USER}"
        - HASURA_GRAPHQL_ENABLE_CONSOLE=true
      volumes:
        - ./migrations:/hasura-migrations
      expose:
        - "8080"
      labels:
        - "traefik.docker.network=web"
        - "traefik.enable=true"
        - "traefik.basic.port=8080"
        - "traefik.basic.protocol=http"
        - "traefik.basic.frontend.rule=Host:${USER}-hasura.sharing.io"
  #volumes:
  #  migrations:
  networks:
    web:
      external: true
#+END_SRC

** start hasura

#+BEGIN_SRC shell :dir hasura
docker-compose up -d
#+END_SRC

#+RESULTS:
#+begin_EXAMPLE
#+end_EXAMPLE
** Watch hasura logs

#+BEGIN_SRC emacs-lisp
    (defun hasura-logs ()
      (interactive)
      (setq *hasura-buffer*
            (get-buffer-create "hasura-logs"))
      (with-current-buffer *hasura-buffer*
        (ansi-color-for-comint-mode-on)
        (comint-mode)
        (spacemacs/toggle-line-numbers-on)
       ;; (linum-mode t)
        )
      (let ((default-directory (file-name-directory (concat (file-name-directory buffer-file-name) "../apps/hasura/")))
            (logs-command "docker-compose logs -f --no-color")
            ;; (logs-command "tail -f /var/log/messages")
            ;;(logs-command "docker-compose logs -f --no-color 2>/dev/null | sed 's:hasura_1  | ::g' | grep '^{' | jq .")
            )
        (setq *hasura-process*
              (start-file-process-shell-command
               "hasura" *hasura-buffer* logs-command))
        (set-process-filter *hasura-process* 'comint-output-filter)
  )
      )
    (hasura-logs)
    ;; unsure how to display
    ;; (add-to-list 'display-buffer-alist
    ;;            '("hasura-logs" . ((display-buffer-pop-up-window) .
    ;;                               ((inhibit-same-window . t)))))
    ;; (
    ;; display-buffer (get-buffer "hasura-logs") nil)
    ;; "docker-compose logs -f| jq .")
#+END_SRC

#+RESULTS:
#+begin_src emacs-lisp
comint-output-filter
#+end_src

* OpenAPI / Swagger Table
** swagger.json

#+NAME: raw_swaggers
#+BEGIN_SRC sql-mode :tangle ../apps/hasura/migrations/100_table_raw_swaggers.up.sql :results silent
CREATE UNLOGGED TABLE raw_swaggers (
    id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ingested_at timestamp DEFAULT CURRENT_TIMESTAMP,
    -- version text NOT NULL,
    -- definition_id text NOT NULL,
    data jsonb NOT NULL
);
#+END_SRC

#+NAME: track raw_swaggers
#+BEGIN_SRC yaml :tangle ../apps/hasura/migrations/100_table_raw_swaggers.up.yaml
- type: track_table
  args:
    schema: public
    name: raw_swaggers
#+END_SRC
** swagger.json INDEX

#+NAME: general index the raw_swagger
#+BEGIN_SRC sql-mode :tangle ../apps/hasura/migrations/100_table_raw_swaggers.up.sql :results silent
CREATE INDEX idx_swagger_jsonb_ops ON raw_swaggers USING GIN (data jsonb_ops);
CREATE INDEX idx_swagger_jsonb_path_ops ON raw_swaggers USING GIN (data jsonb_path_ops);
     -- api_operations view:
     --  , jsonb_each((raw_swaggers.data -> 'paths'::text)) paths(key, value)
     --  , jsonb_each(paths.value) d(key, value)
     --  , jsonb_array_elements((d.value -> 'tags'::text)) cat_tag(value)
     --  , jsonb_array_elements((d.value -> 'tags'::text)) jsonstring(value)
     --  , jsonb_array_elements((d.value -> 'schemes'::text)) schemestring(value)
     -- GROUP BY raw_swaggers.id, paths.key, d.key, d.value, cat_tag.value
     -- ORDER BY paths.key;
     -- api_resources view:
     --   , jsonb_each((raw_swaggers.data -> 'definitions'::text)) d(key, value)
     --   , jsonb_array_elements((d.value -> 'required'::text)) reqstring(value)
     -- GROUP BY raw_swaggers.id, d.key, d.value;
-- CREATE INDEX idx_swagger_X ON raw_swagger USING GIN ((jsb->‘X’));
-- CREATE INDEX idx_swagger_X ON raw_swagger USING BTREE ((jsb->>‘X’));
-- CREATE INDEX idx_swagger_X ON raw_swagger USING HASH ((jsb->>‘X’))
#+END_SRC

** load swagger via curl

#+NAME: load_swagger_via_curl.py
#+BEGIN_SRC python :eval never
  # should probably sanitize branch_or_tag
  try:
      from string import Template
      sql = Template("copy raw_swaggers (data) FROM PROGRAM '$curl' (DELIMITER e'\x02', FORMAT 'csv', QUOTE e'\x01');").substitute(
          curl =  f'curl https://raw.githubusercontent.com/kubernetes/kubernetes/{branch_or_tag}/api/openapi-spec/swagger.json | jq -c .'
      )
      rv = plpy.execute(sql)
      return "it worked"
  except:
      return "something went wrong"
#+END_SRC

#+NAME: load_swagger_via_curl.sql
#+BEGIN_SRC sql-mode :noweb yes :tangle ../apps/hasura/migrations/120_function_load_swagger_via_curl.up.sql :results silent
  set role dba;
  CREATE OR REPLACE FUNCTION load_swagger_via_curl(branch_or_tag text)
  RETURNS text AS $$
  <<load_swagger_via_curl.py>>
  $$ LANGUAGE plpython3u ;
  reset role;
#+END_SRC

#+NAME: reload swaggers for particluar releases
#+BEGIN_SRC sql-mode :noweb yes :tangle ../apps/hasura/migrations/130_populate_swaggers.up.sql :results silent
  delete from raw_swaggers;
  select * from load_swagger_via_curl('master');
  -- select * from load_swagger_via_curl('release-1.15');
  -- select * from load_swagger_via_curl('release-1.14');
  -- select * from load_swagger_via_curl('release-1.13');
  -- select * from load_swagger_via_curl('release-1.12');
  -- select * from load_swagger_via_curl('release-1.11');
  -- select * from load_swagger_via_curl('release-1.10');
#+END_SRC

#+NAME: number of raw_swaggers
#+BEGIN_SRC sql-mode
  select count(*) from raw_swaggers;
#+END_SRC

#+RESULTS: number of raw_swaggers
#+begin_src sql-mode
 count 
-------
     1
(1 row)

#+end_src

#+BEGIN_SRC sql-mode
\dt+
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
                          List of relations
 Schema |       Name       | Type  | Owner |    Size    | Description 
--------+------------------+-------+-------+------------+-------------
 public | raw_audit_events | table | hh    | 8192 bytes | 
 public | raw_swaggers     | table | hh    | 1752 kB    | 
(2 rows)

#+end_src

* Raw Audit Events JSONB Table
** raw_audit_events table

#+NAME: raw_audit_events
#+BEGIN_SRC sql-mode :tangle ../apps/hasura/migrations/220_table_raw_audit_events.up.sql :results silent
  CREATE UNLOGGED TABLE raw_audit_events (
    -- id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    -- ingested_at timestamp DEFAULT CURRENT_TIMESTAMP,
    bucket text,
    job text,
    audit_id text NOT NULL,
    stage text NOT NULL,
    event_verb text NOT NULL,
    request_uri text NOT NULL,
    operation_id text,
    data jsonb NOT NULL
  );
#+END_SRC
** raw_audit_events track

#+NAME: track raw_audit_events
#+BEGIN_SRC yaml :tangle ../apps/hasura/migrations/220_table_raw_audit_events.up.yaml
- type: track_table
  args:
    schema: public
    name: raw_audit_events
#+END_SRC
** raw_audit_events INDEX

#+NAME: index the raw_audit_events
#+BEGIN_SRC sql-mode :tangle ../apps/hasura/migrations/220_table_raw_audit_events.up.sql :results silent
CREATE PRIMARY INDEX idx_audit_events_primary          ON raw_audit_events (bucket, job, audit_id, stage);
ALTER TABLE raw_audit_events add primary key using index idx_audit_events_primary;
CREATE INDEX idx_audit_events_jsonb_ops        ON raw_audit_events USING GIN (data jsonb_ops);
CREATE INDEX idx_audit_events_jsonb_path_jobs  ON raw_audit_events USING GIN (data jsonb_path_ops);
#+END_SRC


#+NAME: index notes
#+BEGIN_SRC sql-mode
-- CREATE INDEX idx_audit_events_level_btree      ON raw_audit_events USING BTREE ((data->>'level'));
-- CREATE INDEX idx_audit_events_level_hash       ON raw_audit_events USING HASH  ((data->>'level'));
-- CREATE INDEX idx_audit_events_stage_btree      ON raw_audit_events USING BTREE ((data->>'stage'));
-- CREATE INDEX idx_audit_events_stage_hash       ON raw_audit_events USING HASH  ((data->>'stage'));
-- CREATE INDEX idx_audit_events_verb_btree       ON raw_audit_events USING BTREE ((data->>'verb'));
-- CREATE INDEX idx_audit_events_verb_hash        ON raw_audit_events USING HASH  ((data->>'verb'));
-- CREATE INDEX idx_audit_events_apiVersion_btree ON raw_audit_events USING BTREE ((data->>'apiVersion'));
-- CREATE INDEX idx_audit_events_apiVersion_hash  ON raw_audit_events USING HASH  ((data->>'apiVersion'));
-- CREATE INDEX idx_audit_events_requestURI_btree ON raw_audit_events USING BTREE ((data->>'requestURI'));
-- CREATE INDEX idx_audit_events_requestURI_hash  ON raw_audit_events USING HASH  ((data->>'requestURI'));
-- CREATE INDEX idx_audit_events_userAgent_btree  ON raw_audit_events USING BTREE ((data->>'userAgent'));
-- CREATE INDEX idx_audit_events_userAgent_hash   ON raw_audit_events USING HASH  ((data->>'userAgent'));
-- CREATE INDEX idx_audit_events_namespace_btree  ON raw_audit_events USING BTREE ((data->'objectRef' ->> 'namespace'));
-- CREATE INDEX idx_audit_events_namespace_hash   ON raw_audit_events USING HASH  ((data->'objectRef' ->> 'namespace'));
-- CREATE INDEX idx_audit_events_resource_btree   ON raw_audit_events USING BTREE ((data->'objectRef' ->> 'resource'));
-- CREATE INDEX idx_audit_events_resource_hash    ON raw_audit_events USING HASH  ((data->'objectRef' ->> 'resource'));
-- CREATE INDEX idx_audit_events_apiGroup_btree   ON raw_audit_events USING BTREE ((data->'objectRef' ->> 'apiGroup'));
-- CREATE INDEX idx_audit_events_apiGroup_hash    ON raw_audit_events USING HASH  ((data->'objectRef' ->> 'apiGroup'));
-- CREATE INDEX idx_audit_events_apiVersion_btree ON raw_audit_events USING BTREE ((data->'objectRef' ->> 'apiVersion'));
-- CREATE INDEX idx_audit_events_apiVersion_hash  ON raw_audit_events USING HASH  ((data->'objectRef' ->> 'apiVersion'));
-- CREATE INDEX idx_audit_events_requests_gin     ON raw_audit_events USING GIN ((data->'requestObject'));
-- CREATE INDEX idx_audit_events_requests_gin     ON raw_audit_events USING GIN ((data->'requestObject'));
-- CREATE INDEX idx_audit_events_namespace_hash   ON raw_audit_events USING HASH  ((data->'objectRef' ->> 'namespace'));
-- CREATE INDEX idx_audit_events_X_gin  ON raw_audit_events USING GIN ((data->'X'));
-- CREATE INDEX idx_audit_events_X_btree ON raw_audit_events USING BTREE ((data->'X'));
-- CREATE INDEX idx_audit_events_X_hash ON raw_audit_events USING HASH ((data->'X'));
-- CREATE INDEX idx_audit_events_X ON raw_audit_events USING GIN ((jsb->‘X’));
-- CREATE INDEX idx_audit_events_X ON raw_audit_events USING BTREE ((jsb->>‘X’));
-- CREATE INDEX idx_audit_events_X ON raw_audit_events USING HASH ((jsb->>‘X’))
#+END_SRC
** load audit_events via plpython3u
*** old cat
#+NAME: raw_audit_events_import.sql
#+BEGIN_SRC sql-mode
  CREATE TEMPORARY TABLE raw_audit_events_import (data jsonb not null) ;

  COPY raw_audit_events_import (data)
  FROM PROGRAM '${cat}' (DELIMITER e'\x02', FORMAT 'csv', QUOTE e'\x01');

  INSERT INTO raw_audit_events(data, bucket, job)
  SELECT data, '${bucket}', '${job}'
    FROM raw_audit_events_import;
#+END_SRC
*** new file based loader
 #+NAME: experimental_raw_audit_events_import.sql
 #+BEGIN_SRC sql-mode :notangle ../apps/hasura/migrations/222_function_verb_to_method.up.sql :results silent
   CREATE TEMPORARY TABLE raw_audit_events_import (data jsonb not null) ;
   COPY raw_audit_events_import (data)
   FROM '${audit_logfile}' (DELIMITER e'\x02', FORMAT 'csv', QUOTE e'\x01');

   INSERT INTO raw_audit_events(bucket, job,
                                audit_id, event_verb, request_uri,
                                operation_id,
                                data)
   SELECT '${bucket}', '${job}',
          (raw.data ->> 'auditID'), (raw.data ->> 'verb'), (raw.data ->> 'requestURI'),
          ops.operation_id,
          raw.data 
     FROM raw_audit_events_import raw
            JOIN api_operations_material ops ON
            ops.raw_swagger_id = 1
                AND raw.data ->> 'verb' = ops.event_verb
                AND raw.data ->> 'requestURI' ~ ops.regex;
 #+END_SRC

#+NAME: raw_audit_event_import_file function.sql
#+BEGIN_SRC sql-mode :notangle ../apps/hasura/migrations/222_function_verb_to_method.up.sql :results silent
  CREATE FUNCTION raw_audit_event_import_file(bucket text, job text, filepath text) RETURNS text as $$
  BEGIN
   CREATE TEMPORARY TABLE raw_audit_events_import (data jsonb not null) ;
   -- We need dynamic execution... BEWARE of 
   -- https://www.postgresql.org/docs/11/sql-execute.html
   -- https://www.postgresql.org/docs/current/functions-string.html#FUNCTIONS-STRING-OTHER
   EXECUTE format ('
   COPY raw_audit_events_import (data)
   FROM %L (DELIMITER e'\x02', FORMAT 'csv', QUOTE e'\x01');
   ', filepath)

   INSERT INTO raw_audit_events(bucket, job,
                                audit_id, event_verb, request_uri,
                                operation_id,
                                data)
   SELECT bucket, job,
          (raw.data ->> 'auditID'), (raw.data ->> 'verb'), (raw.data ->> 'requestURI'),
          ops.operation_id,
          raw.data 
     FROM raw_audit_events_import raw
            JOIN api_operations_material ops ON
            ops.raw_swagger_id = 1
                AND raw.data ->> 'verb' = ANY(ops.event_verb)
                AND raw.data ->> 'requestURI' ~ ops.regex;
   RETURN 'SUCCESS';
  END;
  $$ LANGUAGE plpgsql;
#+END_SRC
*** load_audit_events.py 
 #+NAME: load_audit_events.py
 #+BEGIN_SRC python :noweb yes 
   #:tangle ../apps/hasura/migrations/245_function_load_audit_events.up.sql :results silent
   #!/usr/bin/env python3
   from urllib.request import urlopen, urlretrieve
   import os
   import re
   from bs4 import BeautifulSoup
   import subprocess
   import time
   import glob
   from tempfile import mkdtemp
   from string import Template


   def get_html(url):
       html = urlopen(url).read()
       soup = BeautifulSoup(html, 'html.parser')
       return soup


   def download_url_to_path(url, local_path):
       local_dir = os.path.dirname(local_path)
       if not os.path.isdir(local_dir):
           os.makedirs(local_dir)
       if not os.path.isfile(local_path):
           process = subprocess.Popen(['wget', '-q', url, '-O', local_path])
           downloads[local_path] = process

   # this global dict is used to track our wget subprocesses
   # wget was used because the files can get to several halfa gig
   downloads = {}
   def load_audit_events(bucket,job):
       bucket_url = f'https://storage.googleapis.com/kubernetes-jenkins/logs/{bucket}/{job}/'
       artifacts_url = f'https://gcsweb.k8s.io/gcs/kubernetes-jenkins/logs/{bucket}/{job}/artifacts'
       job_metadata_files = [
           'finished.json',
           'artifacts/metadata.json',
           'artifacts/junit_01.xml',
           'build-log.txt'
       ]
       download_path = mkdtemp( dir='/tmp', prefix=f'apisnoop-{bucket}-{job}' ) + '/'
       combined_log_file = download_path + 'audit.log'

       # meta data to download
       for jobfile in job_metadata_files:
           download_url_to_path( bucket_url + jobfile,
                                 download_path + jobfile )

       # Use soup to grab url of each of audit.log.* (some end in .gz)
       soup = get_html(artifacts_url)
       master_link = soup.find(href=re.compile("master"))
       master_soup = get_html(
           "https://gcsweb.k8s.io" + master_link['href'])
       log_links = master_soup.find_all(
           href=re.compile("audit.log"))

       # download all logs
       for link in log_links:
           log_url = link['href']
           log_file = download_path + os.path.basename(log_url)
           download_url_to_path( log_url, log_file)

       # Our Downloader uses subprocess of curl for speed
       for download in downloads.keys():
           # Sleep for 5 seconds and check for next download
           while downloads[download].poll() is None:
               time.sleep(5)
               # print("Still downloading: " + download)
           # print("Downloaded: " + download)

       # Loop through the files, (z)cat them into a combined audit.log
       with open(combined_log_file, 'ab') as log:
           for logfile in sorted(
                   glob.glob(download_path + '*kube-apiserver-audit*'), reverse=True):
               if logfile.endswith('z'):
                   subprocess.run(['zcat', logfile], stdout=log, check=True)
               else:
                   subprocess.run(['cat', logfile], stdout=log, check=True)
       # Load the resulting combined audit.log directly into raw_audit_events
       try:
           # for some reason tangling isn't working to reference this SQL block
           sql = Template("""
   CREATE TEMPORARY TABLE raw_audit_events_import (data jsonb not null) ;
   COPY raw_audit_events_import (data)
   FROM '${audit_logfile}' (DELIMITER e'\x02', FORMAT 'csv', QUOTE e'\x01');

   INSERT INTO raw_audit_events(bucket, job,
                                audit_id, stage,
                                event_verb, request_uri,
                                operation_id,
                                data)
   SELECT '${bucket}', '${job}',
          (raw.data ->> 'auditID'), (raw.data ->> 'stage'),
          (raw.data ->> 'verb'), (raw.data ->> 'requestURI'),
          ops.operation_id,
          raw.data 
     FROM raw_audit_events_import raw
            LEFT JOIN api_operations_material ops ON
            ops.raw_swagger_id = 1
                AND raw.data ->> 'verb' = ANY(ops.event_verb)
                AND raw.data ->> 'requestURI' ~ ops.regex;
           """).substitute(
               audit_logfile = combined_log_file,
               bucket = bucket,
               job = job
           )
           with open(download_path + 'load.sql', 'w') as sqlfile:
             sqlfile.write(sql)
           rv = plpy.execute(sql)
           return "it worked"
       except plpy.SPIError:
           return "something went wrong with plpy"
       except:
           return "something unknown went wrong"
   if __name__ == "__main__":
       load_audit_events('ci-kubernetes-e2e-gci-gce','1134962072287711234')
   else:
       load_audit_events(bucket,job)
 #+END_SRC

** load_audit_events.sql

#+NAME: load_audit_events.sql
#+BEGIN_SRC sql-mode :noweb yes :tangle ../apps/hasura/migrations/245_function_load_audit_events.up.sql :results silent
  set role dba;
  CREATE OR REPLACE FUNCTION load_audit_events(bucket text, job text)
  RETURNS text AS $$
  <<load_audit_events.py>>
  $$ LANGUAGE plpython3u ;
  reset role;
#+END_SRC

#+BEGIN_SRC sql-mode
\df load_audit_events
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
                              List of functions
 Schema |       Name        | Result data type |  Argument data types  | Type 
--------+-------------------+------------------+-----------------------+------
 public | load_audit_events | text             | bucket text, job text | func
(1 row)

#+end_src

#+BEGIN_SRC sql-mode
\dt+ raw_audit_events
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
                          List of relations
 Schema |       Name       | Type  | Owner |    Size    | Description 
--------+------------------+-------+-------+------------+-------------
 public | raw_audit_events | table | devan | 8192 bytes | 
(1 row)

#+end_src

#+BEGIN_SRC sql-mode
  delete from raw_audit_events;
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
DELETE 0
#+end_src


#+NAME: reload sample audit event
#+BEGIN_SRC sql-mode :noweb yes :notangle ../apps/hasura/migrations/250_populate_audit_events.up.sql
  select * from load_audit_events('ci-kubernetes-e2e-gci-gce','1134962072287711234');
  -- select * from load_swagger_via_curl('release-1.15');
  -- select * from load_swagger_via_curl('release-1.14');
  -- select * from load_swagger_via_curl('release-1.13');
  -- select * from load_swagger_via_curl('release-1.12');
  -- select * from load_swagger_via_curl('release-1.11');
  -- select * from load_swagger_via_curl('release-1.10');
#+END_SRC

#+RESULTS: reload sample audit event
#+begin_src sql-mode
 load_audit_events 
-------------------
 
(1 row)

#+end_src

#+BEGIN_SRC sql-mode
  select count(*) from raw_audit_events;
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
 count 
-------
     0
(1 row)

#+end_src

** load audit_events_via local cli

#+BEGIN_SRC sql-mode
  \d raw_audit_events;
  -- delete from raw_audit_events;
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
                                   Table "public.raw_audit_events"
   Column    |            Type             | Collation | Nullable |             Default              
-------------+-----------------------------+-----------+----------+----------------------------------
 id          | integer                     |           | not null | generated by default as identity
 ingested_at | timestamp without time zone |           |          | CURRENT_TIMESTAMP
 bucket      | text                        |           |          | 
 job         | text                        |           |          | 
 data        | jsonb                       |           | not null | 
Indexes:
    "raw_audit_events_pkey" PRIMARY KEY, btree (id)

#+end_src


#+NAME: load_audit_events.sh
#+BEGIN_SRC shell :var AUDIT_LOG="../data/artifacts/ci-kubernetes-e2e-gci-gce/1134962072287711234/combined-audit.log"
  BUCKET='ci-kubernetes-e2e-gci-gce'
  JOB='1134962072287711234'
  SQL="
  CREATE TEMPORARY TABLE raw_audit_events_import (data jsonb not null) ;
  copy raw_audit_events_import (data)
  FROM STDIN (DELIMITER e'\x02', FORMAT 'csv', QUOTE e'\x01');
  INSERT INTO raw_audit_events(data, bucket, job, audit_id)
  SELECT data, '$BUCKET', '$JOB'
  FROM raw_audit_events_import;
  "
  cat $AUDIT_LOG | psql -c "$SQL"
  date
#+END_SRC

#+RESULTS: load_audit_events.sh
#+begin_EXAMPLE
Sun Aug 11 21:09:02 UTC 2019
#+end_EXAMPLE

#+BEGIN_SRC sql-mode
  select distinct bucket, job from raw_audit_events;
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
 bucket  | job  
---------+------
 bucket1 | job1
(1 row)

#+end_src

#+BEGIN_SRC sql-mode
\dt+
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
                          List of relations
 Schema |       Name       | Type  | Owner |    Size    | Description 
--------+------------------+-------+-------+------------+-------------
 public | audit_events     | table | zz    | 8192 bytes | 
 public | raw_audit_events | table | zz    | 376 MB     | 
 public | raw_swaggers     | table | zz    | 1752 kB    | 
(3 rows)

#+end_src

* Audit Events View
** event_verb_to_http_method

#+BEGIN_SRC sql-mode :notangle ../apps/hasura/migrations/222_function_verb_to_method.up.sql :results silent
  CREATE FUNCTION event_verb_to_http_method(verb text) RETURNS text as $$
  BEGIN
    CASE
    WHEN verb = 'get' OR
         verb = 'list' OR
         verb = 'proxy'
    THEN return 'get' ;

    WHEN verb = 'deletecollection' OR
         verb = 'delete'
    THEN return 'delete' ;

    WHEN verb = 'watch' OR
         verb = 'watchlist'
    THEN return 'watch' ;

    WHEN verb = 'create'
    THEN return 'post' ;

    WHEN verb = 'update'
    THEN return 'put' ;

    WHEN verb = 'patch'
    THEN return 'patch' ;

    ELSE return null ;
    END CASE;
  END;
  $$ LANGUAGE plpgsql;
#+END_SRC

#+BEGIN_SRC sql-mode
select * from event_verb_to_http_method('proxy');
-- select * from event_verb_to_http_method('deletecollection');
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
 event_verb_to_http_method 
---------------------------
 get
(1 row)

#+end_src

** Initial View
   #+BEGIN_SRC sql-mode :notangle ../apps/hasura/migrations/225_material_audit_events.up.sql :results silent
     CREATE OR REPLACE VIEW "public"."audit_events" AS
       SELECT (raw.data ->> 'auditID') as audit_id,
              raw.bucket,
              raw.job,
              raw.data ->> 'level' as event_level,
              raw.data ->> 'stage' as event_stage,
              ops.operation_id,
              ops.k8s_action,
              ops.http_method,
              -- event_verb_to_http_method(raw.data ->> 'verb') AS operation_verb,
              ops.path as op_path,
              raw.data ->> 'verb' as event_verb,
              raw.data ->> 'apiVersion' as api_version,
              raw.data ->> 'requestURI' as request_uri,
              -- Always "Event"
              -- raw.data ->> 'kind' as kind,
              raw.data ->> 'userAgent' as useragent,
              raw.data -> 'user' as event_user,
              raw.data #>> '{objectRef,namespace}' as object_namespace,
              raw.data #>> '{objectRef,resource}' as object_type,
              raw.data #>> '{objectRef,apiGroup}' as object_group,
              raw.data #>> '{objectRef,apiVersion}' as object_ver,
              raw.data -> 'sourceIPs' as source_ips,
              raw.data -> 'annotations' as annotations,
              raw.data -> 'requestObject' as request_object,
              raw.data -> 'responseObject' as response_object,
              raw.data -> 'responseStatus' as response_status,
              raw.data ->> 'stageTimestamp' as stage_timestamp,
              raw.data ->> 'requestReceivedTimestamp' as request_received_timestamp,
              raw.data as data
       FROM raw_audit_events raw;
   #+END_SRC
            -- of done in order, this should limit our regex to < 5 targets to compare
         -- raw.data ->> 'requestURI' ~ ops.regex;
            -- OR raw.data ->> 'requestURI' ~ ops.regex;
        -- WITH NO DATA;
       -- CREATE MATERIALIZED VIEW "public"."audit_events_material" AS

** audit_event indexes

   #+BEGIN_SRC sql-mode
   SELECT event_verb, http_method, k8s_action, operation_id, object_group, object_ver, object_type
   FROM audit_events
   where true
   -- and resource_ver not like '%beta%'
   and event_verb not like 'patch'
   and event_verb not like 'deletecollection'
   and event_verb not like 'delete' -- everything is delete
   and event_verb not like 'list'
   and event_verb not like 'get'
   -- and event_verb not like 'create'
   and event_verb not like 'update'
   and object_type = 'pods'
   and not operation_id = 'createCoreV1NamespacedPod'
   and not operation_id = 'connectCoreV1PostNamespacedPodAttach'
   and not operation_id = 'createCoreV1NamespacedPodBinding'
   and not operation_id = 'createCoreV1NamespacedPodEviction'
   and not operation_id = 'connectCoreV1PostNamespacedPodExec'
   and not operation_id = 'connectCoreV1PostNamespacedPodPortforward'
   -- and event_verb = 'create'
   -- order by operation_id
   LIMIT 300;
   #+END_SRC

   #+RESULTS:
   #+begin_src sql-mode
    event_verb | http_method | k8s_action |               operation_id                | object_group | object_ver | object_type 
   ------------+-------------+------------+-------------------------------------------+--------------+------------+-------------
    create     | post        | connect    | connectCoreV1PostNamespacedPodPortforward |              | v1         | pods
    create     | post        | connect    | connectCoreV1PostNamespacedPodPortforward |              | v1         | pods
    create     | post        | connect    | connectCoreV1PostNamespacedPodPortforward |              | v1         | pods
    create     | post        | connect    | connectCoreV1PostNamespacedPodPortforward |              | v1         | pods
    create     | post        | connect    | connectCoreV1PostNamespacedPodPortforward |              | v1         | pods
    create     | post        | connect    | connectCoreV1PostNamespacedPodPortforward |              | v1         | pods
    create     | post        | connect    | connectCoreV1PostNamespacedPodPortforward |              | v1         | pods
    create     | post        | connect    | connectCoreV1PostNamespacedPodPortforward |              | v1         | pods
    create     | post        | connect    | connectCoreV1PostNamespacedPodPortforward |              | v1         | pods
    create     | post        | connect    | connectCoreV1PostNamespacedPodPortforward |              | v1         | pods
    create     | post        | connect    | connectCoreV1PostNamespacedPodPortforward |              | v1         | pods
    create     | post        | connect    | connectCoreV1PostNamespacedPodPortforward |              | v1         | pods
    create     | post        | connect    | connectCoreV1PostNamespacedPodPortforward |              | v1         | pods
    create     | post        | connect    | connectCoreV1PostNamespacedPodPortforward |              | v1         | pods
   (14 rows)

   #+end_src

   #+BEGIN_SRC sql-mode :results silent
     -- CREATE MATERIALIZED VIEW "public"."audit_events_podspec" AS
     CREATE OR REPLACE VIEW "public"."audit_events" AS
       SELECT (raw.data ->> 'auditID') as audit_id,
              raw.bucket,
              raw.job,
              raw.data ->> 'level' as event_level,
              raw.stage,
              ops.operation_id,
              ops.http_method,
              ops.k8s_action,
              raw.event_verb,
              raw.request_uri,
              -- Always "Event"
              -- raw.data ->> 'kind' as kind,
              raw.data ->> 'apiVersion' as api_version,
              raw.data ->> 'userAgent' as useragent,
              raw.data -> 'user' as event_user,
              raw.data -> 'objectRef' ->> 'namespace' as object_namespace,
              raw.data -> 'objectRef' ->> 'resource' as object_type,
              raw.data -> 'objectRef' ->> 'apiGroup' as object_group,
              raw.data -> 'objectRef' ->> 'apiVersion' as object_ver,
              raw.data -> 'sourceIPs' as source_ips,
              raw.data -> 'annotations' as annotations,
              raw.data -> 'requestObject' as request_object,
              raw.data -> 'responseObject' as response_object,
              raw.data -> 'responseStatus' as response_status,
              raw.data ->> 'stageTimestamp' as stage_timestamp,
              raw.data ->> 'requestReceivedTimestamp' as request_received_timestamp,
              raw.data as data
       FROM raw_audit_events raw
       JOIN api_operations ops ON
            -- of done in order, this should limit our regex to < 5 targets to compare
            raw.operation_id = ops.operation_id;
            -- raw.data ->> 'requestURI' ~ ops.regex;
        --     raw.data ->> 'verb'       = ops.k8s_action
        -- AND raw.data ->> 'requestURI' ~ ops.regex;
        -- WITH NO DATA;
   #+END_SRC

#+BEGIN_SRC sql-mode
   SELECT distinct event_verb, http_method, k8s_action, operation_id, object_group, object_ver, object_type
   FROM audit_events
   where true
   -- and object_ver not like '%alpha%'
   -- and object_ver not like '%beta%'
   and event_verb not like 'list'
   and event_verb not like 'get'
   and event_verb not like 'create'
   and event_verb not like 'update'
   and event_verb not like 'patch'
   and event_verb not like 'delete'
   and event_verb not like 'deletecollection'
   -- and event_verb = 'create'
   -- LIMIT 300;
   ;
   #+END_SRC

   #+RESULTS:
   #+begin_src sql-mode
    event_verb | http_method | k8s_action | operation_id | object_group | object_ver | object_type 
   ------------+-------------+------------+--------------+--------------+------------+-------------
   (0 rows)

   #+end_src


#+BEGIN_SRC sql-mode
   SELECT count(audit_id)
   FROM audit_events;
 #+END_SRC


   #+RESULTS:
   #+begin_src sql-mode
    count 
   -------
        0
   (1 row)

   #+end_src
   #+BEGIN_SRC sql-mode :notangle ../apps/hasura/migrations/230_view_audit_events.up.sql :results silent
     CREATE OR REPLACE VIEW "public"."audit_events" AS
       SELECT audit_id,
              bucket,
              job,
              event_level,
              event_stage,
              operation_id,
              event_verb,
              api_version,
              request_uri,
              useragent,
              event_user,
              object_name,
              object_namespace,
              event_resource,
              object_api_version,
              object_ref,
              source_ips,
              annotations,
              request_object,
              response_object,
              response_status,
              stage_timestamp,
              request_received_timestamp,
              data
       FROM audit_events_material;
   #+END_SRC
   
#+NAME: track audit_events
#+BEGIN_SRC yaml :notangle ../apps/hasura/migrations/230_audit_events.up.yaml
- type: track_table
  args:
    schema: public
    name: audit_events
#+END_SRC
** requestObjects
*** columns
**** requestkind
 #+NAME: requestObject.kind
 #+BEGIN_SRC sql-mode
     requestkind text NOT NULL,
 #+END_SRC

***** Examples
 #+BEGIN_SRC json
 "requestObject": {
     "kind": "SubjectAccessReview",
 #+END_SRC

 #+BEGIN_SRC shell
 cat kube-apiserver-audit.log | jq  -r .requestObject.kind | sort | uniq > kinds.txt
 cat kube-apiserver-audit.log | jq  -r .responseObject.kind | sort | uniq > rkinds.txt
 diff kinds.txt rkinds.txt
 #+END_SRC

 Only requestObjects include Binding, DeleteOptions, and DeploymentRollback
 Only responsesObjects include Status and TokenRequest

 #+BEGIN_SRC diff
 2d1
 < Binding
 12d10
 < DeleteOptions
 14d11
 < DeploymentRollback
 39a37
 > Status
 41a40
 > TokenRequest
 #+END_SRC

**** requestapiversion
 #+NAME: requestObject.apiVersion
 #+BEGIN_SRC sql-mode
   requestapiversion text NOT NULL,
 #+END_SRC
 Might be tied to level = request, response etc
***** examples
 #+BEGIN_SRC json
 "requestObject": {
     "apiVersion": "authorization.k8s.io/v1",
 #+END_SRC

 I'm not sure here, but I feel like we should only be looking at RequestResponse... not all three.
 Huh, that was wrong.. the counts differ wildly:

**** requestmeta
 #+NAME: requestObject.metadata
 #+BEGIN_SRC sql-mode
   requestmeta jsonb NOT NULL,
 #+END_SRC
***** examples
 #+BEGIN_SRC json
 "requestObject": {
     "metadata": {
       "creationTimestamp": null
     },
 #+END_SRC
**** requestspec
 #+NAME: requestObject.spec
 #+BEGIN_SRC sql-mode
   requestspec jsonb NOT NULL,
 #+END_SRC
***** examples
 #+BEGIN_SRC json
 "requestObject": {
     "spec": {
       "resourceAttributes": {
         "namespace": "kubernetes-dashboard-6069",
         "verb": "use",
         "group": "extensions",
         "resource": "podsecuritypolicies",
         "name": "e2e-test-privileged-psp"
       },
       "user": "system:serviceaccount:kubernetes-dashboard-6069:default"
     },
 #+END_SRC
**** requeststatus
 #+NAME: requestObject.status
 #+BEGIN_SRC sql-mode
   requeststatus jsonb NOT NULL,
 #+END_SRC
***** examples
 #+BEGIN_SRC json
   "responseObject": {
     "status": {
       "allowed": true,
       "reason": "RBAC: allowed by RoleBinding \"kubernetes-dashboard-6069--e2e-test-privileged-psp/kubernetes-dashboard-6069\" of ClusterRole \"e2e-test-privileged-psp\" to ServiceAccount \"default/kubernetes-dashboard-6069\""
     }
 #+END_SRC

*** table

 We'll just load these as jsonb into the main audit_events table.

 From https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.15/

 #+BEGIN_EXAMPLE
 Resource objects typically have 3 components:

 Resource ObjectMeta: This is metadata about the resource, such as its name, type, api version, annotations, and labels. This contains fields that maybe updated both by the end user and the system (e.g. annotations).

 ResourceSpec: This is defined by the user and describes the desired state of system. Fill this in when creating or updating an object.

 ResourceStatus: This is filled in by the server and reports the current state of the system. In most cases, users don't need to change this.
 #+END_EXAMPLE

 These have more information
 #+BEGIN_SRC json
 "requestObject": {
     "kind": "SubjectAccessReview",
     "apiVersion": "authorization.k8s.io/v1",
     "metadata": {
       "creationTimestamp": null
     },
     "spec": {
       "resourceAttributes": {
         "namespace": "kubernetes-dashboard-6069",
         "verb": "use",
         "group": "extensions",
         "resource": "podsecuritypolicies",
         "name": "e2e-test-privileged-psp"
       },
       "user": "system:serviceaccount:kubernetes-dashboard-6069:default"
     },
     "status": {
       "allowed": false
     }
   },
 #+END_SRC

** responseObjects
*** columns
**** responsekind
 #+NAME: responseObject.kind
 #+BEGIN_SRC sql-mode
     responsekind text NOT NULL,
 #+END_SRC

***** Examples
 #+BEGIN_SRC json
 "responseObject": {
     "kind": "SubjectAccessReview",
 #+END_SRC

 #+BEGIN_SRC shell
 cat kube-apiserver-audit.log | jq  -r .responseObject.kind | sort | uniq > kinds.txt
 cat kube-apiserver-audit.log | jq  -r .responseObject.kind | sort | uniq > rkinds.txt
 diff kinds.txt rkinds.txt
 #+END_SRC

 Only responseObjects include Binding, DeleteOptions, and DeploymentRollback
 Only responsesObjects include Status and TokenResponse

 #+BEGIN_SRC diff
 2d1
 < Binding
 12d10
 < DeleteOptions
 14d11
 < DeploymentRollback
 39a37
 > Status
 41a40
 > TokenResponse
 #+END_SRC

**** responseapiversion
 #+NAME: responseObject.apiVersion
 #+BEGIN_SRC sql-mode
   responseapiversion text NOT NULL,
 #+END_SRC
 Might be tied to level = response, response etc
***** examples
 #+BEGIN_SRC json
 "responseObject": {
     "apiVersion": "authorization.k8s.io/v1",
 #+END_SRC

 I'm not sure here, but I feel like we should only be looking at ResponseResponse... not all three.
 Huh, that was wrong.. the counts differ wildly:

**** responsemeta
 #+NAME: responseObject.metadata
 #+BEGIN_SRC sql-mode
   responsemeta jsonb NOT NULL,
 #+END_SRC
***** examples
 #+BEGIN_SRC json
 "responseObject": {
     "metadata": {
       "creationTimestamp": null
     },
 #+END_SRC
**** responsespec
 #+NAME: responseObject.spec
 #+BEGIN_SRC sql-mode
   responsespec jsonb NOT NULL,
 #+END_SRC
***** examples
 #+BEGIN_SRC json
 "responseObject": {
     "spec": {
       "resourceAttributes": {
         "namespace": "kubernetes-dashboard-6069",
         "verb": "use",
         "group": "extensions",
         "resource": "podsecuritypolicies",
         "name": "e2e-test-privileged-psp"
       },
       "user": "system:serviceaccount:kubernetes-dashboard-6069:default"
     },
 #+END_SRC
**** responsestatus
 #+NAME: responseObject.status
 #+BEGIN_SRC sql-mode
   responsestatus jsonb NOT NULL,
 #+END_SRC
***** examples
 #+BEGIN_SRC json
   "responseObject": {
     "status": {
       "allowed": true,
       "reason": "RBAC: allowed by RoleBinding \"kubernetes-dashboard-6069--e2e-test-privileged-psp/kubernetes-dashboard-6069\" of ClusterRole \"e2e-test-privileged-psp\" to ServiceAccount \"default/kubernetes-dashboard-6069\""
     }
 #+END_SRC

*** Notes
 #+BEGIN_SRC json
   "responseObject": {
     "kind": "SubjectAccessReview",
     "apiVersion": "authorization.k8s.io/v1",
     "metadata": {
       "creationTimestamp": null
     },
     "spec": {
       "resourceAttributes": {
         "namespace": "kubernetes-dashboard-6069",
         "verb": "use",
         "group": "extensions",
         "resource": "podsecuritypolicies",
         "name": "e2e-test-privileged-psp"
       },
       "user": "system:serviceaccount:kubernetes-dashboard-6069:default"
     },
     "status": {
       "allowed": true,
       "reason": "RBAC: allowed by RoleBinding \"kubernetes-dashboard-6069--e2e-test-privileged-psp/kubernetes-dashboard-6069\" of ClusterRole \"e2e-test-privileged-psp\" to ServiceAccount \"default/kubernetes-dashboard-6069\""
     }
   },
 #+END_SRC

* Operation Views
** api_operations view
*** regex_from_path function
#+NAME: regex_from_path.py
#+BEGIN_SRC python :eval never
  import re
  if path is None:
    return None
  K8S_PATH_VARIABLE_PATTERN = re.compile("{(path)}$")
  VARIABLE_PATTERN = re.compile("{([^}]+)}")
  path_regex = K8S_PATH_VARIABLE_PATTERN.sub("(.*)", path).rstrip('/')
  path_regex = VARIABLE_PATTERN.sub("([^/]*)", path_regex).rstrip('/')
  if not path_regex.endswith(")") and not path_regex.endswith("?"): 
      path_regex += "([^/]*)"
  if path_regex.endswith("proxy"): 
      path_regex += "/?$"
  else:
      path_regex += "$"
  return path_regex
#+END_SRC

#+NAME: regex_from_path.sql
#+BEGIN_SRC sql-mode :noweb yes :tangle ../apps/hasura/migrations/145_function_regex_from_path.up.sql :results silent
  set role dba;
  CREATE OR REPLACE FUNCTION regex_from_path(path text)
  RETURNS text AS $$
  <<regex_from_path.py>>
  $$ LANGUAGE plpython3u ;
  reset role;
#+END_SRC

*** api_operations view
    This grabs the 'paths' section of our swagger.json, where each path contains operation Id, tags, schemes, etc.
#+NAME: api_operations view
#+BEGIN_SRC sql-mode :eval never-export :tangle ../apps/hasura/migrations/150_view_api_operations.up.sql :results silent
  CREATE OR REPLACE VIEW "public"."api_operations" AS 
    SELECT raw_swaggers.id AS raw_swagger_id,
           paths.key AS path,
           regex_from_path(paths.key) as regex,
           d.key AS http_method,
           (d.value ->> 'x-kubernetes-action'::text) AS k8s_action,
           (d.value ->> 'operationId'::text) AS operation_id,
           ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'group'::text) AS k8s_group,
           ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'version'::text) AS k8s_version,
           ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'kind'::text) AS k8s_kind,
           (d.value ->> 'description'::text) AS description,
           (d.value -> 'consumes'::text) AS consumes,
           (d.value -> 'responses'::text) AS responses,
           (d.value -> 'parameters'::text) AS parameters,
           (lower((d.value ->> 'description'::text)) ~~ '%deprecated%'::text) AS deprecated,
           split_part((cat_tag.value ->> 0), '_'::text, 1) AS category,
           string_agg(btrim((jsonstring.value)::text, '"'::text), ', '::text) AS tags,
           string_agg(btrim((schemestring.value)::text, '"'::text), ', '::text) AS schemes,
           CASE
            WHEN (d.value ->> 'x-kubernetes-action'::text) IN ('get', 'list', 'proxy') THEN 'get'
            WHEN (d.value ->> 'x-kubernetes-action'::text) IN ('deleteCollection', 'delete', 'deletecollection') THEN 'delete'
            WHEN (d.value ->> 'x-kubernetes-action'::text) IN ('watch', 'watchlist', 'watch') THEN 'watch'
            WHEN (d.value ->> 'x-kubernetes-action'::text) IN ('create', 'post') THEN 'post'
            WHEN (d.value ->> 'x-kubernetes-action'::text) IN ( 'update', 'put' ) THEN 'put'
            WHEN (d.value ->> 'x-kubernetes-action'::text) = 'patch' THEN 'patch'
            WHEN (d.value ->> 'x-kubernetes-action'::text) = 'connect' THEN 'connect'
           ELSE NULL
             END as event_verb
      FROM raw_swaggers
      , jsonb_each((raw_swaggers.data -> 'paths'::text)) paths(key, value)
      , jsonb_each(paths.value) d(key, value)
      , jsonb_array_elements((d.value -> 'tags'::text)) cat_tag(value)
      , jsonb_array_elements((d.value -> 'tags'::text)) jsonstring(value)
      , jsonb_array_elements((d.value -> 'schemes'::text)) schemestring(value)
     GROUP BY raw_swaggers.id, paths.key, d.key, d.value, cat_tag.value
     ORDER BY paths.key;
#+END_SRC

#+NAME: api_operations indexes the raw_swagger
#+BEGIN_SRC sql-mode :tangle ../apps/hasura/migrations/100_table_raw_swaggers.up.sql :results silent
  -- CREATE INDEX idx_swagger_gin_paths ON raw_swaggers USING GIN ((data->>'paths'));
  -- CREATE INDEX idx_swagger_btree_paths ON raw_swaggers USING BTREE ((data->>'paths'));
  -- CREATE INDEX idx_swagger_hash_paths ON raw_swaggers USING HASH ((data->>'paths'))
       -- api_operations view:
       --  , jsonb_each((raw_swaggers.data -> 'paths'::text)) paths(key, value)
       --  , jsonb_each(paths.value) d(key, value)
       --  , jsonb_array_elements((d.value -> 'tags'::text)) cat_tag(value)
       --  , jsonb_array_elements((d.value -> 'tags'::text)) jsonstring(value)
       --  , jsonb_array_elements((d.value -> 'schemes'::text)) schemestring(value)
       -- GROUP BY raw_swaggers.id, paths.key, d.key, d.value, cat_tag.value
       -- ORDER BY paths.key;
       -- api_resources view:
       --   , jsonb_each((raw_swaggers.data -> 'definitions'::text)) d(key, value)
       --   , jsonb_array_elements((d.value -> 'required'::text)) reqstring(value)
       -- GROUP BY raw_swaggers.id, d.key, d.value;
  -- CREATE INDEX idx_swagger_X ON raw_swagger USING GIN ((jsb->‘X’));
  -- CREATE INDEX idx_swagger_X ON raw_swagger USING BTREE ((jsb->>‘X’));
  -- CREATE INDEX idx_swagger_X ON raw_swagger USING HASH ((jsb->>‘X’))
  #+END_SRC

#+NAME: track api_operations
#+BEGIN_SRC yaml :tangle ../apps/hasura/migrations/150_view_api_operations.up.yaml
- type: track_table
  args:
    schema: public
    name: api_operations
#+END_SRC


#+NAME: possible indexes
#+BEGIN_SRC sql-mode :eval never
create index api_operations_id on api_operations(id);
create index api_operations_method on api_operations(method);
create index api_operations_regexp on api_operations(regexp);
#+END_SRC

** api_operations_parameters view
Using our api_operations view, look into the parameters field in each one.     
#+NAME: api_operations_parameters view
#+BEGIN_SRC sql-mode :eval no-export :tangle ../apps/hasura/migrations/160_view_api_operations_parameters.up.sql
  CREATE OR REPLACE VIEW "public"."api_operations_parameters" AS 
    SELECT (param.entry ->> 'name'::text) AS name,
           (param.entry ->> 'in'::text) AS "in",
           -- for resource:
           -- if param is body in body, take its $ref from its schema
           -- otherwise, take its type
           replace(
             CASE
             WHEN ((param.entry ->> 'in'::text) = 'body'::text) 
              AND ((param.entry -> 'schema'::text) is not null)
               THEN ((param.entry -> 'schema'::text) ->> '$ref'::text)
             ELSE (param.entry ->> 'type'::text)
             END, '#/definitions/','') AS resource,
           (param.entry ->> 'description'::text) AS description,
           CASE
           WHEN ((param.entry ->> 'required'::text) = 'true') THEN true
           ELSE false
            END AS required,
           CASE
           WHEN ((param.entry ->> 'uniqueItems'::text) = 'true') THEN true
           ELSE false
           END AS unique_items,
           api_operations.raw_swagger_id,
           param.entry as entry,
           api_operations.operation_id
      FROM api_operations
           , jsonb_array_elements(api_operations.parameters) WITH ORDINALITY param(entry, index)
            WHERE api_operations.parameters IS NOT NULL;
#+END_SRC

#+RESULTS: api_operations_parameters view
#+begin_src sql-mode
ERROR:  missing FROM-clause entry for table "api_operations"
LINE 23:          api_operations.raw_swagger_id,
#+end_src

#+NAME: track api_operations_parameters
#+BEGIN_SRC yaml :eval no-export :tangle ../apps/hasura/migrations/160_view_api_operations_parameters.up.yaml
- type: track_table
  args:
    schema: public
    name: api_operations_parameters
#+END_SRC

** api_operations_responses view
   Similar to parameters, within each of the paths of the swagger.json, there is a responses field.  We are listing the values within this field.
   
#+NAME: Responses View
#+BEGIN_SRC sql-mode :eval no-export :tangle ../apps/hasura/migrations/180_view_api_operations_responses.up.sql
  CREATE OR REPLACE VIEW "public"."api_operations_responses" AS 
    SELECT d.key AS code,
           (d.value ->> 'description'::text) AS description,
           replace(
             CASE
             WHEN (((d.value -> 'schema'::text) IS NOT NULL) AND (((d.value -> 'schema'::text) -> 'type'::text) IS NOT NULL))
               THEN ((d.value -> 'schema'::text) ->> 'type'::text)
             WHEN (((d.value -> 'schema'::text) IS NOT NULL) AND (((d.value -> 'schema'::text) -> '$ref'::text) IS NOT NULL))
               THEN ((d.value -> 'schema'::text) ->> '$ref'::text)
             ELSE NULL::text
             END, '#/definitions/','') AS resource,
             api_operations.operation_id,
             api_operations.raw_swagger_id
      FROM (api_operations
            JOIN LATERAL jsonb_each(api_operations.responses) d(key, value) ON (true))
     ORDER BY (uuid_generate_v1());
#+END_SRC

#+RESULTS: Responses View
#+begin_src sql-mode
CREATE VIEW
#+end_src

#+NAME: track api_operations_responses
#+BEGIN_SRC yaml :tangle ../apps/hasura/migrations/180_view_api_operations_responses.up.yaml
- type: track_table
  args:
    schema: public
    name: api_operations_responses
#+END_SRC

** Materialized api_operations
*** drop table
    #+BEGIN_SRC sql-mode
    DROP MATERIALIZED VIEW api_operations_material;
    #+END_SRC

    #+RESULTS:
    #+begin_src sql-mode
    DROP MATERIALIZED VIEW
    #+end_src
*** api_operations_material
#+NAME: api_operations_material
#+BEGIN_SRC sql-mode :eval never-export :tangle ../apps/hasura/migrations/150_view_api_operations.up.sql :results silent
  CREATE MATERIALIZED VIEW "public"."api_operations_material" AS 
    SELECT raw_swaggers.id AS raw_swagger_id,
           paths.key AS path,
           regex_from_path(paths.key) as regex,
           d.key AS http_method,
           (d.value ->> 'x-kubernetes-action'::text) AS k8s_action,
           (d.value ->> 'operationId'::text) AS operation_id,
           ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'group'::text) AS k8s_group,
           ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'version'::text) AS k8s_version,
           ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'kind'::text) AS k8s_kind,
           (d.value ->> 'description'::text) AS description,
           (d.value -> 'consumes'::text)::jsonb AS consumes,
           (d.value -> 'responses'::text)::jsonb AS responses,
           (d.value -> 'parameters'::text)::jsonb AS parameters,
           (lower((d.value ->> 'description'::text)) ~~ '%deprecated%'::text) AS deprecated,
           split_part((cat_tag.value ->> 0), '_'::text, 1) AS category,
           string_agg(btrim((jsonstring.value)::text, '"'::text), ', '::text) AS tags,
           string_agg(btrim((schemestring.value)::text, '"'::text), ', '::text) AS schemes,
           CASE
            WHEN (d.value ->> 'x-kubernetes-action'::text) = 'get' THEN ARRAY ['get']
            WHEN (d.value ->> 'x-kubernetes-action'::text) =  'list' THEN ARRAY [ 'list' ]
            WHEN (d.value ->> 'x-kubernetes-action'::text) = 'proxy' THEN ARRAY [ 'proxy' ]
            WHEN (d.value ->> 'x-kubernetes-action'::text) = 'deletecollection' THEN ARRAY [ 'deletecollection' ]
            WHEN (d.value ->> 'x-kubernetes-action'::text) = 'watch' THEN ARRAY [ 'watch' ]
            WHEN (d.value ->> 'x-kubernetes-action'::text) = 'post' THEN ARRAY [ 'post', 'create' ]
            WHEN (d.value ->> 'x-kubernetes-action'::text) =  'put' THEN ARRAY [ 'put', 'update' ]
            WHEN (d.value ->> 'x-kubernetes-action'::text) = 'patch' THEN ARRAY [ 'patch' ]
            WHEN (d.value ->> 'x-kubernetes-action'::text) = 'connect' THEN ARRAY [ 'connect' ]
           ELSE NULL
             END as event_verb
      FROM raw_swaggers
      , jsonb_each((raw_swaggers.data -> 'paths'::text)) paths(key, value)
      , jsonb_each(paths.value) d(key, value)
      , jsonb_array_elements((d.value -> 'tags'::text)) cat_tag(value)
      , jsonb_array_elements((d.value -> 'tags'::text)) jsonstring(value)
      , jsonb_array_elements((d.value -> 'schemes'::text)) schemestring(value)
     GROUP BY raw_swaggers.id, paths.key, d.key, d.value, cat_tag.value
     ORDER BY paths.key;
#+END_SRC

#+BEGIN_SRC sql-mode
    CREATE index api_operations_materialized_event_verb ON api_operations_material            (event_verb);
    CREATE index api_operations_materialized_regex_gist  ON api_operations_material USING GIST (regex gist_trgm_ops);
    CREATE index api_operations_materialized_regex_gin  ON api_operations_material USING GIN  (regex gin_trgm_ops);
  --  CREATE UNIQUE INDEX ON api_operations_material(raw_swagger_id, http_method, regex);
#+END_SRC

#+NAME: k8s_action
#+BEGIN_SRC sql-mode
SELECT
distinct k8s_action
FROM api_operations_material
order by k8s_action;
#+END_SRC

watch, post, list, get, delete, deleteCollection, patch,
#+RESULTS: event_verb
#+begin_src sql-mode
    event_verb    
------------------
 abcd
 create
 delete
 deletecollection
 get
 list
 patch
 post
 update
 watch
(10 rows)

#+end_src
#+RESULTS: k8s_action
#+begin_src sql-mode
    k8s_action    
------------------
 connect
 delete
 deletecollection
 get
 list
 patch
 post
 put
 watch
 watchlist
 
(11 rows)

#+end_src

#+NAME: event_verb
#+BEGIN_SRC sql-mode
  SELECT
  distinct event_verb
  from zraw_audit_events
  order by event_verb;
#+END_SRC



#+RESULTS:
#+begin_src sql-mode
    event_verb    
------------------
 list
 deletecollection
 delete
 update
 get
 create
 post
 abcd
 watch
 patch
(10 rows)

#+end_src

#+NAME: index the api_operations_material
#+BEGIN_SRC sql-mode :eval never-export :tangle ../apps/hasura/migrations/150_view_api_operations.up.sql :results silent
    CREATE UNIQUE INDEX                                  ON api_operations_material(raw_swagger_id, http_method, regex);
    CREATE INDEX api_operations_materialized_event_verb  ON api_operations_material            (event_verb);
    CREATE INDEX api_operations_materialized_k8s_action  ON api_operations_material            (k8s_action);
    CREATE INDEX api_operations_materialized_k8s_group   ON api_operations_material            (k8s_group);
    CREATE INDEX api_operations_materialized_k8s_version ON api_operations_material            (k8s_version);
    CREATE INDEX api_operations_materialized_k8s_kind    ON api_operations_material            (k8s_kind);
    CREATE INDEX api_operations_materialized_tags        ON api_operations_material            (tags);
    CREATE INDEX api_operations_materialized_schemes     ON api_operations_material            (schemes);
    CREATE INDEX api_operations_materialized_regex_gist  ON api_operations_material USING GIST (regex gist_trgm_ops);
    CREATE INDEX api_operations_materialized_regex_gin   ON api_operations_material USING GIN  (regex gin_trgm_ops);
    CREATE INDEX api_operations_materialized_consumes_ops   ON api_operations_material USING GIN  (consumes jsonb_ops);
    CREATE INDEX api_operations_materialized_consumes_path  ON api_operations_material USING GIN  (consumes jsonb_path_ops);
    CREATE INDEX api_operations_materialized_parameters_ops   ON api_operations_material USING GIN  (parameters jsonb_ops);
    CREATE INDEX api_operations_materialized_parameters_path  ON api_operations_material USING GIN  (parameters jsonb_path_ops);
    CREATE INDEX api_operations_materialized_responses_ops   ON api_operations_material USING GIN  (responses jsonb_ops);
    CREATE INDEX api_operations_materialized_responses_path  ON api_operations_material USING GIN  (responses jsonb_path_ops);
#+END_SRC

#+BEGIN_SRC sql-mode :eval never-export :notangle ../apps/hasura/migrations/150_view_api_operations.up.sql :results silent
-- CREATE INDEX idx_api_operations_material_primary ON api_operations_material USING (raw_swagger_id, event_verb, regex);
-- CREATE INDEX idx_audit_events_level_btree      ON raw_audit_events USING BTREE ((data->>'level'));
-- CREATE INDEX idx_audit_events_level_hash       ON raw_audit_events USING HASH  ((data->>'level'));
-- CREATE INDEX idx_api_operations_material_jsonb_ops ON raw_audit_events USING GIN (data jsonb_ops);
-- CREATE INDEX idx_audit_events_jsonb_path_jobs  ON raw_audit_events USING GIN (data jsonb_path_ops);
-- CREATE INDEX idx_audit_events_level_btree      ON raw_audit_events USING BTREE ((data->>'level'));
-- CREATE INDEX idx_audit_events_level_hash       ON raw_audit_events USING HASH  ((data->>'level'));
-- CREATE INDEX idx_audit_events_stage_btree      ON raw_audit_events USING BTREE ((data->>'stage'));
-- CREATE INDEX idx_audit_events_stage_hash       ON raw_audit_events USING HASH  ((data->>'stage'));
-- CREATE INDEX idx_audit_events_verb_btree       ON raw_audit_events USING BTREE ((data->>'verb'));
-- CREATE INDEX idx_audit_events_verb_hash        ON raw_audit_events USING HASH  ((data->>'verb'));
-- CREATE INDEX idx_audit_events_apiVersion_btree ON raw_audit_events USING BTREE ((data->>'apiVersion'));
-- CREATE INDEX idx_audit_events_apiVersion_hash  ON raw_audit_events USING HASH  ((data->>'apiVersion'));
-- CREATE INDEX idx_audit_events_requestURI_btree ON raw_audit_events USING BTREE ((data->>'requestURI'));
-- CREATE INDEX idx_audit_events_requestURI_hash  ON raw_audit_events USING HASH  ((data->>'requestURI'));
-- CREATE INDEX idx_audit_events_userAgent_btree  ON raw_audit_events USING BTREE ((data->>'userAgent'));
-- CREATE INDEX idx_audit_events_userAgent_hash   ON raw_audit_events USING HASH  ((data->>'userAgent'));
-- CREATE INDEX idx_audit_events_namespace_btree  ON raw_audit_events USING BTREE ((data->'objectRef' ->> 'namespace'));
-- CREATE INDEX idx_audit_events_namespace_hash   ON raw_audit_events USING HASH  ((data->'objectRef' ->> 'namespace'));
-- CREATE INDEX idx_audit_events_resource_btree   ON raw_audit_events USING BTREE ((data->'objectRef' ->> 'resource'));
-- CREATE INDEX idx_audit_events_resource_hash    ON raw_audit_events USING HASH  ((data->'objectRef' ->> 'resource'));
-- CREATE INDEX idx_audit_events_apiGroup_btree   ON raw_audit_events USING BTREE ((data->'objectRef' ->> 'apiGroup'));
-- CREATE INDEX idx_audit_events_apiGroup_hash    ON raw_audit_events USING HASH  ((data->'objectRef' ->> 'apiGroup'));
-- CREATE INDEX idx_audit_events_apiVersion_btree ON raw_audit_events USING BTREE ((data->'objectRef' ->> 'apiVersion'));
-- CREATE INDEX idx_audit_events_apiVersion_hash  ON raw_audit_events USING HASH  ((data->'objectRef' ->> 'apiVersion'));
-- CREATE INDEX idx_audit_events_requests_gin     ON raw_audit_events USING GIN ((data->'requestObject'));
-- CREATE INDEX idx_audit_events_requests_gin     ON raw_audit_events USING GIN ((data->'requestObject'));
-- CREATE INDEX idx_audit_events_namespace_hash   ON raw_audit_events USING HASH  ((data->'objectRef' ->> 'namespace'));
-- CREATE INDEX idx_audit_events_X_gin  ON raw_audit_events USING GIN ((data->'X'));
-- CREATE INDEX idx_audit_events_X_btree ON raw_audit_events USING BTREE ((data->'X'));
-- CREATE INDEX idx_audit_events_X_hash ON raw_audit_events USING HASH ((data->'X'));
-- CREATE INDEX idx_audit_events_X ON raw_audit_events USING GIN ((jsb->‘X’));
-- CREATE INDEX idx_audit_events_X ON raw_audit_events USING BTREE ((jsb->>‘X’));
-- CREATE INDEX idx_audit_events_X ON raw_audit_events USING HASH ((jsb->>‘X’))
#+END_SRC

** api_operations_parameters_material
*** drop table
    #+BEGIN_SRC sql-mode
    DROP MATERIALIZED VIEW api_operations_parameters_material;
    #+END_SRC

    #+RESULTS:
    #+begin_src sql-mode
    DROP MATERIALIZED VIEW
    #+end_src
*** table
Using our api_operations_material view, look into the parameters field in each one.     
#+NAME: api_operations_parameters_material view
#+BEGIN_SRC sql-mode :eval no-export :tangle ../apps/hasura/migrations/160_view_api_operations_parameters.up.sql
  CREATE MATERIALIZED VIEW "public"."api_operations_parameters_material" AS 
    SELECT (param.entry ->> 'name'::text) AS name,
           (param.entry ->> 'in'::text) AS "in",
           -- for resource:
           -- if param is body in body, take its $ref from its schema
           -- otherwise, take its type
           replace(
             CASE
             WHEN ((param.entry ->> 'in'::text) = 'body'::text) 
              AND ((param.entry -> 'schema'::text) is not null)
               THEN ((param.entry -> 'schema'::text) ->> '$ref'::text)
             ELSE (param.entry ->> 'type'::text)
             END, '#/definitions/','') AS resource,
           (param.entry ->> 'description'::text) AS description,
           CASE
           WHEN ((param.entry ->> 'required'::text) = 'true') THEN true
           ELSE false
            END AS required,
           CASE
           WHEN ((param.entry ->> 'uniqueItems'::text) = 'true') THEN true
           ELSE false
           END AS unique_items,
           api_operations_material.raw_swagger_id,
           param.entry as entry,
           api_operations_material.operation_id
      FROM api_operations_material
           , jsonb_array_elements(api_operations_material.parameters) WITH ORDINALITY param(entry, index)
            WHERE api_operations_material.parameters IS NOT NULL;
#+END_SRC

#+RESULTS: api_operations_parameters_material view
#+begin_src sql-mode
SELECT 3375
#+end_src
*** indexes
#+NAME: index the api_operations_material
#+BEGIN_SRC sql-mode :eval no-export :tangle ../apps/hasura/migrations/160_view_api_operations_parameters.up.sql
    CREATE UNIQUE INDEX                                  ON api_operations_parameters_material(raw_swagger_id, operation_id, name);
    CREATE INDEX api_parameters_materialized_resource    ON api_operations_parameters_material            (resource);
    CREATE INDEX api_parameters_materialized_entry       ON api_operations_parameters_material            (entry);
#+END_SRC

* Resource Views
** api_resources view
#+NAME: api_resources view
#+BEGIN_SRC sql-mode :eval never-export :tangle ../apps/hasura/migrations/190_view_api_resources.up.sql
  CREATE VIEW "public"."api_resources" AS 
   SELECT 
      raw_swaggers.id AS raw_swagger_id,
      d.key AS name,
      (d.value ->> 'type'::text) AS resource_type,
      (((d.value -> 'x-kubernetes-group-version-kind'::text) -> 0) ->> 'group'::text) AS k8s_group,
      (((d.value -> 'x-kubernetes-group-version-kind'::text) -> 0) ->> 'version'::text) AS k8s_version,
      (((d.value -> 'x-kubernetes-group-version-kind'::text) -> 0) ->> 'kind'::text) AS k8s_kind,
      string_agg(btrim((reqstring.value)::text, '"'::text), ', '::text) AS required_params,
      (d.value ->> 'required'::text) as required_params_text,
      (d.value -> 'properties'::text) AS properties,
      d.value
     FROM raw_swaggers
       , jsonb_each((raw_swaggers.data -> 'definitions'::text)) d(key, value)
       , jsonb_array_elements((d.value -> 'required'::text)) reqstring(value)
     GROUP BY raw_swaggers.id, d.key, d.value;

#+END_SRC

#+RESULTS: api_resources view
#+begin_src sql-mode
ERROR:  relation "raw_swaggers" does not exist
LINE 13:    FROM raw_swaggers
                 ^
#+end_src

#+NAME: track api_resources
#+BEGIN_SRC yaml :tangle ../apps/hasura/migrations/190_view_api_resources.up.yaml
- type: track_table
  args:
    schema: public
    name: api_resources
#+END_SRC

** api_resources_fields view
#+NAME: Older Properties View
#+BEGIN_SRC sql-mode :eval never-export :notangle ../apps/hasura/migrations/200_view_api_resources_fields.up.sql
  -- DROP VIEW api_resources_properties;
  -- DROP MATERIALIZED VIEW api_resources_properties;
  CREATE VIEW "public"."api_resources_fields" AS 
    SELECT api_resources.id AS type_id,
           d.key AS property,
           CASE
           WHEN ((d.value ->> 'type'::text) IS NULL) THEN 'subtype'::text
           ELSE (d.value ->> 'type'::text)
             END AS param_type,
           replace(
             CASE
             WHEN ((d.value ->> 'type'::text) = 'string'::text) THEN 'string'::text
             WHEN ((d.value ->> 'type'::text) IS NULL) THEN (d.value ->> '$ref'::text)
             WHEN ((d.value ->> 'type'::text) = 'array'::text)
              AND ((d.value -> 'items'::text) ->> 'type'::text) IS NULL
               THEN ((d.value -> 'items'::text) ->> '$ref'::text)
             WHEN ((d.value ->> 'type'::text) = 'array'::text)
              AND ((d.value -> 'items'::text) ->> '$ref'::text) IS NULL
               THEN ((d.value -> 'items'::text) ->> 'type'::text)
             ELSE 'integer'::text
             END, '#/definitions/','') AS param_kind,
           (d.value ->> 'description'::text) AS description,
           (d.value ->> 'format'::text) AS format,
           (d.value ->> 'x-kubernetes-patch-merge-key'::text) AS merge_key,
           (d.value ->> 'x-kubernetes-patch-strategy'::text) AS patch_strategy,
           -- CASE
           --   WHEN d.key is null THEN false
           --   WHEN (api_resources.required_params ? d.key) THEN true
           --   ELSE false
           --     END
           --   AS required,
           -- with param type also containing array, we don't need array as a boolean
           -- CASE
           -- WHEN ((d.value ->> 'type'::text) = 'array'::text) THEN true
           -- ELSE false
           --  END AS "array"
           d.value
      FROM (api_resources
            JOIN LATERAL jsonb_each(api_resources.properties) d(key, value) ON (true))
     ORDER BY api_resources.id;
#+END_SRC

#+NAME: api_resources_fields view
#+BEGIN_SRC sql-mode :eval never-export :tangle ../apps/hasura/migrations/200_view_api_resources_fields.up.sql
  CREATE VIEW "public"."api_resources_fields" AS 
    SELECT api_resources.name as api_resource_name,
           api_resources.raw_swagger_id,
           d.key AS resource_field,
           CASE
           WHEN ((d.value ->> 'type'::text) IS NULL) THEN 'subtype'::text
           ELSE (d.value ->> 'type'::text)
             END AS param_type,
           replace(
             CASE
             WHEN ((d.value ->> 'type'::text) = 'string'::text) THEN 'string'::text
             WHEN ((d.value ->> 'type'::text) IS NULL) THEN (d.value ->> '$ref'::text)
             WHEN ((d.value ->> 'type'::text) = 'array'::text)
              AND ((d.value -> 'items'::text) ->> 'type'::text) IS NULL
               THEN ((d.value -> 'items'::text) ->> '$ref'::text)
             WHEN ((d.value ->> 'type'::text) = 'array'::text)
              AND ((d.value -> 'items'::text) ->> '$ref'::text) IS NULL
               THEN ((d.value -> 'items'::text) ->> 'type'::text)
             ELSE 'integer'::text
             END, '#/definitions/','') AS param_kind,
           (d.value ->> 'description'::text) AS description,
           (d.value ->> 'format'::text) AS format,
           (d.value ->> 'x-kubernetes-patch-merge-key'::text) AS merge_key,
           (d.value ->> 'x-kubernetes-patch-strategy'::text) AS patch_strategy,
           d.value
      FROM (api_resources
            JOIN LATERAL jsonb_each(api_resources.properties) d(key, value) ON (true));
#+END_SRC

#+NAME: track api_resources_fields
#+BEGIN_SRC yaml :tangle ../apps/hasura/migrations/200_view_api_resources_fields.up.yaml
- type: track_table
  args:
    schema: public
    name: api_resources_fields
#+END_SRC

* Over View
** TODO opname => op_param_name
** TODO opdescription => op_param_description
#+NAME: over view
#+BEGIN_SRC sql-mode :eval never-export :tangle ../apps/hasura/migrations/210_view_over.up.sql
  CREATE OR REPLACE VIEW "public"."over" AS
    SELECT
      op.name as opname,
      op.required,
      op.description as opdescription,
      o.operation_id,
      op.resource,
      r.name as resource_name,
      r.k8s_group,
      r.k8s_version,
      r.k8s_kind,
      rf.resource_field,
      rf.param_type,
      rf.param_kind,
      rf.description,
      rf.format,
      rf.merge_key,
      rf.patch_strategy
      FROM 
          api_operations_parameters op
          JOIN api_operations o ON (
            o.raw_swagger_id = op.raw_swagger_id
            AND
            o.operation_id = op.operation_id
          )
          LEFT JOIN api_resources r ON (
            op.resource = r.name
            AND
            op.raw_swagger_id = r.raw_swagger_id
            )
          LEFT JOIN api_resources_fields rf ON (
            rf.api_resource_name = r.name
            AND
            rf.raw_swagger_id = r.raw_swagger_id
          )
     ORDER BY op.name;
#+END_SRC

#+RESULTS: over view
#+begin_src sql-mode
CREATE VIEW
#+end_src

#+NAME: track over
#+BEGIN_SRC yaml :tangle ../apps/hasura/migrations/210_view_over.up.yaml
- type: track_table
  args:
    schema: public
    name: over
#+END_SRC

* #40: PodSpec and Audit Events
  There is only a single resource, it seems, that references podspec.  So our list of 'podspec fields' is really coming from this resource.
  
  #+RESULTS: Properties of podspec
  #+begin_src sql-mode
               field             |            name            
  -------------------------------+----------------------------
   hostIPC                       | io.k8s.api.core.v1.PodSpec
   hostPID                       | io.k8s.api.core.v1.PodSpec
   volumes                       | io.k8s.api.core.v1.PodSpec
   affinity                      | io.k8s.api.core.v1.PodSpec
   hostname                      | io.k8s.api.core.v1.PodSpec
   nodeName                      | io.k8s.api.core.v1.PodSpec
   overhead                      | io.k8s.api.core.v1.PodSpec
   priority                      | io.k8s.api.core.v1.PodSpec
   dnsConfig                     | io.k8s.api.core.v1.PodSpec
   dnsPolicy                     | io.k8s.api.core.v1.PodSpec
   subdomain                     | io.k8s.api.core.v1.PodSpec
   containers                    | io.k8s.api.core.v1.PodSpec
   hostAliases                   | io.k8s.api.core.v1.PodSpec
   hostNetwork                   | io.k8s.api.core.v1.PodSpec
   tolerations                   | io.k8s.api.core.v1.PodSpec
   nodeSelector                  | io.k8s.api.core.v1.PodSpec
   restartPolicy                 | io.k8s.api.core.v1.PodSpec
   schedulerName                 | io.k8s.api.core.v1.PodSpec
   initContainers                | io.k8s.api.core.v1.PodSpec
   readinessGates                | io.k8s.api.core.v1.PodSpec
   serviceAccount                | io.k8s.api.core.v1.PodSpec
   securityContext               | io.k8s.api.core.v1.PodSpec
   imagePullSecrets              | io.k8s.api.core.v1.PodSpec
   preemptionPolicy              | io.k8s.api.core.v1.PodSpec
   runtimeClassName              | io.k8s.api.core.v1.PodSpec
   priorityClassName             | io.k8s.api.core.v1.PodSpec
   enableServiceLinks            | io.k8s.api.core.v1.PodSpec
   serviceAccountName            | io.k8s.api.core.v1.PodSpec
   ephemeralContainers           | io.k8s.api.core.v1.PodSpec
   activeDeadlineSeconds         | io.k8s.api.core.v1.PodSpec
   shareProcessNamespace         | io.k8s.api.core.v1.PodSpec
   topologySpreadConstraints     | io.k8s.api.core.v1.PodSpec
   automountServiceAccountToken  | io.k8s.api.core.v1.PodSpec
   terminationGracePeriodSeconds | io.k8s.api.core.v1.PodSpec
  (34 rows)

  #+end_src

  #+RESULTS:
  #+begin_src sql-mode
              name            
  ----------------------------
   io.k8s.api.core.v1.PodSpec
  (1 row)
  #+end_src
  
  One thing we can try is to quickly connect the audit event to its api_operation, so that we get a standard definition of what happened.
  
  From there, we could see if that operation is part of the podSpec in some way.
 
  #+NAME: Properties of podspec
  #+BEGIN_SRC sql-mode
    SELECT 
      resource_field as field,
      api_resource_name as name
      FROM
          api_resources_fields
      WHERE api_resources_fields.api_resource_name ILIKE '%podspec%';
  #+END_SRC

  #+NAME: adding RegEx matching
  #+BEGIN_SRC sql-mode
    SELECT
      events.request_uri,
      ops.operation_id
      FROM audit_events events
         JOIN api_operations ops ON events.request_uri ~ ops.regex
      LIMIT 3;
  #+END_SRC

  #+RESULTS: adding RegEx matching
  #+begin_src sql-mode
                                      request_uri                                    |                         operation_id                          
  -----------------------------------------------------------------------------------+---------------------------------------------------------------
   /apis/rbac.authorization.k8s.io/v1beta1/namespaces/provisioning-6870/rolebindings | deleteRbacAuthorizationV1beta1CollectionNamespacedRoleBinding
   /apis/rbac.authorization.k8s.io/v1beta1/namespaces/provisioning-6870/rolebindings | listRbacAuthorizationV1beta1NamespacedRoleBinding
   /apis/rbac.authorization.k8s.io/v1beta1/namespaces/provisioning-6870/rolebindings | createRbacAuthorizationV1beta1NamespacedRoleBinding
  (3 rows)

  #+end_src

* TODO Create Import for CSV view
  We have a file started here: [[file:test_gen.org][test_gen.org]] 
  that brings in the work devan and caleb did to pull all the tests used in a specific/commit version of k8s.
  If we can build a script for this, then we can have:
  - A test name
  - its description
  - its link to official k8s definition
  - a link to the lines of go code that define it.
  
    We can then use this as a cross refernece for any audit event that references a test.
* IN-PROGRESS Indexed raw_audit_events                                                                                                                                                       
*** What does Success look like?                                                                                                                                                  
 - figure out how to get a count on a where clause                                                                                                                                
 - figure out how to get a distinct on something.                                                                                                                                 
 -  Being able to accurately fill out the hit counts in this query: https://hackmd.io/mnjYC64uQ1eKTr6PIXp5dw?view                                                                 
*** what's the itching confusion?                                                                                                                                                 
 - Proper way to index so that we can do a distinct                                                                                                                               
 - we have to avoid a table scan. Must have index for any place where we are trying to reference a row.                                                                           
   -  e.g. if table says `WHERE audit_event.parameter LIKE '%podspec%' we would need an index on audiet_event.parameter                                                           
 - api_operations: need to calculate, and leave as entry, 'audit_event_verb' (whetever its called) so we have a direct match later on audit_event table.                          
◉ FOOTNOTES...                                                                                                                                                 
*** Experiment
    What if we just load the event_verb and audit_id as distint columsn when the table is first being populated, since we are pulling from a temp table anyway?
    
    I can confirm it works with auditId(audit_id), verb(event_verb), and requestURI(request_uri).
    
    So we are putting the load of the work onto the population of data, instead of on the query, and this is happening from a raw file--and so it is much quicker..  
    Now, I am wondering if we can add operationID too, using a JOIN ON regex and verb.
    This requires setting up our api_operations a bit differently.
    
    We updated api_operations to include an event_verb, and should be able to run a query where we join the table based on the verb and regex matching.  but the query was hanging, likely because it was taking way too long to walk the tree of two un-indexed views.  Our strategythen is to amek both materialized views, that we can then create indexes on, to then make the joins much faster.
****  Create Table
    So we'll make a table that is expecting audit_id and event_verb 
 #+NAME: raw_audit_events test
 #+BEGIN_SRC sql-mode :notangle ../apps/hasura/migrations/220_table_raw_audit_events.up.sql :results silent
 CREATE TABLE zraw_audit_events (
     id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
     ingested_at timestamp DEFAULT CURRENT_TIMESTAMP,
     bucket text,
     job text,
     data jsonb NOT NULL,
     audit_id text,
     event_verb text,
     request_uri text,
     operation_id text
 );
 #+END_SRC
**** Iteration Loop
    
 #+NAME: Confirm Table Exists
 #+BEGIN_SRC sql-mode
   \d zraw_audit_events;
   -- delete from raw_audit_events;
 #+END_SRC

 #+RESULTS: Confirm Table Exists
 #+begin_src sql-mode
                                    Table "public.zraw_audit_events"
     Column    |            Type             | Collation | Nullable |             Default              
 --------------+-----------------------------+-----------+----------+----------------------------------
  id           | integer                     |           | not null | generated by default as identity
  ingested_at  | timestamp without time zone |           |          | CURRENT_TIMESTAMP
  bucket       | text                        |           |          | 
  job          | text                        |           |          | 
  data         | jsonb                       |           | not null | 
  audit_id     | text                        |           |          | 
  event_verb   | text                        |           |          | 
  request_uri  | text                        |           |          | 
  operation_id | text                        |           |          | 
 Indexes:
     "zraw_audit_events_pkey" PRIMARY KEY, btree (id)

 #+end_src

 #+NAME: Drop Table
 #+BEGIN_SRC sql-mode :results silent
 DROP TABLE IF EXISTS zraw_audit_events;
 #+END_SRC


 #+NAME: Test that new columns Work
 #+BEGIN_SRC sql-mode
 SELECT event_verb, audit_id, request_uri
 FROM zraw_audit_events
 LIMIT 8;
 #+END_SRC

 #+RESULTS: Test that new columns Work
 #+begin_src sql-mode
 ERROR:  relation "zraw_audit_events" does not exist
 LINE 2: FROM zraw_audit_events
              ^
 #+end_src

**** Load Audit Events
     
     We need to match our event to an operation ID.
     An operation ID is unique on raw_swagger_id, http method, and regex.
     So we should try to match the vent on the same three.
     raw.data ->> 'requestURI' ~ ops.regex
     raw.data ->> 'verb' = 
     ops.raw_swagger_id = 1
 #+NAME: experimental load_audit_events.sh
 #+BEGIN_SRC shell :var AUDIT_LOG="../data/artifacts/ci-kubernetes-e2e-gci-gce/1134962072287711234/combined-audit.log"

  BUCKET='ci-kubernetes-e2e-gci-gce'
  JOB='1134962072287711234'
  SQL="
  CREATE TEMPORARY TABLE raw_audit_events_import (data jsonb not null) ;
  copy raw_audit_events_import (data)
  FROM STDIN (DELIMITER e'\x02', FORMAT 'csv', QUOTE e'\x01');
  INSERT INTO zraw_audit_events(data, bucket, job, audit_id, event_verb, request_uri, operation_id)
  SELECT raw.data, '$BUCKET', '$JOB', (raw.data ->> 'auditID'), (raw.data ->> 'verb'), (raw.data ->> 'requestURI'), ops.operation_id
  FROM raw_audit_events_import raw
  LEFT JOIN api_operations_material ops ON
       ops.raw_swagger_id = 1
       AND raw.data ->> 'verb' = ops.event_verb
       AND raw.data ->> 'requestURI' ~ ops.regex;
  "
  cat $AUDIT_LOG | psql -c "$SQL" 2>&1
  date
 #+END_SRC

 #+RESULTS: experimental load_audit_events.sh
 #+begin_EXAMPLE
 INSERT 0 313431
 Mon Aug 12 22:41:18 UTC 2019
 #+end_EXAMPLE
 ** event_verb_to_http_method

  
 #+BEGIN_SRC sql-mode
SELECT DISTINCT audit_id, operation_id
FROM zraw_audit_events;
 #+END_SRC
 
 #+NAME: Distinct Key
 #+BEGIN_SRC sql-mode
select distinct data->'requestObject'->>'kind' as keys
from zraw_audit_events
order by keys;
 #+END_SRC

 #+RESULTS: Distinct Keys
 #+begin_src sql-mode
               keys              
 --------------------------------
  APIService
  Binding
  CertificateSigningRequest
  ClusterRole
  ClusterRoleBinding
  ControllerRevision
  CronJob
  CSIDriver
  CSINode
  CustomResourceDefinition
  DaemonSet
  DeleteOptions
  Deployment
  DeploymentRollback
  Endpoints
  HorizontalPodAutoscaler
  Job
  LimitRange
  MutatingWebhookConfiguration
  Namespace
  Node
  PersistentVolume
  PersistentVolumeClaim
  Pod
  PodDisruptionBudget
  PodSecurityPolicy
  PodTemplate
  PriorityClass
  ReplicaSet
  ReplicationController
  ResourceQuota
  Role
  RoleBinding
  RuntimeClass
  Scale
  Service
  ServiceAccount
  StatefulSet
  StorageClass
  SubjectAccessReview
  ValidatingWebhookConfiguration
  VolumeAttachment
 (43 rows)

 #+end_src

 
 - we did a join, and got 50k results, which seemed too small.
 - the join is based on matching regex, event_verb, and raw_swagger_id 
 - raw events is 300k, it shoudl be closer to that?
 - what is the reason for nulls?  how often is i
 #+NAME: Audit_events without matching operations: sample
 #+BEGIN_SRC sql-mode
   SELECT
     distinct event_verb
   FROM
     zraw_audit_events
   LIMIT 50;
 #+END_SRC

 #+RESULTS: Audit_events without matching operations: sample
 #+begin_src sql-mode
     event_verb    
 ------------------
  list
  deletecollection
  delete
  update
  get
  create
  post
  abcd
  watch
  patch
 (10 rows)

 #+end_src

 #+BEGIN_SRC sql-mode
   SELECT
     path, regex
   FROM
     api_operations_material 
    WHERE
      path LIKE '/apis/authorization.k8s.io/v1beta1/subjectaccessreviews%';

 #+END_SRC
 
 #+BEGIN_SRC sql-mode
select distinct param_kind from api_resources_fields order by param_kind;
-- select * from api_resources_fields where param_kind ilike '%PodSpec';
 #+END_SRC


 #+RESULTS:
 #+begin_src sql-mode
                                            param_kind                                            
 -------------------------------------------------------------------------------------------------
  integer
  io.k8s.api.admissionregistration.v1beta1.MutatingWebhookConfiguration
  io.k8s.api.admissionregistration.v1beta1.RuleWithOperations
  io.k8s.api.admissionregistration.v1beta1.ValidatingWebhookConfiguration
  io.k8s.api.admissionregistration.v1beta1.WebhookClientConfig
  io.k8s.api.admissionregistration.v1.MutatingWebhookConfiguration
  io.k8s.api.admissionregistration.v1.RuleWithOperations
  io.k8s.api.admissionregistration.v1.ValidatingWebhookConfiguration
  io.k8s.api.admissionregistration.v1.WebhookClientConfig
  io.k8s.api.apps.v1beta1.ControllerRevision
  io.k8s.api.apps.v1beta1.Deployment
  io.k8s.api.apps.v1beta1.DeploymentStrategy
  io.k8s.api.apps.v1beta1.RollbackConfig
  io.k8s.api.apps.v1beta1.StatefulSet
  io.k8s.api.apps.v1beta1.StatefulSetCondition
  io.k8s.api.apps.v1beta1.StatefulSetUpdateStrategy
  io.k8s.api.apps.v1beta2.ControllerRevision
  io.k8s.api.apps.v1beta2.DaemonSet
  io.k8s.api.apps.v1beta2.DaemonSetCondition
  io.k8s.api.apps.v1beta2.DaemonSetUpdateStrategy
  io.k8s.api.apps.v1beta2.Deployment
  io.k8s.api.apps.v1beta2.DeploymentStrategy
  io.k8s.api.apps.v1beta2.ReplicaSet
  io.k8s.api.apps.v1beta2.ReplicaSetCondition
  io.k8s.api.apps.v1beta2.StatefulSet
  io.k8s.api.apps.v1beta2.StatefulSetCondition
  io.k8s.api.apps.v1beta2.StatefulSetUpdateStrategy
  io.k8s.api.apps.v1.ControllerRevision
  io.k8s.api.apps.v1.DaemonSet
  io.k8s.api.apps.v1.DaemonSetCondition
  io.k8s.api.apps.v1.DaemonSetUpdateStrategy
  io.k8s.api.apps.v1.Deployment
  io.k8s.api.apps.v1.DeploymentStrategy
  io.k8s.api.apps.v1.ReplicaSet
  io.k8s.api.apps.v1.ReplicaSetCondition
  io.k8s.api.apps.v1.StatefulSet
  io.k8s.api.apps.v1.StatefulSetCondition
  io.k8s.api.apps.v1.StatefulSetUpdateStrategy
  io.k8s.api.auditregistration.v1alpha1.AuditSink
  io.k8s.api.auditregistration.v1alpha1.Policy
  io.k8s.api.auditregistration.v1alpha1.Webhook
  io.k8s.api.auditregistration.v1alpha1.WebhookClientConfig
  io.k8s.api.auditregistration.v1alpha1.WebhookThrottleConfig
  io.k8s.api.authentication.v1beta1.TokenReviewSpec
  io.k8s.api.authentication.v1beta1.TokenReviewStatus
  io.k8s.api.authentication.v1.BoundObjectReference
  io.k8s.api.authentication.v1.TokenRequestSpec
  io.k8s.api.authentication.v1.TokenRequestStatus
  io.k8s.api.authentication.v1.TokenReviewSpec
  io.k8s.api.authentication.v1.TokenReviewStatus
  io.k8s.api.authorization.v1beta1.NonResourceRule
  io.k8s.api.authorization.v1beta1.ResourceRule
  io.k8s.api.authorization.v1beta1.SelfSubjectAccessReviewSpec
  io.k8s.api.authorization.v1beta1.SelfSubjectRulesReviewSpec
  io.k8s.api.authorization.v1beta1.SubjectAccessReviewSpec
  io.k8s.api.authorization.v1beta1.SubjectAccessReviewStatus
  io.k8s.api.authorization.v1beta1.SubjectRulesReviewStatus
  io.k8s.api.authorization.v1.NonResourceRule
  io.k8s.api.authorization.v1.ResourceRule
  io.k8s.api.authorization.v1.SelfSubjectAccessReviewSpec
  io.k8s.api.authorization.v1.SelfSubjectRulesReviewSpec
  io.k8s.api.authorization.v1.SubjectAccessReviewSpec
  io.k8s.api.authorization.v1.SubjectAccessReviewStatus
  io.k8s.api.authorization.v1.SubjectRulesReviewStatus
  io.k8s.api.autoscaling.v1.CrossVersionObjectReference
  io.k8s.api.autoscaling.v1.HorizontalPodAutoscaler
  io.k8s.api.autoscaling.v2beta1.CrossVersionObjectReference
  io.k8s.api.autoscaling.v2beta1.ExternalMetricSource
  io.k8s.api.autoscaling.v2beta1.ExternalMetricStatus
  io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscaler
  io.k8s.api.autoscaling.v2beta1.HorizontalPodAutoscalerCondition
  io.k8s.api.autoscaling.v2beta1.MetricSpec
  io.k8s.api.autoscaling.v2beta1.MetricStatus
  io.k8s.api.autoscaling.v2beta1.ObjectMetricSource
  io.k8s.api.autoscaling.v2beta1.ObjectMetricStatus
  io.k8s.api.autoscaling.v2beta1.PodsMetricSource
  io.k8s.api.autoscaling.v2beta1.PodsMetricStatus
  io.k8s.api.autoscaling.v2beta1.ResourceMetricSource
  io.k8s.api.autoscaling.v2beta1.ResourceMetricStatus
  io.k8s.api.autoscaling.v2beta2.CrossVersionObjectReference
  io.k8s.api.autoscaling.v2beta2.ExternalMetricSource
  io.k8s.api.autoscaling.v2beta2.ExternalMetricStatus
  io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscaler
  io.k8s.api.autoscaling.v2beta2.HorizontalPodAutoscalerCondition
  io.k8s.api.autoscaling.v2beta2.MetricIdentifier
  io.k8s.api.autoscaling.v2beta2.MetricSpec
  io.k8s.api.autoscaling.v2beta2.MetricStatus
  io.k8s.api.autoscaling.v2beta2.MetricTarget
  io.k8s.api.autoscaling.v2beta2.MetricValueStatus
  io.k8s.api.autoscaling.v2beta2.ObjectMetricSource
  io.k8s.api.autoscaling.v2beta2.ObjectMetricStatus
  io.k8s.api.autoscaling.v2beta2.PodsMetricSource
  io.k8s.api.autoscaling.v2beta2.PodsMetricStatus
  io.k8s.api.autoscaling.v2beta2.ResourceMetricSource
  io.k8s.api.autoscaling.v2beta2.ResourceMetricStatus
  io.k8s.api.batch.v1beta1.CronJob
  io.k8s.api.batch.v1beta1.JobTemplateSpec
  io.k8s.api.batch.v1.Job
  io.k8s.api.batch.v2alpha1.CronJob
  io.k8s.api.batch.v2alpha1.JobTemplateSpec
  io.k8s.api.certificates.v1beta1.CertificateSigningRequest
  io.k8s.api.coordination.v1beta1.Lease
  io.k8s.api.coordination.v1.Lease
  io.k8s.api.core.v1.Affinity
  io.k8s.api.core.v1.AWSElasticBlockStoreVolumeSource
  io.k8s.api.core.v1.AzureDiskVolumeSource
  io.k8s.api.core.v1.AzureFileVolumeSource
  io.k8s.api.core.v1.CephFSVolumeSource
  io.k8s.api.core.v1.CinderVolumeSource
  io.k8s.api.core.v1.ComponentStatus
  io.k8s.api.core.v1.ConfigMap
  io.k8s.api.core.v1.ConfigMapVolumeSource
  io.k8s.api.core.v1.Container
  io.k8s.api.core.v1.ContainerPort
  io.k8s.api.core.v1.ContainerState
  io.k8s.api.core.v1.CSIVolumeSource
  io.k8s.api.core.v1.DownwardAPIVolumeSource
  io.k8s.api.core.v1.EmptyDirVolumeSource
  io.k8s.api.core.v1.Endpoints
  io.k8s.api.core.v1.EnvFromSource
  io.k8s.api.core.v1.EnvVar
  io.k8s.api.core.v1.EnvVarSource
  io.k8s.api.core.v1.EphemeralContainer
  io.k8s.api.core.v1.Event
  io.k8s.api.core.v1.EventSeries
  io.k8s.api.core.v1.EventSource
  io.k8s.api.core.v1.FCVolumeSource
  io.k8s.api.core.v1.FlexVolumeSource
  io.k8s.api.core.v1.FlockerVolumeSource
  io.k8s.api.core.v1.GCEPersistentDiskVolumeSource
  io.k8s.api.core.v1.GitRepoVolumeSource
  io.k8s.api.core.v1.GlusterfsVolumeSource
  io.k8s.api.core.v1.HostAlias
  io.k8s.api.core.v1.HostPathVolumeSource
  io.k8s.api.core.v1.HTTPHeader
  io.k8s.api.core.v1.ISCSIVolumeSource
  io.k8s.api.core.v1.Lifecycle
  io.k8s.api.core.v1.LimitRange
  io.k8s.api.core.v1.LimitRangeItem
  io.k8s.api.core.v1.LocalObjectReference
  io.k8s.api.core.v1.Namespace
  io.k8s.api.core.v1.NFSVolumeSource
  io.k8s.api.core.v1.Node
  io.k8s.api.core.v1.NodeSelectorTerm
  io.k8s.api.core.v1.ObjectFieldSelector
  io.k8s.api.core.v1.ObjectReference
  io.k8s.api.core.v1.PersistentVolume
  io.k8s.api.core.v1.PersistentVolumeClaim
  io.k8s.api.core.v1.PersistentVolumeClaimVolumeSource
  io.k8s.api.core.v1.PhotonPersistentDiskVolumeSource
  io.k8s.api.core.v1.Pod
  io.k8s.api.core.v1.PodAffinityTerm
  io.k8s.api.core.v1.PodDNSConfig
  io.k8s.api.core.v1.PodReadinessGate
  io.k8s.api.core.v1.PodSecurityContext
  io.k8s.api.core.v1.PodTemplate
  io.k8s.api.core.v1.PodTemplateSpec
  io.k8s.api.core.v1.PortworxVolumeSource
  io.k8s.api.core.v1.Probe
  io.k8s.api.core.v1.ProjectedVolumeSource
  io.k8s.api.core.v1.QuobyteVolumeSource
  io.k8s.api.core.v1.RBDVolumeSource
  io.k8s.api.core.v1.ReplicationController
  io.k8s.api.core.v1.ReplicationControllerCondition
  io.k8s.api.core.v1.ResourceFieldSelector
  io.k8s.api.core.v1.ResourceQuota
  io.k8s.api.core.v1.ResourceRequirements
  io.k8s.api.core.v1.ScaleIOVolumeSource
  io.k8s.api.core.v1.Secret
  io.k8s.api.core.v1.SecretReference
  io.k8s.api.core.v1.SecretVolumeSource
  io.k8s.api.core.v1.SecurityContext
  io.k8s.api.core.v1.SELinuxOptions
  io.k8s.api.core.v1.Service
  io.k8s.api.core.v1.ServiceAccount
  io.k8s.api.core.v1.StorageOSVolumeSource
  io.k8s.api.core.v1.Toleration
  io.k8s.api.core.v1.TopologySelectorTerm
  io.k8s.api.core.v1.TopologySpreadConstraint
  io.k8s.api.core.v1.Volume
  io.k8s.api.core.v1.VolumeDevice
  io.k8s.api.core.v1.VolumeMount
  io.k8s.api.core.v1.VolumeProjection
  io.k8s.api.core.v1.VsphereVirtualDiskVolumeSource
  io.k8s.api.events.v1beta1.Event
  io.k8s.api.events.v1beta1.EventSeries
  io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceColumnDefinition
  io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceConversion
  io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinition
  io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionCondition
  io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionNames
  io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionSpec
  io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionStatus
  io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceDefinitionVersion
  io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceSubresources
  io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.CustomResourceValidation
  io.k8s.apiextensions-apiserver.pkg.apis.apiextensions.v1beta1.WebhookClientConfig
  io.k8s.api.extensions.v1beta1.AllowedCSIDriver
  io.k8s.api.extensions.v1beta1.AllowedFlexVolume
  io.k8s.api.extensions.v1beta1.AllowedHostPath
  io.k8s.api.extensions.v1beta1.DaemonSet
  io.k8s.api.extensions.v1beta1.DaemonSetCondition
  io.k8s.api.extensions.v1beta1.DaemonSetUpdateStrategy
  io.k8s.api.extensions.v1beta1.Deployment
  io.k8s.api.extensions.v1beta1.DeploymentStrategy
  io.k8s.api.extensions.v1beta1.FSGroupStrategyOptions
  io.k8s.api.extensions.v1beta1.HostPortRange
  io.k8s.api.extensions.v1beta1.HTTPIngressPath
  io.k8s.api.extensions.v1beta1.IDRange
  io.k8s.api.extensions.v1beta1.Ingress
  io.k8s.api.extensions.v1beta1.IngressBackend
  io.k8s.api.extensions.v1beta1.NetworkPolicy
  io.k8s.api.extensions.v1beta1.NetworkPolicyEgressRule
  io.k8s.api.extensions.v1beta1.NetworkPolicyIngressRule
  io.k8s.api.extensions.v1beta1.PodSecurityPolicy
  io.k8s.api.extensions.v1beta1.ReplicaSet
  io.k8s.api.extensions.v1beta1.ReplicaSetCondition
  io.k8s.api.extensions.v1beta1.RollbackConfig
  io.k8s.api.extensions.v1beta1.RunAsGroupStrategyOptions
  io.k8s.api.extensions.v1beta1.RunAsUserStrategyOptions
  io.k8s.api.extensions.v1beta1.RuntimeClassStrategyOptions
  io.k8s.api.extensions.v1beta1.SELinuxStrategyOptions
  io.k8s.api.extensions.v1beta1.SupplementalGroupsStrategyOptions
  io.k8s.apimachinery.pkg.api.resource.Quantity
  io.k8s.apimachinery.pkg.apis.meta.v1.APIGroup
  io.k8s.apimachinery.pkg.apis.meta.v1.APIResource
  io.k8s.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery
  io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelector
  io.k8s.apimachinery.pkg.apis.meta.v1.ListMeta
  io.k8s.apimachinery.pkg.apis.meta.v1.MicroTime
  io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta
  io.k8s.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR
  io.k8s.apimachinery.pkg.apis.meta.v1.Time
  io.k8s.apimachinery.pkg.runtime.RawExtension
  io.k8s.apimachinery.pkg.util.intstr.IntOrString
  io.k8s.api.networking.v1beta1.HTTPIngressPath
  io.k8s.api.networking.v1beta1.Ingress
  io.k8s.api.networking.v1beta1.IngressBackend
  io.k8s.api.networking.v1.NetworkPolicy
  io.k8s.api.networking.v1.NetworkPolicyEgressRule
  io.k8s.api.networking.v1.NetworkPolicyIngressRule
  io.k8s.api.node.v1alpha1.Overhead
  io.k8s.api.node.v1alpha1.RuntimeClass
  io.k8s.api.node.v1alpha1.RuntimeClassSpec
  io.k8s.api.node.v1alpha1.Scheduling
  io.k8s.api.node.v1beta1.Overhead
  io.k8s.api.node.v1beta1.RuntimeClass
  io.k8s.api.node.v1beta1.Scheduling
  io.k8s.api.policy.v1beta1.AllowedCSIDriver
  io.k8s.api.policy.v1beta1.AllowedFlexVolume
  io.k8s.api.policy.v1beta1.AllowedHostPath
  io.k8s.api.policy.v1beta1.FSGroupStrategyOptions
  io.k8s.api.policy.v1beta1.HostPortRange
  io.k8s.api.policy.v1beta1.IDRange
  io.k8s.api.policy.v1beta1.PodDisruptionBudget
  io.k8s.api.policy.v1beta1.PodSecurityPolicy
  io.k8s.api.policy.v1beta1.RunAsGroupStrategyOptions
  io.k8s.api.policy.v1beta1.RunAsUserStrategyOptions
  io.k8s.api.policy.v1beta1.RuntimeClassStrategyOptions
  io.k8s.api.policy.v1beta1.SELinuxStrategyOptions
  io.k8s.api.policy.v1beta1.SupplementalGroupsStrategyOptions
  io.k8s.api.rbac.v1alpha1.ClusterRole
  io.k8s.api.rbac.v1alpha1.ClusterRoleBinding
  io.k8s.api.rbac.v1alpha1.Role
  io.k8s.api.rbac.v1alpha1.RoleBinding
  io.k8s.api.rbac.v1alpha1.RoleRef
  io.k8s.api.rbac.v1alpha1.Subject
  io.k8s.api.rbac.v1beta1.ClusterRole
  io.k8s.api.rbac.v1beta1.ClusterRoleBinding
  io.k8s.api.rbac.v1beta1.Role
  io.k8s.api.rbac.v1beta1.RoleBinding
  io.k8s.api.rbac.v1beta1.RoleRef
  io.k8s.api.rbac.v1beta1.Subject
  io.k8s.api.rbac.v1.ClusterRole
  io.k8s.api.rbac.v1.ClusterRoleBinding
  io.k8s.api.rbac.v1.Role
  io.k8s.api.rbac.v1.RoleBinding
  io.k8s.api.rbac.v1.RoleRef
  io.k8s.api.rbac.v1.Subject
  io.k8s.api.scheduling.v1alpha1.PriorityClass
  io.k8s.api.scheduling.v1beta1.PriorityClass
  io.k8s.api.scheduling.v1.PriorityClass
  io.k8s.api.settings.v1alpha1.PodPreset
  io.k8s.api.storage.v1alpha1.VolumeAttachment
  io.k8s.api.storage.v1alpha1.VolumeAttachmentSource
  io.k8s.api.storage.v1alpha1.VolumeAttachmentSpec
  io.k8s.api.storage.v1alpha1.VolumeAttachmentStatus
  io.k8s.api.storage.v1alpha1.VolumeError
  io.k8s.api.storage.v1beta1.CSIDriver
  io.k8s.api.storage.v1beta1.CSIDriverSpec
  io.k8s.api.storage.v1beta1.CSINode
  io.k8s.api.storage.v1beta1.CSINodeDriver
  io.k8s.api.storage.v1beta1.CSINodeSpec
  io.k8s.api.storage.v1beta1.StorageClass
  io.k8s.api.storage.v1beta1.VolumeAttachment
  io.k8s.api.storage.v1beta1.VolumeAttachmentSource
  io.k8s.api.storage.v1beta1.VolumeAttachmentSpec
  io.k8s.api.storage.v1beta1.VolumeAttachmentStatus
  io.k8s.api.storage.v1beta1.VolumeError
  io.k8s.api.storage.v1beta1.VolumeNodeResources
  io.k8s.api.storage.v1.StorageClass
  io.k8s.api.storage.v1.VolumeAttachment
  io.k8s.api.storage.v1.VolumeAttachmentSource
  io.k8s.api.storage.v1.VolumeAttachmentSpec
  io.k8s.api.storage.v1.VolumeAttachmentStatus
  io.k8s.api.storage.v1.VolumeError
  io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIService
  io.k8s.kube-aggregator.pkg.apis.apiregistration.v1beta1.APIService
  io.k8s.kube-aggregator.pkg.apis.apiregistration.v1beta1.ServiceReference
  io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.ServiceReference
  string
 (311 rows)

 #+end_src
 
 #+BEGIN_SRC sql-mode
   select
      distinct request_uri
   from
     zraw_audit_events
   where 
     operation_id IS NULL
     AND event_verb = 'get'
     AND request_uri like '/api%'
     AND request_uri not like '%proxy%'
     AND request_uri like '%timeout%'

   order by request_uri
   LIMIT 500;
 #+END_SRC

 #+RESULTS:
 #+begin_src sql-mode
                                   request_uri                                   
 --------------------------------------------------------------------------------
  /apis/admissionregistration.k8s.io/v1beta1?timeout=32s
  /apis/apiextensions.k8s.io/v1beta1?timeout=32s
  /apis/apiregistration.k8s.io/v1beta1?timeout=32s
  /apis/apiregistration.k8s.io/v1?timeout=32s
  /apis/apps/v1beta1?timeout=32s
  /apis/apps/v1beta2?timeout=32s
  /apis/apps/v1?timeout=32s
  /apis/authentication.k8s.io/v1beta1?timeout=32s
  /apis/authentication.k8s.io/v1?timeout=32s
  /apis/authorization.k8s.io/v1beta1?timeout=32s
  /apis/authorization.k8s.io/v1?timeout=32s
  /apis/autoscaling/v1?timeout=32s
  /apis/autoscaling/v2beta1?timeout=32s
  /apis/autoscaling/v2beta2?timeout=32s
  /apis/batch/v1beta1?timeout=32s
  /apis/batch/v1?timeout=32s
  /apis/batch/v2alpha1?timeout=32s
  /apis/certificates.k8s.io/v1beta1?timeout=32s
  /apis/coordination.k8s.io/v1beta1?timeout=32s
  /apis/coordination.k8s.io/v1?timeout=32s
  /apis/crd-publish-openapi-test-common-group.k8s.io/v4?timeout=32s
  /apis/crd-publish-openapi-test-common-group.k8s.io/v5?timeout=32s
  /apis/crd-publish-openapi-test-common-group.k8s.io/v6?timeout=32s
  /apis/crd-publish-openapi-test-empty.k8s.io/v1?timeout=32s
  /apis/crd-publish-openapi-test-foo.k8s.io/v1?timeout=32s
  /apis/crd-publish-openapi-test-multi-to-single-ver.k8s.io/v5?timeout=32s
  /apis/crd-publish-openapi-test-multi-to-single-ver.k8s.io/v6alpha1?timeout=32s
  /apis/crd-publish-openapi-test-multi-ver.k8s.io/v2?timeout=32s
  /apis/crd-publish-openapi-test-multi-ver.k8s.io/v3?timeout=32s
  /apis/crd-publish-openapi-test-multi-ver.k8s.io/v4?timeout=32s
  /apis/crd-publish-openapi-test-waldo.k8s.io/v1beta1?timeout=32s
  /apis/discovery-crd-test.k8s.io/v1?timeout=32s
  /apis/events.k8s.io/v1beta1?timeout=32s
  /apis/extensions/v1beta1?timeout=32s
  /apis/kubectl-crd-test.k8s.io/v1?timeout=32s
  /apis/metrics.k8s.io/v1beta1?timeout=32s
  /apis/mygroup.example.com/v1beta1?timeout=32s
  /apis/networking.k8s.io/v1beta1?timeout=32s
  /apis/networking.k8s.io/v1?timeout=32s
  /apis/node.k8s.io/v1beta1?timeout=32s
  /apis/policy/v1beta1?timeout=32s
  /apis/rbac.authorization.k8s.io/v1beta1?timeout=32s
  /apis/rbac.authorization.k8s.io/v1?timeout=32s
  /apis/resourcequota-crd-test.k8s.io/v1?timeout=32s
  /apis/scalingpolicy.kope.io/v1alpha1?timeout=32s
  /apis/scheduling.k8s.io/v1alpha1?timeout=32s
  /apis/scheduling.k8s.io/v1beta1?timeout=32s
  /apis/scheduling.k8s.io/v1?timeout=32s
  /apis/settings.k8s.io/v1alpha1?timeout=32s
  /apis/snapshot.storage.k8s.io/v1alpha1?timeout=32s
  /apis/stable.example.com/v1?timeout=32s
  /apis/stable.example.com/v2?timeout=32s
  /apis/storage.k8s.io/v1beta1?timeout=32s
  /apis/storage.k8s.io/v1?timeout=32s
  /apis?timeout=32s
  /apis/wardle.k8s.io/v1alpha1?timeout=32s
  /apis/webhook-crd-test.k8s.io/v1?timeout=32s
  /apis/webhook-multiversion-crd-test.k8s.io/v1?timeout=32s
  /apis/webhook-multiversion-crd-test.k8s.io/v2?timeout=32s
  /api?timeout=32s
  /api/v1?timeout=32s
 (61 rows)

 #+end_src


* TODO Adjust api_operations_material with correct mapping of event verb
  Our original event_verb assumed that the audit_event would only have the http request verbs available.

  Now that we have the zraw_audit_events table, though, we can see this is not the case.
  #+NAME:Distinct Event Verbs in audit_events
  #+BEGIN_SRC sql-mode
  SELECT DISTINCT event_verb
  FROM zraw_audit_events;
  #+END_SRC
  
  #+RESULTS: Distinct Event Verbs in audit_events
  #+begin_src sql-mode
      event_verb    
  ------------------
   list
   deletecollection
   delete
   update
   get
   create
   post
   abcd
   watch
   patch
  (10 rows)
  #+end_src
  
  Our api_operations_material reduces a number of possible verbs into the https request verbs
  #+NAME: event verbs and k8s_actions in api_operations_material
  #+BEGIN_SRC sql-mode
  SELECT DISTINCT k8s_action, event_verb
  FROM api_operations_material
  ORDER BY event_verb;
  #+END_SRC

  #+RESULTS: event verbs and k8s_actions in api_operations_material
  #+begin_src sql-mode
      k8s_action    | event_verb 
  ------------------+------------
   connect          | connect
   delete           | delete
   deletecollection | delete
   get              | get
   list             | get
   patch            | patch
   post             | post
   put              | put
   watchlist        | watch
   watch            | watch
                    | 
  (11 rows)
  #+end_src

 This means that audit_events are returning null because these verbs have been absorbed in our mapping incorrectly.  
 For example, list and deleteCollection will return null even though there's a direct connect between the audit event verb and the api_operations k8s_action.
 The two verbs on the audit_event side that don't fully map are =create= and =update= 
  
 We could likely see what their mapping to k8s_action should be by checking their request_uri or request object
 
 #+NAME: request_uri of create audit_events
 #+BEGIN_SRC sql-mode
   SELECT
     request_uri,
     event_verb FROM zraw_audit_events WHERE
     event_verb = 'create'
   LIMIT
     10;

 #+END_SRC

 #+RESULTS: request_uri of create audit_events
 #+begin_src sql-mode
                                        request_uri                                        | event_verb 
 ------------------------------------------------------------------------------------------+------------
  /apis/rbac.authorization.k8s.io/v1beta1/namespaces/node-lease-test-6991/rolebindings     | create
  /apis/authorization.k8s.io/v1beta1/subjectaccessreviews                                  | create
  /api/v1/namespaces/provisioning-62/pods                                                  | create
  /apis/authorization.k8s.io/v1beta1/subjectaccessreviews                                  | create
  /api/v1/namespaces/nettest-1762/pods/host-test-container-pod/binding                     | create
  /api/v1/namespaces/kube-system/configmaps                                                | create
  /apis/autoscaling/v1/namespaces/horizontal-pod-autoscaling-3029/horizontalpodautoscalers | create
  /api/v1/namespaces/volumemode-6821/secrets                                               | create
  /api/v1/namespaces/deployment-2887/pods/test-cleanup-controller-2pkb8/binding            | create
  /apis/authorization.k8s.io/v1beta1/subjectaccessreviews                                  | create
 (10 rows)

 #+end_src

 Never mind!

It makes sense to me that 'create' would be a post and update a put.  The problem is that post is already present in both k8s_action and event_verb...so we can't do a one to one match.  I think we need to do an ANY on the event verb array.  so the api_operations_material event_verb wold be ['create', 'post'] .  I had an issue doing this, and so made it a comma separated string.  We can then update our join clause as a like

I've updated the api_operations for that.  Then we'll update our zraw_audit_events to map on any instead.

So we can now see our distinct event_verbs in the api_operations_material view
#+NAME: Distinct Event Verbs in api_operations_material
#+BEGIN_SRC sql-mode
select distinct event_verb from api_operations_material;
#+END_SRC

#+RESULTS: Distinct Event Verbs in api_operations_material
#+begin_src sql-mode
     event_verb     
--------------------
 
 {watch}
 {post,create}
 {get}
 {connect}
 {patch}
 {list}
 {deletecollection}
 {put,update}
(9 rows)

#+end_src

Now we need to update our zraw_audit_events_view remaking its operation_id
#+NAME: Update zraw_audit_events
#+BEGIN_SRC sql-mode 
  UPDATE zraw_audit_events AS raw
  SET operation_id = ops.operation_id
  FROM api_operations_material ops
  WHERE
      ops.raw_swagger_id = 1
      AND raw.data ->> 'verb' = ANY(ops.event_verb)
      AND raw.data ->> 'requestURI' ~ ops.regex;
#+END_SRC


  
* TODO update zraw_audit_events now that mapping is correct
* TODO run query on count of audit_events whose operation_id is null.  hope for <50k
* FOOTNOTES
** load audit_events_via local cli

#+BEGIN_SRC sql-mode
  \d raw_audit_events;
  -- delete from raw_audit_events;
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
                                   Table "public.raw_audit_events"
   Column    |            Type             | Collation | Nullable |             Default              
-------------+-----------------------------+-----------+----------+----------------------------------
 id          | integer                     |           | not null | generated by default as identity
 ingested_at | timestamp without time zone |           |          | CURRENT_TIMESTAMP
 bucket      | text                        |           |          | 
 job         | text                        |           |          | 
 data        | jsonb                       |           | not null | 
Indexes:
    "raw_audit_events_pkey" PRIMARY KEY, btree (id)

#+end_src


#+NAME: load_audit_events.sh
#+BEGIN_SRC shell :var AUDIT_LOG="../data/artifacts/ci-kubernetes-e2e-gci-gce/1134962072287711234/combined-audit.log"
  BUCKET='ci-kubernetes-e2e-gci-gce'
  JOB='1134962072287711234'
  SQL="
  CREATE TEMPORARY TABLE raw_audit_events_import (data jsonb not null) ;
  copy raw_audit_events_import (data)
  FROM STDIN (DELIMITER e'\x02', FORMAT 'csv', QUOTE e'\x01');
  INSERT INTO raw_audit_events(data, bucket, job)
  SELECT data, '$BUCKET', '$JOB'
  FROM raw_audit_events_import;
  "
  cat $AUDIT_LOG | psql -c "$SQL"
  date
#+END_SRC

#+RESULTS: load_audit_events.sh
#+begin_EXAMPLE
INSERT 0 313431
Thu Aug  8 01:14:52 UTC 2019
#+end_EXAMPLE

#+BEGIN_SRC sql-mode
  select distinct bucket, job from raw_audit_events;
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
 bucket  | job  
---------+------
 bucket1 | job1
(1 row)

#+end_src

#+BEGIN_SRC sql-mode
\dt+
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
                          List of relations
 Schema |       Name       | Type  | Owner |    Size    | Description 
--------+------------------+-------+-------+------------+-------------
 public | audit_events     | table | zz    | 8192 bytes | 
 public | raw_audit_events | table | zz    | 376 MB     | 
 public | raw_swaggers     | table | zz    | 1752 kB    | 
(3 rows)

#+end_src

# Local Variables:
# eval: (sql-connect "hasura" (concat "*SQL: postgres:data*"))
# End:
* TODO MAJOR

** What we want!
#+BEGIN_SRC sql-mode
select distinct api_resource_name, resource_field as field, param_kind as kind, 0 as hits, 0 as test_hits, 0 as conformance_hits
from api_resources_fields
where api_resource_name like '%PodSpec%'
order by field; 
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
     api_resource_name      |             field             |                    kind                     | hits | test_hits | conformance_hits 
----------------------------+-------------------------------+---------------------------------------------+------+-----------+------------------
 io.k8s.api.core.v1.PodSpec | activeDeadlineSeconds         | integer                                     |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | affinity                      | io.k8s.api.core.v1.Affinity                 |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | automountServiceAccountToken  | integer                                     |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | containers                    | io.k8s.api.core.v1.Container                |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | dnsConfig                     | io.k8s.api.core.v1.PodDNSConfig             |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | dnsPolicy                     | string                                      |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | enableServiceLinks            | integer                                     |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | ephemeralContainers           | io.k8s.api.core.v1.EphemeralContainer       |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | hostAliases                   | io.k8s.api.core.v1.HostAlias                |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | hostIPC                       | integer                                     |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | hostname                      | string                                      |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | hostNetwork                   | integer                                     |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | hostPID                       | integer                                     |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | imagePullSecrets              | io.k8s.api.core.v1.LocalObjectReference     |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | initContainers                | io.k8s.api.core.v1.Container                |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | nodeName                      | string                                      |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | nodeSelector                  | integer                                     |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | overhead                      | integer                                     |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | preemptionPolicy              | string                                      |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | priority                      | integer                                     |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | priorityClassName             | string                                      |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | readinessGates                | io.k8s.api.core.v1.PodReadinessGate         |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | restartPolicy                 | string                                      |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | runtimeClassName              | string                                      |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | schedulerName                 | string                                      |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | securityContext               | io.k8s.api.core.v1.PodSecurityContext       |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | serviceAccount                | string                                      |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | serviceAccountName            | string                                      |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | shareProcessNamespace         | integer                                     |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | subdomain                     | string                                      |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | terminationGracePeriodSeconds | integer                                     |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | tolerations                   | io.k8s.api.core.v1.Toleration               |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | topologySpreadConstraints     | io.k8s.api.core.v1.TopologySpreadConstraint |    0 |         0 |                0
 io.k8s.api.core.v1.PodSpec | volumes                       | io.k8s.api.core.v1.Volume                   |    0 |         0 |                0
(34 rows)

#+end_src

** where is PodSecurityContext

*** Pod is a kind
#+BEGIN_SRC shell :wrap "SRC json"
cat ~/go/src/k8s.io/kubernetes/api/openapi-spec/swagger.json | jq '.definitions["io.k8s.api.core.v1.Pod"]'
#+END_SRC

#+RESULTS:
#+begin_SRC json
{
  "description": "Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.",
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#resources",
      "type": "string"
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
      "type": "string"
    },
    "metadata": {
      "$ref": "#/definitions/io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta",
      "description": "Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata"
    },
    "spec": {
      "$ref": "#/definitions/io.k8s.api.core.v1.PodSpec",
      "description": "Specification of the desired behavior of the pod. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status"
    },
    "status": {
      "$ref": "#/definitions/io.k8s.api.core.v1.PodStatus",
      "description": "Most recently observed status of the pod. This data may not be up to date. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status"
    }
  },
  "type": "object",
  "x-kubernetes-group-version-kind": [
    {
      "group": "",
      "kind": "Pod",
      "version": "v1"
    }
  ]
}
#+end_SRC
*** Pod is used by operations
#+BEGIN_SRC sql-mode
select k8s_version, k8s_kind, description from api_operations_material where k8s_kind = 'Pod';
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
 k8s_version | k8s_kind |                                                                                description                                                                                 
-------------+----------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 v1          | Pod      | delete collection of Pod 
 v1          | Pod      | list or watch objects of kind Pod
 v1          | Pod      | create a Pod
 v1          | Pod      | delete a Pod
 v1          | Pod      | read the specified Pod
 v1          | Pod      | partially update the specified Pod
 v1          | Pod      | replace the specified Pod
 v1          | Pod      | read log of the specified Pod
 v1          | Pod      | read status of the specified Pod
 v1          | Pod      | partially update status of the specified Pod
 v1          | Pod      | replace status of the specified Pod
 v1          | Pod      | list or watch objects of kind Pod
 v1          | Pod      | watch individual changes to a list of Pod. deprecated: use the 'watch' parameter with a list operation instead.
 v1          | Pod      | watch changes to an object of kind Pod. deprecated: use the 'watch' parameter with a list operation instead, filtered to a single item with the 'fieldSelector' parameter.
 v1          | Pod      | watch individual changes to a list of Pod. deprecated: use the 'watch' parameter with a list operation instead.
(15 rows)

#+end_src
** Pod is not in api_resources

#+BEGIN_SRC sql-mode


#+END_SRC



** distinct api_resource_name from api_resource_fields don't have Pod

#+BEGIN_SRC sql-mode
select distinct api_resource_name as name
 from api_resources_fields
 where api_resource_name not like '%alpha%'
 and api_resource_name not like '%beta%'
order by api_resource_name;
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
                                  name                                  
------------------------------------------------------------------------
 io.k8s.api.admissionregistration.v1.MutatingWebhook
 io.k8s.api.admissionregistration.v1.MutatingWebhookConfigurationList
 io.k8s.api.admissionregistration.v1.ServiceReference
 io.k8s.api.admissionregistration.v1.ValidatingWebhook
 io.k8s.api.admissionregistration.v1.ValidatingWebhookConfigurationList
 io.k8s.api.apps.v1.ControllerRevision
 io.k8s.api.apps.v1.ControllerRevisionList
 io.k8s.api.apps.v1.DaemonSetCondition
 io.k8s.api.apps.v1.DaemonSetList
 io.k8s.api.apps.v1.DaemonSetSpec
 io.k8s.api.apps.v1.DaemonSetStatus
 io.k8s.api.apps.v1.DeploymentCondition
 io.k8s.api.apps.v1.DeploymentList
 io.k8s.api.apps.v1.DeploymentSpec
 io.k8s.api.apps.v1.ReplicaSetCondition
 io.k8s.api.apps.v1.ReplicaSetList
 io.k8s.api.apps.v1.ReplicaSetSpec
 io.k8s.api.apps.v1.ReplicaSetStatus
 io.k8s.api.apps.v1.StatefulSetCondition
 io.k8s.api.apps.v1.StatefulSetList
 io.k8s.api.apps.v1.StatefulSetSpec
 io.k8s.api.apps.v1.StatefulSetStatus
 io.k8s.api.authentication.v1.TokenRequest
 io.k8s.api.authentication.v1.TokenRequestSpec
 io.k8s.api.authentication.v1.TokenRequestStatus
 io.k8s.api.authentication.v1.TokenReview
 io.k8s.api.authorization.v1.LocalSubjectAccessReview
 io.k8s.api.authorization.v1.NonResourceRule
 io.k8s.api.authorization.v1.ResourceRule
 io.k8s.api.authorization.v1.SelfSubjectAccessReview
 io.k8s.api.authorization.v1.SelfSubjectRulesReview
 io.k8s.api.authorization.v1.SubjectAccessReview
 io.k8s.api.authorization.v1.SubjectAccessReviewStatus
 io.k8s.api.authorization.v1.SubjectRulesReviewStatus
 io.k8s.api.autoscaling.v1.CrossVersionObjectReference
 io.k8s.api.autoscaling.v1.HorizontalPodAutoscalerList
 io.k8s.api.autoscaling.v1.HorizontalPodAutoscalerSpec
 io.k8s.api.autoscaling.v1.HorizontalPodAutoscalerStatus
 io.k8s.api.autoscaling.v1.ScaleStatus
 io.k8s.api.batch.v1.JobCondition
 io.k8s.api.batch.v1.JobList
 io.k8s.api.batch.v1.JobSpec
 io.k8s.api.coordination.v1.LeaseList
 io.k8s.api.core.v1.AttachedVolume
 io.k8s.api.core.v1.AWSElasticBlockStoreVolumeSource
 io.k8s.api.core.v1.AzureDiskVolumeSource
 io.k8s.api.core.v1.AzureFilePersistentVolumeSource
 io.k8s.api.core.v1.AzureFileVolumeSource
 io.k8s.api.core.v1.Binding
 io.k8s.api.core.v1.CephFSPersistentVolumeSource
 io.k8s.api.core.v1.CephFSVolumeSource
 io.k8s.api.core.v1.CinderPersistentVolumeSource
 io.k8s.api.core.v1.CinderVolumeSource
 io.k8s.api.core.v1.ComponentCondition
 io.k8s.api.core.v1.ComponentStatusList
 io.k8s.api.core.v1.ConfigMapKeySelector
 io.k8s.api.core.v1.ConfigMapList
 io.k8s.api.core.v1.ConfigMapNodeConfigSource
 io.k8s.api.core.v1.Container
 io.k8s.api.core.v1.ContainerImage
 io.k8s.api.core.v1.ContainerPort
 io.k8s.api.core.v1.ContainerStateTerminated
 io.k8s.api.core.v1.ContainerStatus
 io.k8s.api.core.v1.CSIPersistentVolumeSource
 io.k8s.api.core.v1.CSIVolumeSource
 io.k8s.api.core.v1.DaemonEndpoint
 io.k8s.api.core.v1.DownwardAPIVolumeFile
 io.k8s.api.core.v1.EndpointAddress
 io.k8s.api.core.v1.EndpointPort
 io.k8s.api.core.v1.EndpointsList
 io.k8s.api.core.v1.EnvVar
 io.k8s.api.core.v1.EphemeralContainer
 io.k8s.api.core.v1.Event
 io.k8s.api.core.v1.EventList
 io.k8s.api.core.v1.FlexPersistentVolumeSource
 io.k8s.api.core.v1.FlexVolumeSource
 io.k8s.api.core.v1.GCEPersistentDiskVolumeSource
 io.k8s.api.core.v1.GitRepoVolumeSource
 io.k8s.api.core.v1.GlusterfsPersistentVolumeSource
 io.k8s.api.core.v1.GlusterfsVolumeSource
 io.k8s.api.core.v1.HostPathVolumeSource
 io.k8s.api.core.v1.HTTPGetAction
 io.k8s.api.core.v1.HTTPHeader
 io.k8s.api.core.v1.ISCSIPersistentVolumeSource
 io.k8s.api.core.v1.ISCSIVolumeSource
 io.k8s.api.core.v1.KeyToPath
 io.k8s.api.core.v1.LimitRangeList
 io.k8s.api.core.v1.LimitRangeSpec
 io.k8s.api.core.v1.LocalVolumeSource
 io.k8s.api.core.v1.NamespaceList
 io.k8s.api.core.v1.NFSVolumeSource
 io.k8s.api.core.v1.NodeAddress
 io.k8s.api.core.v1.NodeCondition
 io.k8s.api.core.v1.NodeList
 io.k8s.api.core.v1.NodeSelector
 io.k8s.api.core.v1.NodeSelectorRequirement
 io.k8s.api.core.v1.NodeSystemInfo
 io.k8s.api.core.v1.ObjectFieldSelector
 io.k8s.api.core.v1.PersistentVolumeClaimCondition
 io.k8s.api.core.v1.PersistentVolumeClaimList
 io.k8s.api.core.v1.PersistentVolumeClaimVolumeSource
 io.k8s.api.core.v1.PersistentVolumeList
 io.k8s.api.core.v1.PhotonPersistentDiskVolumeSource
 io.k8s.api.core.v1.PodAffinityTerm
 io.k8s.api.core.v1.PodCondition
 io.k8s.api.core.v1.PodList
 io.k8s.api.core.v1.PodReadinessGate
 io.k8s.api.core.v1.PodSpec
 io.k8s.api.core.v1.PodTemplateList
 io.k8s.api.core.v1.PortworxVolumeSource
 io.k8s.api.core.v1.PreferredSchedulingTerm
 io.k8s.api.core.v1.ProjectedVolumeSource
 io.k8s.api.core.v1.QuobyteVolumeSource
 io.k8s.api.core.v1.RBDPersistentVolumeSource
 io.k8s.api.core.v1.RBDVolumeSource
 io.k8s.api.core.v1.ReplicationControllerCondition
 io.k8s.api.core.v1.ReplicationControllerList
 io.k8s.api.core.v1.ReplicationControllerStatus
 io.k8s.api.core.v1.ResourceFieldSelector
 io.k8s.api.core.v1.ResourceQuotaList
 io.k8s.api.core.v1.ScaleIOPersistentVolumeSource
 io.k8s.api.core.v1.ScaleIOVolumeSource
 io.k8s.api.core.v1.ScopedResourceSelectorRequirement
 io.k8s.api.core.v1.SecretKeySelector
 io.k8s.api.core.v1.SecretList
 io.k8s.api.core.v1.ServiceAccountList
 io.k8s.api.core.v1.ServiceAccountTokenProjection
 io.k8s.api.core.v1.ServiceList
 io.k8s.api.core.v1.ServicePort
 io.k8s.api.core.v1.Sysctl
 io.k8s.api.core.v1.Taint
 io.k8s.api.core.v1.TCPSocketAction
 io.k8s.api.core.v1.TopologySelectorLabelRequirement
 io.k8s.api.core.v1.TopologySpreadConstraint
 io.k8s.api.core.v1.TypedLocalObjectReference
 io.k8s.api.core.v1.Volume
 io.k8s.api.core.v1.VolumeDevice
 io.k8s.api.core.v1.VolumeMount
 io.k8s.api.core.v1.VsphereVirtualDiskVolumeSource
 io.k8s.api.core.v1.WeightedPodAffinityTerm
 io.k8s.apimachinery.pkg.apis.meta.v1.APIGroup
 io.k8s.apimachinery.pkg.apis.meta.v1.APIGroupList
 io.k8s.apimachinery.pkg.apis.meta.v1.APIResource
 io.k8s.apimachinery.pkg.apis.meta.v1.APIResourceList
 io.k8s.apimachinery.pkg.apis.meta.v1.APIVersions
 io.k8s.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery
 io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement
 io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference
 io.k8s.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR
 io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent
 io.k8s.apimachinery.pkg.runtime.RawExtension
 io.k8s.apimachinery.pkg.version.Info
 io.k8s.api.networking.v1.IPBlock
 io.k8s.api.networking.v1.NetworkPolicyList
 io.k8s.api.networking.v1.NetworkPolicySpec
 io.k8s.api.rbac.v1.ClusterRoleBinding
 io.k8s.api.rbac.v1.ClusterRoleBindingList
 io.k8s.api.rbac.v1.ClusterRoleList
 io.k8s.api.rbac.v1.PolicyRule
 io.k8s.api.rbac.v1.RoleBinding
 io.k8s.api.rbac.v1.RoleBindingList
 io.k8s.api.rbac.v1.RoleList
 io.k8s.api.rbac.v1.RoleRef
 io.k8s.api.rbac.v1.Subject
 io.k8s.api.scheduling.v1.PriorityClass
 io.k8s.api.scheduling.v1.PriorityClassList
 io.k8s.api.storage.v1.StorageClass
 io.k8s.api.storage.v1.StorageClassList
 io.k8s.api.storage.v1.VolumeAttachment
 io.k8s.api.storage.v1.VolumeAttachmentList
 io.k8s.api.storage.v1.VolumeAttachmentSpec
 io.k8s.api.storage.v1.VolumeAttachmentStatus
 io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceCondition
 io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceList
 io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceSpec
(175 rows)

#+end_src

** operations that have a resource like '%Pod%'... 

Note lack of PodSpec

#+BEGIN_SRC sql-mode
select distinct operation_id, resource from api_operations_parameters
where resource like '%Pod%'
and resource not like '%alpha%'
and resource not like '%beta%'
order by resource;
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
                        operation_id                         |                     resource                      
-------------------------------------------------------------+---------------------------------------------------
 createAutoscalingV1NamespacedHorizontalPodAutoscaler        | io.k8s.api.autoscaling.v1.HorizontalPodAutoscaler
 replaceAutoscalingV1NamespacedHorizontalPodAutoscaler       | io.k8s.api.autoscaling.v1.HorizontalPodAutoscaler
 replaceAutoscalingV1NamespacedHorizontalPodAutoscalerStatus | io.k8s.api.autoscaling.v1.HorizontalPodAutoscaler
 createCoreV1NamespacedPod                                   | io.k8s.api.core.v1.Pod
 replaceCoreV1NamespacedPod                                  | io.k8s.api.core.v1.Pod
 replaceCoreV1NamespacedPodStatus                            | io.k8s.api.core.v1.Pod
 createCoreV1NamespacedPodTemplate                           | io.k8s.api.core.v1.PodTemplate
 replaceCoreV1NamespacedPodTemplate                          | io.k8s.api.core.v1.PodTemplate
(8 rows)

#+end_src

** Nothing else uses PodSpec as a field !

#+BEGIN_SRC sql-mode
select distinct api_resource_name, resource_field as field, param_kind as kind, 0 as hits, 0 as test_hits, 0 as conformance_hits
from api_resources_fields
where param_kind like '%PodSpec%'
order by field; 
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
 api_resource_name | field | kind | hits | test_hits | conformance_hits 
-------------------+-------+------+------+-----------+------------------
(0 rows)

#+end_src
** What operations use it as a parameter?

#+BEGIN_SRC sql-mode
select distinct name from api_resources
where resource_type = 'object'
and name not like '%alpha%'
and name not like '%beta%'
order by name ;
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
                                  name                                  
------------------------------------------------------------------------
 io.k8s.api.admissionregistration.v1.MutatingWebhook
 io.k8s.api.admissionregistration.v1.MutatingWebhookConfigurationList
 io.k8s.api.admissionregistration.v1.ServiceReference
 io.k8s.api.admissionregistration.v1.ValidatingWebhook
 io.k8s.api.admissionregistration.v1.ValidatingWebhookConfigurationList
 io.k8s.api.apps.v1.ControllerRevision
 io.k8s.api.apps.v1.ControllerRevisionList
 io.k8s.api.apps.v1.DaemonSetCondition
 io.k8s.api.apps.v1.DaemonSetList
 io.k8s.api.apps.v1.DaemonSetSpec
 io.k8s.api.apps.v1.DaemonSetStatus
 io.k8s.api.apps.v1.DeploymentCondition
 io.k8s.api.apps.v1.DeploymentList
 io.k8s.api.apps.v1.DeploymentSpec
 io.k8s.api.apps.v1.ReplicaSetCondition
 io.k8s.api.apps.v1.ReplicaSetList
 io.k8s.api.apps.v1.ReplicaSetSpec
 io.k8s.api.apps.v1.ReplicaSetStatus
 io.k8s.api.apps.v1.StatefulSetCondition
 io.k8s.api.apps.v1.StatefulSetList
 io.k8s.api.apps.v1.StatefulSetSpec
 io.k8s.api.apps.v1.StatefulSetStatus
 io.k8s.api.authentication.v1.TokenRequest
 io.k8s.api.authentication.v1.TokenRequestSpec
 io.k8s.api.authentication.v1.TokenRequestStatus
 io.k8s.api.authentication.v1.TokenReview
 io.k8s.api.authorization.v1.LocalSubjectAccessReview
 io.k8s.api.authorization.v1.NonResourceRule
 io.k8s.api.authorization.v1.ResourceRule
 io.k8s.api.authorization.v1.SelfSubjectAccessReview
 io.k8s.api.authorization.v1.SelfSubjectRulesReview
 io.k8s.api.authorization.v1.SubjectAccessReview
 io.k8s.api.authorization.v1.SubjectAccessReviewStatus
 io.k8s.api.authorization.v1.SubjectRulesReviewStatus
 io.k8s.api.autoscaling.v1.CrossVersionObjectReference
 io.k8s.api.autoscaling.v1.HorizontalPodAutoscalerList
 io.k8s.api.autoscaling.v1.HorizontalPodAutoscalerSpec
 io.k8s.api.autoscaling.v1.HorizontalPodAutoscalerStatus
 io.k8s.api.autoscaling.v1.ScaleStatus
 io.k8s.api.batch.v1.JobCondition
 io.k8s.api.batch.v1.JobList
 io.k8s.api.batch.v1.JobSpec
 io.k8s.api.coordination.v1.LeaseList
 io.k8s.api.core.v1.AttachedVolume
 io.k8s.api.core.v1.AWSElasticBlockStoreVolumeSource
 io.k8s.api.core.v1.AzureDiskVolumeSource
 io.k8s.api.core.v1.AzureFilePersistentVolumeSource
 io.k8s.api.core.v1.AzureFileVolumeSource
 io.k8s.api.core.v1.Binding
 io.k8s.api.core.v1.CephFSPersistentVolumeSource
 io.k8s.api.core.v1.CephFSVolumeSource
 io.k8s.api.core.v1.CinderPersistentVolumeSource
 io.k8s.api.core.v1.CinderVolumeSource
 io.k8s.api.core.v1.ComponentCondition
 io.k8s.api.core.v1.ComponentStatusList
 io.k8s.api.core.v1.ConfigMapKeySelector
 io.k8s.api.core.v1.ConfigMapList
 io.k8s.api.core.v1.ConfigMapNodeConfigSource
 io.k8s.api.core.v1.Container
 io.k8s.api.core.v1.ContainerImage
 io.k8s.api.core.v1.ContainerPort
 io.k8s.api.core.v1.ContainerStateTerminated
 io.k8s.api.core.v1.ContainerStatus
 io.k8s.api.core.v1.CSIPersistentVolumeSource
 io.k8s.api.core.v1.CSIVolumeSource
 io.k8s.api.core.v1.DaemonEndpoint
 io.k8s.api.core.v1.DownwardAPIVolumeFile
 io.k8s.api.core.v1.EndpointAddress
 io.k8s.api.core.v1.EndpointPort
 io.k8s.api.core.v1.EndpointsList
 io.k8s.api.core.v1.EnvVar
 io.k8s.api.core.v1.EphemeralContainer
 io.k8s.api.core.v1.Event
 io.k8s.api.core.v1.EventList
 io.k8s.api.core.v1.FlexPersistentVolumeSource
 io.k8s.api.core.v1.FlexVolumeSource
 io.k8s.api.core.v1.GCEPersistentDiskVolumeSource
 io.k8s.api.core.v1.GitRepoVolumeSource
 io.k8s.api.core.v1.GlusterfsPersistentVolumeSource
 io.k8s.api.core.v1.GlusterfsVolumeSource
 io.k8s.api.core.v1.HostPathVolumeSource
 io.k8s.api.core.v1.HTTPGetAction
 io.k8s.api.core.v1.HTTPHeader
 io.k8s.api.core.v1.ISCSIPersistentVolumeSource
 io.k8s.api.core.v1.ISCSIVolumeSource
 io.k8s.api.core.v1.KeyToPath
 io.k8s.api.core.v1.LimitRangeList
 io.k8s.api.core.v1.LimitRangeSpec
 io.k8s.api.core.v1.LocalVolumeSource
 io.k8s.api.core.v1.NamespaceList
 io.k8s.api.core.v1.NFSVolumeSource
 io.k8s.api.core.v1.NodeAddress
 io.k8s.api.core.v1.NodeCondition
 io.k8s.api.core.v1.NodeList
 io.k8s.api.core.v1.NodeSelector
 io.k8s.api.core.v1.NodeSelectorRequirement
 io.k8s.api.core.v1.NodeSystemInfo
 io.k8s.api.core.v1.ObjectFieldSelector
 io.k8s.api.core.v1.PersistentVolumeClaimCondition
 io.k8s.api.core.v1.PersistentVolumeClaimList
 io.k8s.api.core.v1.PersistentVolumeClaimVolumeSource
 io.k8s.api.core.v1.PersistentVolumeList
 io.k8s.api.core.v1.PhotonPersistentDiskVolumeSource
 io.k8s.api.core.v1.PodAffinityTerm
 io.k8s.api.core.v1.PodCondition
 io.k8s.api.core.v1.PodList
 io.k8s.api.core.v1.PodReadinessGate
 io.k8s.api.core.v1.PodSpec
 io.k8s.api.core.v1.PodTemplateList
 io.k8s.api.core.v1.PortworxVolumeSource
 io.k8s.api.core.v1.PreferredSchedulingTerm
 io.k8s.api.core.v1.ProjectedVolumeSource
 io.k8s.api.core.v1.QuobyteVolumeSource
 io.k8s.api.core.v1.RBDPersistentVolumeSource
 io.k8s.api.core.v1.RBDVolumeSource
 io.k8s.api.core.v1.ReplicationControllerCondition
 io.k8s.api.core.v1.ReplicationControllerList
 io.k8s.api.core.v1.ReplicationControllerStatus
 io.k8s.api.core.v1.ResourceFieldSelector
 io.k8s.api.core.v1.ResourceQuotaList
 io.k8s.api.core.v1.ScaleIOPersistentVolumeSource
 io.k8s.api.core.v1.ScaleIOVolumeSource
 io.k8s.api.core.v1.ScopedResourceSelectorRequirement
 io.k8s.api.core.v1.SecretKeySelector
 io.k8s.api.core.v1.SecretList
 io.k8s.api.core.v1.ServiceAccountList
 io.k8s.api.core.v1.ServiceAccountTokenProjection
 io.k8s.api.core.v1.ServiceList
 io.k8s.api.core.v1.ServicePort
 io.k8s.api.core.v1.Sysctl
 io.k8s.api.core.v1.Taint
 io.k8s.api.core.v1.TCPSocketAction
 io.k8s.api.core.v1.TopologySelectorLabelRequirement
 io.k8s.api.core.v1.TopologySpreadConstraint
 io.k8s.api.core.v1.TypedLocalObjectReference
 io.k8s.api.core.v1.Volume
 io.k8s.api.core.v1.VolumeDevice
 io.k8s.api.core.v1.VolumeMount
 io.k8s.api.core.v1.VsphereVirtualDiskVolumeSource
 io.k8s.api.core.v1.WeightedPodAffinityTerm
 io.k8s.apimachinery.pkg.apis.meta.v1.APIGroup
 io.k8s.apimachinery.pkg.apis.meta.v1.APIGroupList
 io.k8s.apimachinery.pkg.apis.meta.v1.APIResource
 io.k8s.apimachinery.pkg.apis.meta.v1.APIResourceList
 io.k8s.apimachinery.pkg.apis.meta.v1.APIVersions
 io.k8s.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery
 io.k8s.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement
 io.k8s.apimachinery.pkg.apis.meta.v1.OwnerReference
 io.k8s.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR
 io.k8s.apimachinery.pkg.apis.meta.v1.WatchEvent
 io.k8s.apimachinery.pkg.runtime.RawExtension
 io.k8s.apimachinery.pkg.version.Info
 io.k8s.api.networking.v1.IPBlock
 io.k8s.api.networking.v1.NetworkPolicyList
 io.k8s.api.networking.v1.NetworkPolicySpec
 io.k8s.api.rbac.v1.ClusterRoleBinding
 io.k8s.api.rbac.v1.ClusterRoleBindingList
 io.k8s.api.rbac.v1.ClusterRoleList
 io.k8s.api.rbac.v1.PolicyRule
 io.k8s.api.rbac.v1.RoleBinding
 io.k8s.api.rbac.v1.RoleBindingList
 io.k8s.api.rbac.v1.RoleList
 io.k8s.api.rbac.v1.RoleRef
 io.k8s.api.rbac.v1.Subject
 io.k8s.api.scheduling.v1.PriorityClass
 io.k8s.api.scheduling.v1.PriorityClassList
 io.k8s.api.storage.v1.StorageClass
 io.k8s.api.storage.v1.StorageClassList
 io.k8s.api.storage.v1.VolumeAttachment
 io.k8s.api.storage.v1.VolumeAttachmentList
 io.k8s.api.storage.v1.VolumeAttachmentSpec
 io.k8s.api.storage.v1.VolumeAttachmentStatus
 io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceCondition
 io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceList
 io.k8s.kube-aggregator.pkg.apis.apiregistration.v1.APIServiceSpec
(175 rows)

#+end_src

