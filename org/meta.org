#+NAME: META
#+TODO: TODO(t) NEXT(n) IN-PROGRESS(i) BLOCKED(b) | TADA(d)

* Purpose
  This holds the authorative way to get setup and exploring with our hasura backend.
* Working with this repo/org file
** Work happens in Org first
   Within ii, our emphasis is on the documentation/org-file first.  
   We can document and craft the queries for our db, then tangle them into our migration files.
   as such: 
   *NOTE: Don't commit the hasura/migrations, they should be tangled from the org file.*
   In the future, we may add a commit hook that tangles org => hasura
* TODO Starting up your database
** listing tables
#+BEGIN_SRC sql-mode
\conninfo
\d+
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
You are connected to database "hh" as user "hh" on host "172.17.0.1" at port "5432".
SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
#+end_src

** dropping all data
#+NAME: do not run
#+BEGIN_SRC sql-mode :eval ask
  drop table raw_swaggers cascade;
  drop schema hdb_catalog cascade;
  drop schema hdb_views cascade;
#+END_SRC

#+RESULTS: do not run
#+begin_src sql-mode
ERROR:  "api_operations" is not a table
HINT:  Use DROP VIEW to remove a view.
ERROR:  table "audit_events" does not exist
NOTICE:  drop cascades to 7 other objects
DETAIL:  drop cascades to view api_operations
drop cascades to view operations_with_parameters
drop cascades to view orig_api_operations_parameters
drop cascades to view api_operations_responses
drop cascades to view api_operations_parameters
drop cascades to view api_resources
drop cascades to view api_resources_fields
DROP TABLE
#+end_src

** setting up the hasura postgresql-permissions
   
Run the following as the postgres user via psql:
https://docs.hasura.io/1.0/graphql/manual/deployment/postgres-permissions.html

#+NAME: emacs-user
#+BEGIN_SRC shell :results silent
echo -n $USER
#+END_SRC

#+NAME: create database and granting all privs to a user
#+BEGIN_SRC sql-mode :noweb yes :tangle ../hasura/db_setup.sql

create database <<emacs-user()>>;
-- create user myuser with encrypted password 'mypass';
grant all privileges on database <<emacs-user()>> to <<emacs-user()>>;
create role dba with superuser noinherit;
grant dba to <<emacs-user()>>;
\connect <<emacs-user()>>
-- we write python functions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS plpython3u;
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE SCHEMA IF NOT EXISTS hdb_catalog;
CREATE SCHEMA IF NOT EXISTS hdb_views;
-- make the user an owner of system schemas
ALTER SCHEMA hdb_catalog OWNER TO <<emacs-user()>>;
ALTER SCHEMA hdb_views OWNER TO <<emacs-user()>>;
GRANT SELECT ON ALL TABLES IN SCHEMA information_schema TO <<emacs-user()>>;
GRANT SELECT ON ALL TABLES IN SCHEMA pg_catalog TO <<emacs-user()>>;
GRANT USAGE ON SCHEMA public TO <<emacs-user()>>;
GRANT ALL ON ALL TABLES IN SCHEMA public TO <<emacs-user()>>;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO <<emacs-user()>>;
GRANT pg_execute_server_program TO <<emacs-user()>>;
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
ERROR:  must have admin option on role "pg_execute_server_program"
#+end_src

#+NAME: as posgres admin, setup hasura user and db
#+BEGIN_SRC shell  :var SUDO_ASKPASS="/usr/bin/ssh-askpass" :prologue "export SUDO_ASKPASS"
# :var DISPLAY=":0.0"
sudo su - postgres -c psql < ~/ii/apisnoop_v3/hasura/db_setup.sql
#+END_SRC

#+RESULTS: as posgres admin, setup hasura user and db
#+begin_EXAMPLE
GRANT
GRANT ROLE
You are now connected to database "hh" as user "postgres".
CREATE EXTENSION
CREATE EXTENSION
CREATE EXTENSION
CREATE SCHEMA
CREATE SCHEMA
ALTER SCHEMA
ALTER SCHEMA
GRANT
GRANT
GRANT
GRANT
GRANT
GRANT ROLE
#+end_EXAMPLE

* TADA make sure hasura has public endpoint
file:hasura.org
** docker-compose.yml
#+BEGIN_SRC yaml :tangle hasura/docker-compose.yaml
  # hasura/docker-compose.yaml
  version: "3.7"

  services:
   hasura:
      #image: hasura/graphql-engine:v1.0.0-beta.3
      # append '.cli-migrations' to auto run 'hasura migrations apply'
      container_name: "${USER}-hasura"
      image: hasura/graphql-engine:v1.0.0-beta.4.cli-migrations
      restart: always
      networks:
        - web
      environment:
        # Should try and set database be read only for public
        #- HASURA_GRAPHQL_DATABASE_URL=postgres://non-priv-user@172.17.0.1:5432/database-name
        #- HASURA_GRAPHQL_DATABASE_URL=postgres://non-priv-user@172.17.0.1:5432/$OUTER-USER
        # https://docs.docker.com/compose/compose-file/#variable-substitution
        # https://docs.docker.com/compose/env-file/
        - "HASURA_GRAPHQL_DATABASE_URL=postgres://${USER}@172.17.0.1:5432/${USER}"
        - HASURA_GRAPHQL_ENABLE_CONSOLE=true
      volumes:
        - ./migrations:/hasura-migrations
      expose:
        - "8080"
      labels:
        - "traefik.docker.network=web"
        - "traefik.enable=true"
        - "traefik.basic.port=8080"
        - "traefik.basic.protocol=http"
        - "traefik.basic.frontend.rule=Host:${USER}-hasura.sharing.io"
  #volumes:
  #  migrations:
  networks:
    web:
      external: true
#+END_SRC

** start hasura

#+BEGIN_SRC shell :dir hasura
docker-compose up -d
#+END_SRC

#+RESULTS:
#+begin_EXAMPLE
#+end_EXAMPLE
** Watch hasura logs

#+BEGIN_SRC emacs-lisp
    (defun hasura-logs ()
      (interactive)
      (setq *hasura-buffer*
            (get-buffer-create "hasura-logs"))
      (with-current-buffer *hasura-buffer*
        (ansi-color-for-comint-mode-on)
        (comint-mode)
        (spacemacs/toggle-line-numbers-on)
       ;; (linum-mode t)
        )
      (let ((default-directory (file-name-directory (concat (file-name-directory buffer-file-name) "../hasura/")))
            (logs-command "docker-compose logs -f --no-color")
            ;; (logs-command "tail -f /var/log/messages")
            ;;(logs-command "docker-compose logs -f --no-color 2>/dev/null | sed 's:hasura_1  | ::g' | grep '^{' | jq .")
            )
        (setq *hasura-process*
              (start-file-process-shell-command
               "hasura" *hasura-buffer* logs-command))
        (set-process-filter *hasura-process* 'comint-output-filter)
  )
      )
    (hasura-logs)
    ;; "docker-compose logs -f| jq .")
#+END_SRC

#+RESULTS:
#+begin_src emacs-lisp
comint-output-filter
#+end_src

** TODO secure hasura with simple auth
* Create Tables and Load Data
** swagger.json

#+NAME: raw_swaggers
#+BEGIN_SRC sql-mode :tangle ../hasura/migrations/100_table_raw_swaggers.up.sql
CREATE TABLE raw_swaggers (
    id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ingested_at timestamp DEFAULT CURRENT_TIMESTAMP,
    -- version text NOT NULL,
    -- definition_id text NOT NULL,
    data jsonb NOT NULL
);
#+END_SRC

#+RESULTS: raw_swaggers
#+begin_src sql-mode
ERROR:  relation "raw_swaggers" already exists
#+end_src

#+NAME: track raw_swaggers
#+BEGIN_SRC yaml :tangle ../hasura/migrations/100_table_raw_swaggers.up.yaml
- type: track_table
  args:
    schema: public
    name: raw_swaggers
#+END_SRC

** load swagger via curl

#+NAME: load_swagger_via_curl.py
#+BEGIN_SRC python :eval never
  # should probably sanitize branch_or_tag
  try:
      from string import Template
      sql = Template("copy raw_swaggers (data) FROM PROGRAM '$curl' (DELIMITER e'\x02', FORMAT 'csv', QUOTE e'\x01');").substitute(
          curl =  f'curl https://raw.githubusercontent.com/kubernetes/kubernetes/{branch_or_tag}/api/openapi-spec/swagger.json | jq -c .'
      )
      rv = plpy.execute(sql)
      return "it worked"
  except:
      return "something went wrong"
#+END_SRC

#+NAME: load_swagger_via_curl.sql
#+BEGIN_SRC sql-mode :noweb yes :tangle ../hasura/migrations/120_function_load_swagger_via_curl.up.sql
  set role dba;
  CREATE OR REPLACE FUNCTION load_swagger_via_curl(branch_or_tag text)
  RETURNS text AS $$
  <<load_swagger_via_curl.py>>
  $$ LANGUAGE plpython3u ;
  reset role;
#+END_SRC

#+RESULTS: load_swagger_via_curl.sql
#+begin_src sql-mode
SET
hh$# hh$# hh$# hh$# hh$# hh$# hh$# hh$# hh$# hh$# hh$# CREATE FUNCTION
RESET
#+end_src

#+BEGIN_SRC sql-mode :noweb yes :tangle ../hasura/migrations/130_populate_swaggers.up.sql
  delete from raw_swaggers;
  select * from load_swagger_via_curl('master');
  -- select * from load_swagger_via_curl('release-1.15');
  -- select * from load_swagger_via_curl('release-1.14');
  -- select * from load_swagger_via_curl('release-1.13');
  -- select * from load_swagger_via_curl('release-1.12');
  -- select * from load_swagger_via_curl('release-1.11');
  -- select * from load_swagger_via_curl('release-1.10');
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
DELETE 1
#+end_src

#+BEGIN_SRC sql-mode
  select count(*) from raw_swaggers;
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
 count 
-------
     1
(1 row)

#+end_src

#+BEGIN_SRC sql-mode
\dt+
#+END_SRC

#+RESULTS:
#+begin_src sql-mode
                      List of relations
 Schema |     Name     | Type  | Owner | Size  | Description 
--------+--------------+-------+-------+-------+-------------
 public | raw_swaggers | table | zz    | 13 MB | 
(1 row)

#+end_src

* Load Operation Views
** api_operations view
*** regex_from_path function
#+NAME: regex_from_path.py
#+BEGIN_SRC python :eval never
  import re
  if path is None:
    return None
  K8S_PATH_VARIABLE_PATTERN = re.compile("{(path)}$")
  VARIABLE_PATTERN = re.compile("{([^}]+)}")
  path_regex = K8S_PATH_VARIABLE_PATTERN.sub("(.*)", path).rstrip('/')
  path_regex = VARIABLE_PATTERN.sub("([^/]*)", path_regex).rstrip('/')
  if not path_regex.endswith(")") and not path_regex.endswith("?"): 
      path_regex += "([^/]*)"
  if path_regex.endswith("proxy"): 
      path_regex += "/?$"
  else:
      path_regex += "$"
  return path_regex
#+END_SRC

#+NAME: regex_from_path.sql
#+BEGIN_SRC sql-mode :noweb yes :tangle ../hasura/migrations/145_function_regex_from_path.up.sql
  set role dba;
  CREATE OR REPLACE FUNCTION regex_from_path(path text)
  RETURNS text AS $$
  <<regex_from_path.py>>
  $$ LANGUAGE plpython3u ;
  reset role;
#+END_SRC

*** api_operations view
#+NAME: api_operations view
#+BEGIN_SRC sql-mode :eval never-export :tangle ../hasura/migrations/150_view_api_operations.up.sql
  CREATE OR REPLACE VIEW "public"."api_operations" AS 
    SELECT raw_swaggers.id AS raw_swagger_id,
           paths.key AS path,
           regex_from_path(paths.key) as regex,
           d.key AS method,
           (d.value ->> 'operationId'::text) AS operation_id,
           ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'group'::text) AS k8s_group,
           ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'version'::text) AS k8s_version,
           ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'kind'::text) AS k8s_kind,
           (d.value ->> 'description'::text) AS description,
           (d.value ->> 'x-kubernetes-action'::text) AS x_kubernetes_action,
           (d.value -> 'consumes'::text) AS consumes,
           (d.value -> 'responses'::text) AS responses,
           (d.value -> 'parameters'::text) AS parameters,
           (lower((d.value ->> 'description'::text)) ~~ '%deprecated%'::text) AS deprecated,
           split_part((cat_tag.value ->> 0), '_'::text, 1) AS category,
           string_agg(btrim((jsonstring.value)::text, '"'::text), ', '::text) AS tags,
           string_agg(btrim((schemestring.value)::text, '"'::text), ', '::text) AS schemes
      FROM raw_swaggers
      , jsonb_each((raw_swaggers.data -> 'paths'::text)) paths(key, value)
      , jsonb_each(paths.value) d(key, value)
      , jsonb_array_elements((d.value -> 'tags'::text)) cat_tag(value)
      , jsonb_array_elements((d.value -> 'tags'::text)) jsonstring(value)
      , jsonb_array_elements((d.value -> 'schemes'::text)) schemestring(value)
     GROUP BY raw_swaggers.id, paths.key, d.key, d.value, cat_tag.value
     ORDER BY paths.key;
#+END_SRC

#+RESULTS: api_operations view
#+begin_src sql-mode
CREATE VIEW
#+end_src

#+NAME: track api_operations
#+BEGIN_SRC yaml :tangle ../hasura/migrations/150_view_api_operations.up.yaml
- type: track_table
  args:
    schema: public
    name: api_operations
#+END_SRC


#+NAME: possible indexes
#+BEGIN_SRC sql-mode :eval never
create index api_operations_id on api_operations(id);
create index api_operations_method on api_operations(method);
create index api_operations_regexp on api_operations(regexp);
#+END_SRC

** api_operations_parameters view
   This only gives us 17 distinct parameters, but 4k rows.  It looks like the same parameters are used again and again across the operation_ids.  
   All of them have a description except for the param 'body in body'.  Need to look further into what that param looks like
#+NAME: api_operations_parameters view
#+BEGIN_SRC sql-mode :eval no-export :tangle ../hasura/migrations/160_view_api_operations_parameters.up.sql
  CREATE OR REPLACE VIEW "public"."api_operations_parameters" AS 
    SELECT (param.entry ->> 'name'::text) AS name,
           (param.entry ->> 'in'::text) AS "in",
           replace(
             CASE
             WHEN ((param.entry ->> 'in'::text) = 'body'::text) 
              AND ((param.entry -> 'schema'::text) is not null)
               THEN ((param.entry -> 'schema'::text) ->> '$ref'::text)
             ELSE (param.entry ->> 'type'::text)
             END, '#/definitions/','') AS resource,
           (param.entry ->> 'description'::text) AS description,
           CASE
           WHEN ((param.entry ->> 'required'::text) = 'true') THEN true
           ELSE false
            END AS required,
           CASE
           WHEN ((param.entry ->> 'uniqueItems'::text) = 'true') THEN true
           ELSE false
           END AS unique_items,
           api_operations.raw_swagger_id,
           param.entry as entry
      FROM api_operations
           , jsonb_array_elements(api_operations.parameters) WITH ORDINALITY param(entry, index)
            WHERE api_operations.parameters IS NOT NULL;
#+END_SRC

#+RESULTS: api_operations_parameters view
#+begin_src sql-mode
CREATE VIEW
#+end_src

#+NAME: track api_operations_parameters
#+BEGIN_SRC yaml :eval no-export :tangle ../hasura/migrations/160_view_api_operations_parameters.up.yaml
- type: track_table
  args:
    schema: public
    name: api_operations_parameters
#+END_SRC

** api_operations_responses view
#+NAME: Responses View
#+BEGIN_SRC sql-mode :eval no-export :tangle ../hasura/migrations/180_view_api_operations_responses.up.sql
  CREATE OR REPLACE VIEW "public"."api_operations_responses" AS 
    SELECT d.key AS code,
           (d.value ->> 'description'::text) AS description,
           replace(
             CASE
             WHEN (((d.value -> 'schema'::text) IS NOT NULL) AND (((d.value -> 'schema'::text) -> 'type'::text) IS NOT NULL))
               THEN ((d.value -> 'schema'::text) ->> 'type'::text)
             WHEN (((d.value -> 'schema'::text) IS NOT NULL) AND (((d.value -> 'schema'::text) -> '$ref'::text) IS NOT NULL))
               THEN ((d.value -> 'schema'::text) ->> '$ref'::text)
             ELSE NULL::text
             END, '#/definitions/','') AS resource
      FROM (api_operations
            JOIN LATERAL jsonb_each(api_operations.responses) d(key, value) ON (true))
     ORDER BY (uuid_generate_v1());
#+END_SRC
#+NAME: track api_operations_responses
#+BEGIN_SRC yaml :tangle ../hasura/migrations/180_view_api_operations_responses.up.yaml
- type: track_table
  args:
    schema: public
    name: api_operations_responses
#+END_SRC

* Load Resource Views
** api_resources view
#+NAME: api_resources view
#+BEGIN_SRC sql-mode :eval never-export :tangle ../hasura/migrations/190_view_api_resources.up.sql
-- drop materialized view api_resources CASCADE;
-- CREATE MATERIALIZED VIEW "public"."api_resources" AS 
CREATE VIEW "public"."api_resources" AS 
 SELECT 
    uuid_generate_v1() AS id,
    raw_swaggers.id AS raw_swagger_id,
    d.key AS name,
    (d.value ->> 'type'::text) AS resource_type,
    (((d.value -> 'x-kubernetes-group-version-kind'::text) -> 0) ->> 'group'::text) AS k8s_group,
    (((d.value -> 'x-kubernetes-group-version-kind'::text) -> 0) ->> 'version'::text) AS k8s_version,
    (((d.value -> 'x-kubernetes-group-version-kind'::text) -> 0) ->> 'kind'::text) AS k8s_kind,
    ( SELECT string_agg(btrim((jsonstring.value)::text, '"'::text), ', '::text) AS string_agg
          FROM jsonb_array_elements((d.value -> 'required'::text)) jsonstring(value)) AS required_params,
    (d.value ->> 'required'::text) as required_params_text,
    (d.value -> 'properties'::text) AS properties,
    -- (raw_api_definitions.data ->> 'version'::text) AS source
    d.value
   FROM (raw_swaggers
     JOIN LATERAL jsonb_each((raw_swaggers.data -> 'definitions'::text)) d(key, value) ON (true))
  ORDER BY id;
#+END_SRC
#+NAME: track api_resources
#+BEGIN_SRC yaml :tangle ../hasura/migrations/190_view_api_resources.up.yaml
- type: track_table
  args:
    schema: public
    name: api_resources
#+END_SRC

** api_resources_fields view
#+NAME: Properties View
#+BEGIN_SRC sql-mode :eval never-export :tangle ../hasura/migrations/200_view_api_resources_fields.up.sql
  -- DROP VIEW api_resources_properties;
  -- DROP MATERIALIZED VIEW api_resources_properties;
  CREATE VIEW "public"."api_resources_fields" AS 
    SELECT api_resources.id AS type_id,
           d.key AS property,
           CASE
           WHEN ((d.value ->> 'type'::text) IS NULL) THEN 'subtype'::text
           ELSE (d.value ->> 'type'::text)
             END AS param_type,
           replace(
             CASE
             WHEN ((d.value ->> 'type'::text) = 'string'::text) THEN 'string'::text
             WHEN ((d.value ->> 'type'::text) IS NULL) THEN (d.value ->> '$ref'::text)
             WHEN ((d.value ->> 'type'::text) = 'array'::text)
              AND ((d.value -> 'items'::text) ->> 'type'::text) IS NULL
               THEN ((d.value -> 'items'::text) ->> '$ref'::text)
             WHEN ((d.value ->> 'type'::text) = 'array'::text)
              AND ((d.value -> 'items'::text) ->> '$ref'::text) IS NULL
               THEN ((d.value -> 'items'::text) ->> 'type'::text)
             ELSE 'integer'::text
             END, '#/definitions/','') AS param_kind,
           (d.value ->> 'description'::text) AS description,
           (d.value ->> 'format'::text) AS format,
           (d.value ->> 'x-kubernetes-patch-merge-key'::text) AS merge_key,
           (d.value ->> 'x-kubernetes-patch-strategy'::text) AS patch_strategy,
           -- CASE
           --   WHEN d.key is null THEN false
           --   WHEN (api_resources.required_params ? d.key) THEN true
           --   ELSE false
           --     END
           --   AS required,
           -- with param type also containing array, we don't need array as a boolean
           -- CASE
           -- WHEN ((d.value ->> 'type'::text) = 'array'::text) THEN true
           -- ELSE false
           --  END AS "array"
           d.value
      FROM (api_resources
            JOIN LATERAL jsonb_each(api_resources.properties) d(key, value) ON (true))
     ORDER BY api_resources.id;
#+END_SRC
#+NAME: track api_resources_fields
#+BEGIN_SRC yaml :tangle ../hasura/migrations/200_view_api_resources_fields.up.yaml
- type: track_table
  args:
    schema: public
    name: api_resources_fields
#+END_SRC

* Create Over View
#+NAME: over view
#+BEGIN_SRC sql-mode :eval never-export :notangle ../hasura/migrations/210_view_over.up.sql
  CREATE OR REPLACE VIEW "public"."over" AS
   SELECT
      o.operation_id,
      op.name as opname,
      op.required,
      op.description as opdescription
      -- r.name as rname,
      -- r.k8s_group,
      -- r.k8s_version,
      -- r.k8s_kind,
      -- rf.property,
      -- rf.param_type,
      -- rf.param_kind,
      -- rf.description,
      -- rf.format,
      -- rf.merge_key,
      -- rf.patch_strategy
     FROM 
       api_operations o
       , INNER JOIN api_operations_parameters USING (raw_swagger_id) op
     --   api_operations_responses resp,
     --   api_resources r,
     --   api_resources_fields rf
     -- WHERE rs.id = o.raw_swagger_id
     --   AND rs.id = r.raw_swagger_id
     --   AND o.id = op.api_operations_id
     --   AND r.id = rf.type_id
       -- AND rs.id = 1
    ORDER BY o.operation_id;
#+END_SRC

#+RESULTS: over view
#+begin_src sql-mode
ERROR:  syntax error at or near "JOIN"
LINE 20:      NATURAL JOIN api_operations_parameters ON (raw_swagger_...
                      ^
#+end_src
#+NAME: track over
#+BEGIN_SRC yaml :notangle ../hasura/migrations/210_view_over.up.yaml
- type: track_table
  args:
    schema: public
    name: over
#+END_SRC

#+BEGIN_SRC sql-mode
select count(*) from "over";

#+END_SRC

#+RESULTS:
#+begin_src sql-mode
 count 
-------
     0
(1 row)

#+end_src

* IN-PROGRESS Remove interim 'operations with parameters' view
* NEXT Finish the Over View
* TODO Create Import for CSV view
  We have a file started here: [[file:test_gen.org][test_gen.org]] 
  that brings in the work devan and caleb did to pull all the tests used in a specific/commit version of k8s.
  If we can build a script for this, then we can have:
  - A test name
  - its description
  - its link to official k8s definition
  - a link to the lines of go code that define it.
  
    We can then use this as a cross refernece for any audit event that references a test.
* TODO Creating/Editing Views
* FOOTNOTES
# Local Variables:
# eval: (sql-connect "hasura" (concat "*SQL: postgres:data*"))
# End:
  
  

  
