#+TITLE: Auditlogger Code, Deployment, and Reference Materials
#+TODO: TODO(t) IN-PROGRESS(i) WAITING(w) | DONE(d)
#+PROPERTY: header-args :comments none 
#+

* Introduction 
  Logs all events in a kubernetes cluster and inserts it into the apisnoop DB.  Useful for running mock-test code and making sure this test hits the endpoints you intend.
* App
** Configuration

Here are some environment variables to configure auditlogger

| Name                     | Purpose                                                                     | Default                                                             |
|--------------------------+-----------------------------------------------------------------------------+---------------------------------------------------------------------|
| APP_DB_CONNECTION_STRING | Connection string to talk to the APIsnoop Postgres database                 | ~postgres://apisnoop:s3cretsauc3@postgres/apisnoop?sslmode=disable~ |
| APP_DB_AUDIT_EVENT_TABLE | The table inside the APIsnoop postgres database to insert the audit data to | ~audit_event~                                                       |
| APP_PORT                 | The HTTP port to serve the auditlogger API on                               | ~9900~                                                              |
| APP_DISABLE_LOGS         | Toggle false to disable logs for the HTTP traffic and incoming data         | ~false~                                                            |

** javascript code
#+NAME: auditlogger bot (nodejs)
#+begin_src js :tangle ./app/auditlogger.js :results silent
  const connectionString = typeof process.env.APP_DB_CONNECTION_STRING !== 'undefined' ? process.env.APP_DB_CONNECTION_STRING : 'postgres://apisnoop:s3cretsauc3@postgres/apisnoop?sslmode=disable'
  const auditTableName = typeof process.env.APP_DB_AUDIT_EVENT_TABLE !== 'undefined' ? process.env.APP_DB_AUDIT_EVENT_TABLE : 'audit_event'
  const appPort = typeof process.env.APP_PORT !== 'undefined' ? process.env.APP_PORT : '9900'
  const appDisableLogs = typeof process.env.APP_DISABLE_LOGS !== 'undefined' ? process.env.APP_DISABLE_LOGS : 'false'
  const express = require('express')
  const app = express()
  const bodyParser = require('body-parser')
  const morgan = require('morgan')
  const knex = require('knex')({
      client: 'pg',
      connection: connectionString
  })

  var postgresIsReady = false

  console.log(`[status] using connection string: ${connectionString}`)

  function logs(...messages) {
      if (appDisableLogs == 'true') {
          return
      }
      console.log(...messages)
  }

  function hello (req, res, next) {
      const helloMsg = 'Hey! I\'m your friendly neighbourhood auditlogger. Note: the endpoint /events is where logging takes place.'
      res.json({ message: helloMsg })
      return res.end()
  }

  function requestFailure (req, res, next, message) {
      res.status(400)
      res.json({ message })
      return res.end()
  }

  function checkForBodyContent (req, res, next) {
      if (Object.keys(req.body).length === 0 || typeof req.body !== 'object') {
          console.log('[error] request contains no body')
          return requestFailure(req, res, next, 'request must contain a body')
      }
      return next()
  }

  function checkUserAgent (req, res, next) {
      const requestContent = req.body
      if (req.headers['user-agent'] !== 'kube-apiserver-admission') {
          console.log('[error] request didn\'t come from kube-apiserver')
          return requestFailure(req, res, next, 'Error: request must come from Kubernetes apiserver')
      }
      return next()
  }

  function postgresReadyCheck (req, res, next) {
      if (postgresIsReady === true) {
          return next()
      }
      knex.raw(`SELECT to_regclass('${auditTableName}');`).then(resp => {
          postgresIsReady = resp.rows[0].to_regclass !== null
      })
  }

  function logEventsToDB (req, res, next) {
      const requestContent = req.body
      const items = requestContent.items[0]
      logs(JSON.stringify(requestContent, null, 2))

      // set each relevant part of data load to a variable, for easier insertion statement into db below
      const {
          auditID,
          stage,
          verb,
          requestURI,
          level,
          apiVersion,
          userAgent,
          user,
          objectRef,
          sourceIPs,
          annotations,
          requestObject,
          responseObject,
          responseStatus,
          stageTimestamp,
          requestReceivedTimestamp
      } = items;

      // regex for useragent, to determine if a test or conformance test hit
      const STARTS_WITH_E2E = new RegExp('^e2e.test')
      const HAS_CONF_IN_BRACKETS = new RegExp('\\[Conformance\\]')

      logs('[status] inserting into database')
      let dataToInsert = {
          bucket: 'apisnoop',
          job: 'live',
          audit_id: auditID,
          stage,
          event_verb: verb,
          request_uri: requestURI,
          event_level: level,
          api_version: apiVersion,
          useragent: userAgent,
          test_hit: STARTS_WITH_E2E.test(userAgent),
          conf_test_hit: HAS_CONF_IN_BRACKETS.test(userAgent),
          event_user: user,
          object_namespace: objectRef ? objectRef.namespace : null,
          object_type: objectRef ? objectRef.resource : null,
          object_group: objectRef ? objectRef.apiGroup : null,
          object_ver: objectRef ? objectRef.apiVersion : null,
          source_ips: JSON.stringify(sourceIPs),
          annotations: JSON.stringify(annotations),
          request_object: JSON.stringify(requestObject),
          response_object: JSON.stringify(responseObject),
          response_status: JSON.stringify(responseStatus),
          stage_timestamp: stageTimestamp,
          request_received_timestamp: requestReceivedTimestamp,
          data: JSON.stringify(items)
      }
      logs(dataToInsert)

      knex.transaction((trx) => {
          knex(`${auditTableName}`).transacting(trx).insert(dataToInsert)
              .then(trx.commit)
              .catch(trx.rollback)
      }).then(resp => {
          logs('[status] successfully submitted entry')
          res.json({ message: 'operation complete; data inserted' })
          return res.end()
      }).catch(err => {
          console.log(`[error] database: ${err}`)
          requestFailure(req, res, next, `[error] database: ${err}`)
      })
  }

  console.log('[status] starting apisnoop-auditlog-event-handler')

  app.use(bodyParser.json({
    extended: true,
    limit: '100mb'
  }))
  app.use(express.json())
  app.use(morgan('combined'))

  app.get('/', hello)
  app.post('/events', [checkForBodyContent, postgresReadyCheck], logEventsToDB)

  knex.raw('select 0;').then(() => {
      console.log('[status] connected to database')
      app.listen(appPort, () => {
          console.log(`[status] started; listening on port ${appPort}`)
      })
  }).catch(err => {
      console.log('[error] No database connection found.')
      console.log(err)
      process.exit(1)
  })
#+end_src


#+NAME: auditlogger bot (nodejs) package
#+begin_src json :tangle ./app/package.json :comments no :results silent
{
  "name": "apisnoop-auditlogger",
  "version": "0.0.2",
  "description": "AuditLogger for apisnoop",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Caleb Woodbine <caleb@ii.coop>",
  "license": "Apache-2.0",
  "dependencies": {
    "express": "^4.17.1",
    "knex": "^0.20.1",
    "morgan": "^1.9.1",
    "pg": "^7.12.1"
  }
}
#+end_src

** Dockerfile
 #+NAME: dockerfile for auditlogger bot
 #+begin_src dockerfile :tangle ./app/Dockerfile
   FROM node:12.14.1-alpine3.11
   RUN apk update && \
   apk add vim postgresql-client netcat-openbsd
   RUN adduser -D -H -h /opt/apisnoop apisnoop
   WORKDIR /opt/apisnoop
   COPY auditlogger.js .
   COPY package.json .
   RUN npm i
   EXPOSE 9900
   USER apisnoop
   CMD ["node", "auditlogger.js"]
 #+end_src

** cloudbuild
  #+NAME: auditlogger cloudbuild 
#+begin_src yaml :tangle ./app/cloudbuild.yaml :comments no :results silent
    steps:
      - name: gcr.io/cloud-builders/docker
        args: ['build', '-t', 'gcr.io/$PROJECT_ID/auditlogger:$_GIT_TAG',
              '--build-arg', 'IMAGE_ARG=gcr.io/$PROJECT_ID/auditlogger:$_GIT_TAG',
              '.']
    substitutions:
      _GIT_TAG: '12345'
    images:
      - 'gcr.io/$PROJECT_ID/auditlogger:$_GIT_TAG'
    options:
      substitution_option: 'ALLOW_LOOSE'
#+end_src

** Build the container image
Build the container image:
#+BEGIN_SRC shell :async yes
  eval $(minikube -p minikube docker-env)
  TAG="$(date +%Y.%m.%d)"
  docker build -t raiinbow/auditlogger:"$TAG" app
#+END_SRC

#+RESULTS:
#+begin_example
Sending build context to Docker daemon  10.24kB
Step 1/10 : FROM node:12.14.1-alpine3.11
 ---> b0dc3a5e5e9e
Step 2/10 : RUN apk update && apk add vim postgresql-client netcat-openbsd
 ---> Using cache
 ---> 88b236f5ee71
Step 3/10 : RUN adduser -D -H -h /opt/apisnoop apisnoop
 ---> Using cache
 ---> 3beaabc8564a
Step 4/10 : WORKDIR /opt/apisnoop
 ---> Using cache
 ---> b678977c8e32
Step 5/10 : COPY auditlogger.js .
 ---> 4d85977cdfcd
Step 6/10 : COPY package.json .
 ---> 2f97d7f71b69
Step 7/10 : RUN npm i
 ---> Running in 891a76f6b7da
[91mnpm[0m[91m WARN deprecated[0m[91m urix@0.1.0: Please see https://github.com/lydell/urix#deprecated
[0m[91mnpm[0m[91m [0m[91mWARN[0m[91m [0m[91mdeprecated[0m[91m resolve-url@0.2.1: https://github.com/lydell/resolve-url#deprecated
[0m[91mnpm [0m[91mnotice created a lockfile as package-lock.json. You should commit this file.
[0m[91mnpm[0m[91m WARN[0m[91m apisnoop-auditlogger@0.0.2 No repository field.
[0m[91m
[0madded 227 packages from 171 contributors and audited 227 packages in 8.106s

1 package is looking for funding
  run `npm fund` for details

found 0 vulnerabilities

Removing intermediate container 891a76f6b7da
 ---> 5933290a61cc
Step 8/10 : EXPOSE 9900
 ---> Running in c029aea09dd8
Removing intermediate container c029aea09dd8
 ---> 1ebfa5c941f6
Step 9/10 : USER apisnoop
 ---> Running in e1098f1e9fde
Removing intermediate container e1098f1e9fde
 ---> a2e803e02073
Step 10/10 : CMD ["node", "auditlogger.js"]
 ---> Running in c882abdf7ea9
Removing intermediate container c882abdf7ea9
 ---> 7dcfaffdb13d
Successfully built 7dcfaffdb13d
Successfully tagged raiinbow/auditlogger:2020.08.19
#+end_example

Push the image:
#+BEGIN_SRC shell :async yes
  eval $(minikube -p minikube docker-env)
  TAG="$(date +%Y.%m.%d)"
  docker push raiinbow/auditlogger:"$TAG"
#+END_SRC

#+RESULTS:
#+begin_example
The push refers to repository [docker.io/raiinbow/auditlogger]
a055aa55ad02: Preparing
897e974b7299: Preparing
16906a9dc4d2: Preparing
53f117658a32: Preparing
3b9238999319: Preparing
1b3c39a9a303: Preparing
5280d2327565: Preparing
77d806cfa004: Preparing
930c8bc01816: Preparing
5216338b40a7: Preparing
1b3c39a9a303: Waiting
5280d2327565: Waiting
5216338b40a7: Waiting
77d806cfa004: Waiting
930c8bc01816: Waiting
3b9238999319: Layer already exists
53f117658a32: Layer already exists
5280d2327565: Layer already exists
1b3c39a9a303: Layer already exists
77d806cfa004: Layer already exists
930c8bc01816: Layer already exists
5216338b40a7: Layer already exists
16906a9dc4d2: Pushed
897e974b7299: Pushed
a055aa55ad02: Pushed
2020.08.19: digest: sha256:c01b7e5e35086e70f1a734d09fc7b4710ebbdc8c424aeaf6a7f057ca26a7ba7d size: 2411
#+end_example

* Deployment
** deployment
#+NAME: deployment.yaml   
#+begin_src yaml :tangle ./deployment/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: apisnoop-auditlogger
spec:
  replicas: 1
  selector:
    matchLabels:
      io.apisnoop.auditlogger: apisnoop-auditlogger
  template:
    metadata:
      labels:
        io.apisnoop.auditlogger: apisnoop-auditlogger
    spec:
      containers:
        - name: apisnoop-auditlogger
          image: "raiinbow/auditlogger:v20200211-0.9.34-1-g24cf96f"
          #command:
          #  - "sleep"
          #args: 
          #  - "10000000"
          ports:
            - containerPort: 9900
#+end_src

** kustomization
#+NAME: kustomization.yaml   
#+begin_src yaml :tangle ./deployment/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
  - deployment.yaml
  - service.yaml
#+end_src

** service
#+NAME: service.yaml   
#+begin_src yaml :tangle ./deployment/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: apisnoop-auditlogger
spec:
  ports:
    - port: 9900
      targetPort: 9900
  selector:
    io.apisnoop.auditlogger: apisnoop-auditlogger
  clusterIP: 10.96.96.96
  type: ClusterIP
#+end_src

* Footnotes
