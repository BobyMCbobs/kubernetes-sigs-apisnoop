#+TITLE: Tables, Views, Functions
#+PROPERTY: header-args:sql-mode :product postgres :noweb yes :comments no :results silent

* Purpose
  This document holds all the definitions for the snoopdb database.
  Each table, view, function, and comment defined here is tangled into the ~postgres/initdb~ folder in this same directory, which is initialized as part of the docker image.

  This document, then, is the source of truth for the database and anything related to it should be defined here and tangled to its necessary path.
* Basic Database Setup
The database is organized around three schemas: public, conformance, testing.
- public :: default schema related to the overall testing coverage of k8s and the evolving definition of its api
- conformance :: relations related to conformance coverage specifically, and so focused on stable, conformant-eligible endpoints and the things to know about them
- testing :: relations related to the live-testing environment of apisnoop.  Our auditlogger will insert audit events here so we can see whether the functions we're writing increase coverage
* Numbering Scheme of relations
Our numbering is based on the _type_ of relation, but moves across schemas.
- 000 - 099 :: any admin/setup for the db, like addiong extensions and schemas
- 100 - 199 :: all our tables
- 200 - 299 :: all our views, organized by their dependencies (e.g if one view requires another to already exist)
- 300 - 399 :: all our functions
- 400 - 499 :: all our triggers
- 500 - 599 :: bootstrap scripts (not a part of the db, but run during initialization to make sure we have data)

  We also define some selection scripts that are useful for work outside of the db, like a sql script that generates the latest coverage json.  These are defined here, but the filenames don't follow the numbering as they aren't a part of the initdb.
* Setup
** Create Schemas
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/000_create_schemas.sql
   :END:
   #+begin_src sql-mode
     create schema conformance;
     create schema testing;

     comment on schema conformance is 'relations focused on conformance coverage and stable, conformance-eligible endpoints';
     comment on schema testing is 'relations related to our live testing environment, to test if mock tests hit desired endpoints';
   #+end_src
** Create Extensions
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/001_create_extensions.sql
   :END:
   #+begin_src sql-mode
     create extension plpython3u;
     create extension semver;
   #+end_src
* Tables
** Public
*** open_api
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/100_table_open_api.sql
   :END:
   #+NAME: openapi
   #+begin_src sql-mode
     create table open_api
       (
         release text,
         release_date timestamp,
         endpoint text,
         level text,
         category text,
         path text,
         k8s_group text,
         k8s_version text,
         k8s_kind text,
         k8s_action text,
         deprecated boolean,
         description text,
         spec text,
         primary key (release, endpoint)
       );

   #+end_src

   #+NAME: open_api comments
   #+begin_src sql-mode
     comment on table open_api is 'endpoint details from openAPI spec';
     comment on column open_api.release is 'kubernetes release of this spec';
     comment on column open_api.release_date is 'canonical release date for k8s release';
     comment on column open_api.endpoint is 'kubernetes endpoint, the operation_id in the spec';
     comment on column open_api.level is 'alpha, beta, or stable';
     comment on column open_api.category is 'endpoint category, roughly its group, taken from the first tag in the spec.';
     comment on column open_api.path is 'the http path of the endpoint';
     comment on column open_api.k8s_group is 'k8s group for endpoint';
     comment on column open_api.k8s_version is 'k8s version for endpoint';
     comment on column open_api.k8s_kind  is 'k8s kind  for endpoint';
     comment on column open_api.k8s_action is 'endpoint action, roughly related to an http method';
     comment on column open_api.deprecated is 'is endpoint marked as deprecated?';
     comment on column open_api.description is 'description of endpoint';
     comment on column open_api.spec is 'the source for this open api spec, taken from github.';

   #+end_src
*** audit_event
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/101_table_audit_event.sql
   :END:

   #+NAME: audit event definition
   #+begin_src sql-mode
     CREATE UNLOGGED TABLE audit_event (
       release text,
       release_date text,
       audit_id text NOT NULL,
       endpoint text,
       useragent text,
       test text,
       test_hit boolean,
       conf_test_hit boolean,
       data jsonb NOT NULL,
       source text,
       id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
       ingested_at timestamp DEFAULT CURRENT_TIMESTAMP);

   #+end_src

   #+NAME: audit event comments
   #+begin_src sql-mode
     comment on table audit_event is 'every event from an e2e test run, or multiple test runs.';

     comment on column audit_event.release is 'release this test suite was run for';
     comment on column audit_event.release_date is 'canonical release date (or test run date if version not released yet';
     comment on column audit_event.audit_id is 'audit event id as given in log.  Note these are not necessarily unique.';
     comment on column audit_event.endpoint is 'endpoint hit by this audit event';
     comment on column audit_event.useragent is 'useragent of the event, taken from events request header';
     comment on column audit_event.test is 'the test codename if it can be extracted from useragent, else null';
     comment on column audit_event.test_hit is 'is the useragent of the event a test?';
     comment on column audit_event.conf_test_hit is 'is the useragent of the event a conformance test?';
     comment on column audit_event.data is 'the full json of the audit event';
     comment on column audit_event.source is 'url of the bucket where the test run logs are stored';
     comment on column audit_event.id is 'generated id, this will be unique';
     comment on column audit_event.ingested_at is 'the time at which the audit_event was added to this table';
   #+end_src

** Conformance
*** test
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/102_table_test.sql
   :END:

  #+NAME: Test Definition
  #+begin_src sql-mode
    create table conformance.test
      (
        testname text,
        codename text,
        release text,
        description text,
        file text
    );

  #+end_src

  #+NAME: Test Comments
  #+begin_src sql-mode
    comment on table conformance.test is 'info for each conformance test, from latest conformance.yaml';
    comment on column conformance.test.testname is 'name of the test';
    comment on column conformance.test.codename is 'How the test is displayed within a useragent';
    comment on column conformance.test.release is 'release in which this test was promoted to conformance';
    comment on column conformance.test.description is 'description of this test';
    comment on column conformance.test.file is 'file in kubernetes/kubernetes where this test is defined';
  #+end_src
*** ineligible_endpoint
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/103_table_ineligible_endpoint.sql
   :END:
#+BEGIN_SRC sql-mode
create table conformance.ineligible_endpoint(
      endpoint text not null,
      reason text,
      link text,
      primary key (endpoint)
);
#+END_SRC

#+begin_src sql-mode
comment on table conformance.ineligible_endpoint is 'endpoints ineligible for conformance testing';
comment on column conformance.ineligible_endpoint.endpoint is 'the ineligible endpoint';
comment on column conformance.ineligible_endpoint.reason is 'reason, from conformance guidelines, for ineligibility';
comment on column conformance.ineligible_endpoint.link is 'url source for reason';
#+end_src
** Testing
*** audit_event
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/104_table_audit_event.sql
   :END:

   #+NAME: audit event definition
   #+begin_src sql-mode
     CREATE UNLOGGED TABLE testing.audit_event (
       release text,
       release_date text,
       audit_id text NOT NULL,
       endpoint text,
       useragent text,
       test text,
       test_hit boolean,
       conf_test_hit boolean,
       data jsonb NOT NULL,
       source text,
       id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
       ingested_at timestamp DEFAULT CURRENT_TIMESTAMP);

   #+end_src

   #+NAME: audit event comments
   #+begin_src sql-mode
     comment on table testing.audit_event is 'every event from an e2e test run, or multiple test runs.';

     comment on column testing.audit_event.release is 'release this test suite was run for';
     comment on column testing.audit_event.release_date is 'canonical release date (or test run date if version not released yet';
     comment on column testing.audit_event.audit_id is 'audit event id as given in log.  Note these are not necessarily unique.';
     comment on column testing.audit_event.endpoint is 'endpoint hit by this audit event';
     comment on column testing.audit_event.useragent is 'useragent of the event, taken from events request header';
     comment on column testing.audit_event.test is 'the test codename if it can be extracted from useragent, else null';
     comment on column testing.audit_event.test_hit is 'is the useragent of the event a test?';
     comment on column testing.audit_event.conf_test_hit is 'is the useragent of the event a conformance test?';
     comment on column testing.audit_event.data is 'the full json of the audit event';
     comment on column testing.audit_event.source is 'url of the bucket where the test run logs are stored';
     comment on column testing.audit_event.id is 'generated id, this will be unique';
     comment on column testing.audit_event.ingested_at is 'the time at which the audit event was added to this table';
   #+end_src

* Views
** Public
*** Endpoint Coverage
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/200_view_endpoint_coverage.sql
   :END:
   #+NAME: endpoint_coverage definition
   #+begin_src sql-mode
     create or replace view endpoint_coverage as
     select release, endpoint, level, category, path, description,
            k8s_kind as kind,
            k8s_version as version,
            k8s_group as group,
            k8s_action as action,
            (count(test_hit) filter(where test_hit is true)>0) as tested,
            (count(conf_test_hit) filter(where conf_test_hit is true)>0) as conf_tested,
            array_agg(distinct test) as tests
       from      open_api
       left join audit_event using (endpoint, release)
      where deprecated is false
      group by release, endpoint, level, category, path, description, kind, version, k8s_group, k8s_action
      order by level desc, endpoint;

   #+end_src

   #+NAME: endpoint_coverage comments
   #+begin_src sql-mode
     comment on view endpoint_coverage is 'Coverage info for every endpoint in a release, taken from audit events for that release';

     comment on column endpoint_coverage.release is 'the open api release, date of endpoint details ';
     comment on column endpoint_coverage.endpoint is 'a kubernetes endpoint, the operation_id in the spec';
     comment on column endpoint_coverage.level is 'alpha, beta, or stable';
     comment on column endpoint_coverage.category is 'endpoint category, roughly its group, taken from the first tag in the spec.';
     comment on column endpoint_coverage.path is 'the http path of the endpoint';
     comment on column endpoint_coverage.group is 'k8s group for endpoint';
     comment on column endpoint_coverage.version is 'k8s version for endpoint';
     comment on column endpoint_coverage.kind  is 'k8s kind  for endpoint';
     comment on column endpoint_coverage.action is 'endpoint action, roughly related to an http method';
     comment on column endpoint_coverage.tested is 'was endpoint hit at least once by a test useragent';
     comment on column endpoint_coverage.conf_tested is 'was endpoint hit at least once by a conformance test useragent';
     comment on column endpoint_coverage.tests is 'array of codenames of all tests that hit this endpoint';

   #+end_src

   #+begin_src sql-mode
     select 'endpoint_coverage defined and commented' as "build log";
   #+end_src
*** Audit Event Test
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/201_view_audit_event_test.sql
   :END:
   #+NAME: audit_event_test definition
   #+begin_src sql-mode :results silent
     create or replace view audit_event_test as
       select event.release,
              event.test,
              (test.testname is not null) as conformance_test,
                test.testname,
              test.file,
              test.release as promotion_release
         from      audit_event event
         left join conformance.test test on(event.test = test.codename)
        where test is not null
        group by test, testname, file, test.release, event.release;
   #+end_src

   #+NAME: audit_event_test comments
   #+begin_src sql-mode

     comment on view audit_event_test is 'every test in the audit_log of a release';
     comment on column audit_event_test.release is 'audit log relesae this test is pulled from';
     comment on column audit_event_test.test is 'test as it appears in audit event, would be codename in conformance.yaml';
     comment on column audit_event_test.conformance_test is 'is this a conformance test?';
     comment on column audit_event_test.testname is 'if conformance, testname as it appears in conformance.yaml, else null.';
     comment on column audit_event_test.file is 'if conformance, file in which test is defined, else null';
     comment on column audit_event_test.promotion_release is 'if conformance, release in which it was promoted, else null.';
   #+end_src

   #+begin_src sql-mode
     select 'audit_event_test defined and commented' as "build log";
   #+end_src

** Conformance
*** eligible endpoint
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/203_view_conformance_eligible_endpoint.sql
   :END:
   #+begin_src sql-mode
     create or replace view conformance.eligible_endpoint as
          select endpoint
            from open_api
                   join (
                     select release
                       from open_api
                      order by release::semver desc
                      limit 1) latest using(release)
           where level = 'stable'
           and deprecated is not true
          except
          select endpoint
            from conformance.ineligible_endpoint;
    #+end_src

    #+begin_src sql-mode
      comment on view conformance.eligible_endpoint is 'all current stable endpoints for which conformant tests could be written, following conformance guidelines';

      comment on column conformance.eligible_endpoint.endpoint is 'the endpoint, as its defined in the open_api table';
    #+end_src
   #+begin_src sql-mode
     select 'conformance.eligible_endpoint defined and commented' as "build log";
   #+end_src

*** eligible endpoint coverage
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/204_view_conformance_eligible_endpoint_coverage.sql
   :END:
   #+NAME: eligible endpoint coverage definition
   #+begin_src sql-mode :results silent
          create materialized view conformance.eligible_endpoint_coverage as
            select
            oa.endpoint,
            (array_agg(test.release order by test.release::semver))[1] as first_conformance_test,
            (array_agg(test.testname order by test.release::semver))[1] as test,
            (array_agg(test.codename order by test.release::semver))[1] as codename,
            (array_agg(test.file order by test.release::semver))[1] as file,
            (array_agg(oa.release order by oa.release::semver))[1] as first_release,
            array_remove((array_agg(distinct test.release::semver order by test.release::semver)), null) as all_test_releases
            from
                      open_api oa
           inner join conformance.eligible_endpoint using(endpoint)
            left join audit_event ae using(endpoint)
            left join conformance.test test on (ae.test = test.codename)
     group by endpoint;
   #+end_src

   #+NAME: eligible endopint coverage comments
   #+begin_src sql-mode
     comment on materialized view conformance.eligible_endpoint_coverage is 'in-depth coverage info for eligible endpoints';

     comment on column conformance.eligible_endpoint_coverage.endpoint is 'endpoint as defined in table open_api';
     comment on column conformance.eligible_endpoint_coverage.first_conformance_test is 'release of earliest conformance test that hits endpoint. May be earlier than release of endpoint.';
     comment on column conformance.eligible_endpoint_coverage.test is 'Name of first test that hits endopint, as given in conformance.yaml';
     comment on column conformance.eligible_endpoint_coverage.codename is 'first test as it appears in useragent of auditlog';
     comment on column conformance.eligible_endpoint_coverage.file is 'file where this first test is defined';
     comment on column conformance.eligible_endpoint_coverage.first_release is 'release in which this endpoint first appears in the open_api spec as an eligible endpoint.';
     comment on column conformance.eligible_endpoint_coverage.all_test_releases is 'set of releases for tests that hit this endpoint';
   #+end_src

   #+begin_src sql-mode
     select 'conformance.eligible_endpoint_coverage defined and commented' as "build log";
   #+end_src
*** conformance progress
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/205_view_conformance_progress.sql
   :END:
  #+NAME: conformance progress definition
  #+begin_src sql-mode
    create or replace view conformance.progress as
        with endpoints_per_release as (-- this filters out endpoints that were dropped after the release
          select release, endpoint
            from      open_api
           inner join conformance.eligible_endpoint using(endpoint)
        )
        select distinct
          epr.release::semver,
          count(*) filter (where epr.release = coverage.first_release) as new_endpoints,
          (select count(*) from conformance.test where conformance.test.release = epr.release) as new_tests,
          count(*) filter (
            where epr.release = coverage.first_release
            and coverage.all_test_releases @> array[epr.release::semver]
          ) as new_endpoints_promoted_with_tests,
          count(*) filter (
            where epr.release = coverage.first_release
            and coverage.first_conformance_test = coverage.first_release
          ) as new_endpoints_covered_by_new_tests,
          count(*) filter (
          where coverage.first_release = epr.release
          and coverage.first_conformance_test::semver < epr.release::semver
          ) new_endpoints_covered_by_old_tests,
          count(*) filter (
            where coverage.first_release::semver < epr.release::semver
              and coverage.first_conformance_test = epr.release
          ) old_endpoints_covered_by_new_tests,
          count(*) as total_endpoints,
          count(*) filter (
            where coverage.first_release::semver <= epr.release::semver
            and coverage.first_conformance_test::semver <= epr.release::semver
          ) as total_tested_endpoints,
          count(*) filter (
            where coverage.first_release = epr.release
            AND coverage.first_conformance_test is null
          ) endpoints_still_untested_today
        from      endpoints_per_release epr
        left join conformance.eligible_endpoint_coverage coverage using (endpoint)
        where release::semver >= '1.8.0'::semver
        group by epr.release
        order by epr.release::semver;
    #+end_src

    #+NAME: conformance progress comments
    #+begin_src sql-mode
      comment on view conformance.progress is 'per release, the # of new, eligible endpoints and coverage ratios';

      comment on column conformance.progress.release is 'the kubernetes release';
      comment on column conformance.progress.new_endpoints is '# of eligible endpoints promoted to stable in this release';
      comment on column conformance.progress.new_tests is '# of tests promoted to conformance this release';
      comment on column conformance.progress.new_endpoints_promoted_with_tests is '# of new endpoints hit by a new test, meaning the test and endpoint were promoted in tandem';
      comment on column conformance.progress.new_endpoints_covered_by_new_tests is '# of new endpoints whose first test is one that was promoted this release';
      comment on column conformance.progress.new_endpoints_covered_by_old_tests is '# of new endpoints that were hit by an existing test';
      comment on column conformance.progress.old_endpoints_covered_by_new_tests is '# old endoints hit for the first time by a test from this release.  This shows the payment of technical debt';
      comment on column conformance.progress.total_tested_endpoints is 'total # of eligible endopints hit by tests';
      comment on column conformance.progress.endpoints_still_untested_today is '# of new endopints from this release that are unhit as of the present day';
    #+end_src

   #+begin_src sql-mode
     select 'conformance.conformance_progress defined and commented' as "build log";
   #+end_src
*** coverage per release
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/206_view_conformance_coverage_per_release.sql
   :END:

  #+NAME: coverage_per_release definition
  #+begin_src sql-mode :results silent
create or replace view conformance.coverage_per_release as
          with endpoints_per_release as (
            select release, endpoint
              from       open_api
              inner join conformance.eligible_endpoint using(endpoint)
          ), counts as (
          select distinct epr.release::semver,
                 count(*) filter (where epr.release = firsts.first_release) as new_endpoints,
                 count(*) filter (where epr.release = firsts.first_release and first_conformance_test is not null) as tested,
                 count(*) filter (where epr.release = firsts.first_release and first_conformance_test is null) as untested
          from      endpoints_per_release epr
          left join conformance.eligible_endpoint_coverage firsts on (epr.endpoint = firsts.endpoint)
         group by epr.release
         order by epr.release::semver
       )
          select release,
                 new_endpoints as "new endpoints",
                 tested,
                 untested,
                 sum(tested) over (order by release::semver) as "total tested",
                 sum(untested) over (order by release::semver) as "total untested",
                 sum(new_endpoints) over (order by release::semver) as "total endpoints"
            from counts;
    ;
    #+end_src

    #+NAME: coverage per release definition
    #+begin_src sql-mode
      comment on view conformance.coverage_per_release is 'How many endopoints from a release are tested today?';

      comment on column conformance.coverage_per_release.release is 'the given kubernetes release';
      comment on column conformance.coverage_per_release.tested is '# of endpoints from this release that are tested today';
      comment on column conformance.coverage_per_release.untested is '# of endpoints from this release that are untested today.';
      comment on column conformance.coverage_per_release."new endpoints" is '# of endpoints introduced in this release';
      comment on column conformance.coverage_per_release."total tested" is '# of total tested endpoints from this release and earlier. will be higher than same column in conformance.progress as it includes endpoints hit by tests introduced in a later release.';
      comment on column conformance.coverage_per_release."total untested" is '# of total untested endpoints from this release and earlier';
      comment on column conformance.coverage_per_release."total endpoints" is '# of total endpoints at time of release';


    #+end_src

   #+begin_src sql-mode
     select 'conformance.coverage_per_release defined and commented' as "build log";
   #+end_src
*** new endpoints
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/207_view_conformance_new_endpoints.sql
   :END:

   #+NAME: new endpoints definition
   #+begin_src sql-mode
     create view conformance.new_endpoint as
          select endpoint,
                 first_release as release,
                 (first_conformance_test is not null) as tested
                   from conformance.eligible_endpoint_coverage
               order by first_release::semver desc, tested;

   #+end_src

   #+begin_src sql-mode
     comment on view conformance.new_endpoint is 'eligible endpoints sorted by release and whether they are tested';

     comment on column conformance.new_endpoint.endpoint is 'eligible endpoint as defined in table open_api';
     comment on column conformance.new_endpoint.release is 'release in which this endpoint was promoted';
     comment on column conformance.new_endpoint.endpoint is 'is this endpoint hit by a conformance test, as of latest test run?';
   #+end_src

   #+begin_src sql-mode
     select 'conformance.new_endpoint defined and commented' as "build log";
   #+end_src

** Testing
*** untested_stable_endpoints
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/208_untested_stable_endpoint.sql
   :END:
#+NAME: untested_stable_endpoints
#+BEGIN_SRC  sql-mode
CREATE OR REPLACE VIEW "testing"."untested_stable_endpoint" AS
  with latest_release as (
  select release::semver as release
    from open_api
   order by release::semver desc
   limit 1
  )
  select ec.*,
         exists(select * from conformance.eligible_endpoint ee where ee.endpoint = ec.endpoint) as eligible
    from endpoint_coverage  ec
    join latest_release on(ec.release::semver = latest_release.release)
   where level = 'stable'
     and tested is false
   ORDER BY endpoint desc;
#+END_SRC

*** endpoint_hit_by_new_test
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/209_endpoint_hit_by_new_test.sql
   :END:
#+BEGIN_SRC sql-mode
create or replace view "testing"."endpoint_hit_by_new_test" AS
  with live_testing_endpoints AS (
    SELECT endpoint, useragent,
           count(*) as hits
      from testing.audit_event
      where useragent like 'live%'
     group by endpoint, useragent
  ), baseline as  (
    select distinct
      ec.endpoint,
      ec.tested,
      ec.conf_tested,
      release
      from endpoint_coverage ec
      where ec.release = (
      select release
      from open_api
      order by release::semver desc
      limit 1
     )
  )
  select distinct
    lte.useragent,
    lte.endpoint,
    b.tested as hit_by_ete,
    lte.hits as hit_by_new_test
    from live_testing_endpoints lte
    join baseline b using(endpoint);
#+END_SRC

*** projected_change_in_coverage
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/210_projected_change_in_coverage.sql
   :END:
#+BEGIN_SRC sql-mode
CREATE OR REPLACE VIEW "testing"."projected_change_in_coverage" AS
 with latest_release as (
 select release
   from open_api
   order by release::semver desc
   limit 1
), baseline AS (
   SELECT count(*) as total_endpoints,
          count(*) filter(where tested is true) as tested_endpoints
     FROM
         endpoint_coverage
         join latest_release using(release)
 ), test AS (
   SELECT
     COUNT(1) AS endpoints_hit
     FROM
         (
           SELECT
             endpoint
     FROM testing.audit_event

      WHERE useragent like 'live%'
     EXCEPT
     SELECT
      endpoint
     FROM
         endpoint_coverage
         WHERE tested is true
               ) tested_endpoints
 ), coverage AS (
   SELECT
   baseline.tested_endpoints as old_coverage,
   (baseline.tested_endpoints::int + test.endpoints_hit::int) AS new_coverage
   FROM baseline, test
 )
 SELECT
   'test_coverage' AS category,
   baseline.total_endpoints,
   coverage.old_coverage,
   coverage.new_coverage,
   (coverage.new_coverage - coverage.old_coverage) AS change_in_number
   FROM baseline, coverage ;
#+END_SRC
* Functions
** Public
*** load_open_api
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/300_fn_load_open_api.sql
   :END:
#+NAME: updated load_open_api
#+begin_src sql-mode
create or replace function load_open_api (
  custom_release text default null
  )
returns text AS $$
from string import Template
import json
import time
import datetime
from urllib.request import urlopen, urlretrieve
import urllib
import yaml

K8S_REPO_URL = 'https://raw.githubusercontent.com/kubernetes/kubernetes/'
OPEN_API_PATH = '/api/openapi-spec/swagger.json'
RELEASES_URL = 'https://raw.githubusercontent.com/cncf/apisnoop/main/resources/coverage/releases.yaml'

# Get info about latest release from our releases.yaml
releases = yaml.safe_load(urlopen(RELEASES_URL))
latest_release = releases[0]

# Set values for sql template  based on if custom_release argument was passed
if custom_release is not None:
  open_api_url = K8S_REPO_URL + 'v' + custom_release  + OPEN_API_PATH
# check to see if we can load this custom_release url
  try:
    open_api = json.loads(urlopen(open_api_url).read().decode('utf-8'))
    release = custom_release
    rd = [r for r in releases if r['version'] == release][0]['release_date']
    release_date = time.mktime(datetime.datetime.strptime(str(rd), "%Y-%m-%d").timetuple())
  except urllib.error.HTTPError as e:
    raise ValueError('http error with', custom_release)
else:
  open_api_url = K8S_REPO_URL + 'master' + OPEN_API_PATH
  open_api = json.loads(urlopen(open_api_url).read().decode('utf-8'))
  release = latest_release['version']
  release_date = time.mktime(datetime.datetime.now().timetuple())
sql = Template("""
   WITH open AS (
     SELECT '${open_api}'::jsonb as api_data
     )
       INSERT INTO open_api(
         release,
         release_date,
         endpoint,
         level,
         category,
         path,
         k8s_group,
         k8s_version,
         k8s_kind,
         k8s_action,
         deprecated,
         description,
         spec
       )
   SELECT
     '${release}' as release,
     to_timestamp(${release_date}) as release_date,
     (d.value ->> 'operationId'::text) as endpoint,
     CASE
       WHEN paths.key ~~ '%alpha%' THEN 'alpha'
       WHEN paths.key ~~ '%beta%' THEN 'beta'
       -- these endpoints are beta, but are not marked as such, yet, in the swagger.json
       WHEN (d.value ->> 'operationId'::text) = any('{"getServiceAccountIssuerOpenIDConfiguration", "getServiceAccountIssuerOpenIDKeyset"}') THEN 'beta'
       ELSE 'stable'
     END AS level,
     split_part((cat_tag.value ->> 0), '_'::text, 1) AS category,
     paths.key AS path,
     ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'group'::text) AS k8s_group,
     ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'version'::text) AS k8s_version,
     ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'kind'::text) AS k8s_kind,
     (d.value ->> 'x-kubernetes-action'::text) AS k8s_action,
     CASE
       WHEN (lower((d.value ->> 'description'::text)) ~~ '%deprecated%'::text) THEN true
       ELSE false
     END AS deprecated,
                 (d.value ->> 'description'::text) AS description,
                 '${open_api_url}' as spec
     FROM
         open
          , jsonb_each((open.api_data -> 'paths'::text)) paths(key, value)
          , jsonb_each(paths.value) d(key, value)
          , jsonb_array_elements((d.value -> 'tags'::text)) cat_tag(value)
    ORDER BY paths.key;
              """).substitute(release = release,
                              release_date = str(release_date),
                              open_api = json.dumps(open_api).replace("'","''"),
                              open_api_url = open_api_url)
try:
  plpy.execute((sql))
  return "{} open api is loaded".format(release)
except Exception as e:
  return "an error occurred: " + str(e) + "\nrelease: " + release
$$ LANGUAGE plpython3u ;
reset role;

#+end_src


#+NAME: load_open_api comments
#+begin_src sql-mode
comment on function load_open_api is 'loads given release to open_api table.  Pass release (as "X.XX.X") to load specific release, otherwise loads latest';

#+end_src

#+begin_src sql-mode
select 'load_open_api function defined and commented' as "build log";
#+end_src

*** load_audit_events
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/301_fn_load_audit_events.sql
   :END:
    #+NAME: load_audit_events definition
    #+begin_src sql-mode
      create or replace function load_audit_events(
        custom_bucket text default null,
        custom_job text default null)

        returns text AS $$
        from string import Template
        from urllib.request import urlopen
        import json
        import yaml
        from snoopUtils import determine_bucket_job, download_and_process_auditlogs

        GCS_LOGS="https://storage.googleapis.com/kubernetes-jenkins/logs/"
        RELEASES_URL = "https://raw.githubusercontent.com/cncf/apisnoop/master/resources/coverage/releases.yaml"

        releases = yaml.safe_load(urlopen(RELEASES_URL))
        latest_release = releases[0]['version']

        bucket, job = determine_bucket_job(custom_bucket, custom_job)
        plpy.log("our bucket and job", detail=[bucket,job])
        metadata_url = ''.join([GCS_LOGS, bucket, '/', job, '/finished.json'])
        metadata = json.loads(urlopen(metadata_url).read().decode('utf-8'))
        plpy.log("our finished json", detail=urlopen(metadata_url).read().decode('utf-8'))
        auditlog_file = download_and_process_auditlogs(bucket, job)

        release_date = int(metadata['timestamp'])
        if bucket == 'ci-audit-kind-conformance':
            release = latest_release
        else:
            release = metadata["version"].split('-')[0].replace('v','')
            num = release.replace('.','')
            if int(release.split('.')[1]) > int(latest_release.split('.')[1]):
                release = latest_release
        # if we are grabbing latest release, and it is on cusp of new release,
        # then test runs will show their version as the next release...which is confusing,
        # this period is a code freeze, where tests can still be added, and so the logs we are
        # seeing still shows coverage for the version just about to be released.
        # when this happens, we set our release to what is canonically the latest.
        if custom_bucket is None and custom_job is None:
          release = latest_release

        sql = Template("""
          CREATE TEMPORARY TABLE audit_event_import${job}(data jsonb not null) ;
          COPY audit_event_import${job}(data)
          FROM '${audit_logfile}' (DELIMITER e'\x02', FORMAT 'csv', QUOTE e'\x01');

          INSERT INTO audit_event(release, release_date,
                                  audit_id, endpoint,
                                  useragent, test,
                                  test_hit, conf_test_hit,
                                  data, source)

          SELECT trim(leading 'v' from '${release}') as release,
                  '${release_date}',
                  (raw.data ->> 'auditID'),
                  (raw.data ->> 'operationId') as endpoint,
                  (raw.data ->> 'userAgent') as useragent,
                  CASE
                    WHEN ((raw.data ->> 'userAgent') like 'e2e.test%')
                      THEN trim(split_part((raw.data->>'userAgent'), '--'::text, 2))
                    ELSE null
                  END as test,
                  ((raw.data ->> 'userAgent') like 'e2e.test%') as test_hit,
                  ((raw.data ->> 'userAgent') like '%[Conformance]%') as conf_test_hit,
                  raw.data,
                  'https://prow.k8s.io/view/gcs/kubernetes-jenkins/logs/${bucket}/${job}' as source
            FROM audit_event_import${job} raw;
                  """).substitute(
                      audit_logfile = auditlog_file,
                      release = release,
                      bucket = bucket,
                      job = job,
                      release_date = release_date
                  )
        try:
            plpy.execute(sql)
            return "events for {} loaded, from {}/{}".format(release, bucket, job)
        except plpy.SPIError as plpyError:
            print("something went wrong with plpy: ")
            return plpyError
        except:
            return "something unknown went wrong"
        $$ LANGUAGE plpython3u ;
        reset role;
    #+end_src

    #+NAME: load_audit_events comments
    #+begin_src sql-mode
      comment on function load_audit_events is 'loads all audit events from given bucket, job.  if neither given, loads latest successful job from sig-release blocking. if just bucket given, loads latest successful job for that bucket.';
    #+end_src

   #+name: build log
   #+begin_src sql-mode
     select 'load_audit_events function defined and commented' as "build log";
   #+end_src
*** load_tests
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/302_fn_load_tests.sql
   :END:
   #+NAME: load_tests definition
   #+begin_src sql-mode
     create or replace function load_tests()

     returns text AS $$

     from string import Template
     import json
     import yaml
     from urllib.request import urlopen, urlretrieve

     TESTS_URL = "https://raw.githubusercontent.com/kubernetes/kubernetes/master/test/conformance/testdata/conformance.yaml"
     tests = json.dumps(yaml.safe_load(urlopen(TESTS_URL)))
     sql = Template("""
                   with jsonb_array AS (
                   select jsonb_array_elements('${tests}'::jsonb) as test_data)
                   insert into conformance.test(testname, codename, release, description, file)
                      select
                      (test_data->>'testname') as testname,
                      (test_data->>'codename') as codename,
                      case
                        when ((test_data->>'release') = '') then '1.9.0'
                        when ((test_data->>'release') like '%,%')
                          then trim(leading 'v' from split_part((test_data->>'release'), ', ', 2))||'.0'
                        else trim(leading 'v' from (test_data->>'release')) ||'.0'
                      end as release,
                      (test_data->>'description') as description,
                      (test_data->>'file') as file
                      from jsonb_array;
                   """).substitute(tests = tests.replace("'","''"))
     try:
         plpy.execute(sql)
         return 'conformance.yaml loaded into conformance.test!'
     except Exception as e:
         return 'error occured: ', e
     $$ LANGUAGE plpython3u;
   #+end_src

   #+NAME: load_tests comment
   #+begin_src sql-mode
     comment on function load_tests is 'loads latest conformance.yaml into test table';
   #+end_src

   #+begin_src sql-mode
     select 'load_tests function defined and commented' as "build log";
   #+end_src

*** load_ineligible_endpoints
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/303_fn_load_ineligible_endpoints.sql
   :END:
   #+NAME: load_ineligible_endpoints definition
   #+begin_src sql-mode
      create or replace function load_ineligible_endpoints (
        custom_release text default null
        )
      returns text AS $$
      from string import Template
      import json
      from urllib.request import urlopen, urlretrieve
      import urllib
      import yaml

      K8S_REPO_URL = "https://raw.githubusercontent.com/kubernetes/kubernetes/"
      MAIN_BRANCH = "master"
      INELIGIBLE_ENDPOINTS = "/test/conformance/testdata/ineligible_endpoints.yaml"
      INELIGIBLE_URL = K8S_REPO_URL + MAIN_BRANCH + INELIGIBLE_ENDPOINTS

      ineligible_endpoints = json.dumps(yaml.safe_load(urlopen(INELIGIBLE_URL)))
      sql = Template("""
                   with jsonb_array AS (
                   select jsonb_array_elements('${ineligible_endpoints}'::jsonb) as endpoint_data)
                   insert into conformance.ineligible_endpoint(endpoint, reason, link)
                      select
                      (endpoint_data->>'endpoint') as endpoint,
                      (endpoint_data->>'reason') as reason,
                      (endpoint_data->>'link') as link
                      from jsonb_array;
                   """).substitute(ineligible_endpoints = ineligible_endpoints.replace("'","''"))
      try:
          plpy.execute(sql)
          return 'ineligible endpoints loaded!'
      except Exception as e:
          return 'error occured: ', e
     $$ LANGUAGE plpython3u;
    #+end_src

   #+NAME: load_tests comment
   #+begin_src sql-mode
     comment on function load_ineligible_endpoints is 'loads ineligible endpoints from k8s/k8s/test/conformance/testdata';
   #+end_src

   #+begin_src sql-mode
     select 'load_ineligible_endpoints function defined and commented' as "build log";
   #+end_src

*** describe_relations
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/304_fn_describe_relations.sql
   :END:
   #+begin_src sql-mode
     create or replace function describe_relations(
       out schema text,
       out name text,
       out description text
     )
       returns setof record
     as $$
       select table_schema::text as schema,
       table_name::text as name,
       obj_description(table_name::regclass) as description
       from information_schema.tables
       where table_schema = 'public'
       union
       select table_schema as schema,
              table_name as name,
              obj_description(table_name::regclass) as description
       from information_schema.views
       where table_schema = 'public'
       union
       select  table_schema as schema,
               table_name as name,
               obj_description(('conformance.'||table_name)::regclass) as description
       from information_schema.views
       where table_schema = 'conformance'
       union
       select  table_schema as schema,
               table_name as name,
               obj_description(('conformance.'||table_name)::regclass) as description
       from information_schema.tables
       where table_schema = 'conformance'
       union
       select  table_schema as schema,
               table_name as name,
               obj_description(('testing.'||table_name)::regclass) as description
       from information_schema.views
       where table_schema = 'testing'
       union
       select  table_schema as schema,
               table_name as name,
               obj_description(('testing.'||table_name)::regclass) as description
       from information_schema.tables
       where table_schema = 'testing'
       group by name, table_schema
       order by schema desc, name;
     $$ language SQL;
   #+end_src

   #+NAME: describe_relations comment
   #+begin_src sql-mode
     comment on function describe_relations is 'lists all tables and views in db and short description for each';
   #+end_src

   #+NAME: Build Log
   #+begin_src sql-mode
     select 'describe_relations function defined and commented' as "build log";
   #+end_src
*** describe_relation
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/305_fn_describe_relation.sql
   :END:
   #+begin_src sql-mode
     create or replace function describe_relation(
       schema text,
       relation text
     )
       returns text
     as $$
       select obj_description((schema||'.'||relation)::regclass)
     $$ language SQL;
   #+end_src

   #+NAME: describe_relation comment
   #+begin_src sql-mode
     comment on function describe_relation is 'given schema and relation, return its one-line definition';
   #+end_src

   #+NAME: Build Log
   #+begin_src sql-mode
     select 'describe_relation function defined and commented' as "build log";
   #+end_src
*** describe_columns
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/306_fn_describe_columns.sql
   :END:
     #+begin_src sql-mode
       create or replace function describe_columns(
         in schema text,
         in relation text,
         out "column" text,
         out description text
       )
         returns setof record
       as $$
       select cols.column_name::text as "column",
              pg_catalog.col_description(c.oid, cols.ordinal_position::int)::text as description
         from pg_catalog.pg_class c, information_schema.columns cols
        where cols.table_schema = schema
          and cols.table_name = relation
          and cols.table_name = c.relname;
       $$ language SQL;
   #+end_src
   #+NAME: describe_columns comment
   #+begin_src sql-mode
     comment on function describe_columns is 'given schema and relation, list all columns in that relation and their one-line definitions';
   #+end_src

   #+NAME: Build Log
   #+begin_src sql-mode
     select 'describe_columns function defined and commented' as "build log";
   #+end_src
*** describe_column
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/307_fn_describe_column.sql
   :END:

     #+begin_src sql-mode
              create or replace function describe_column(
                in schema text,
                in relation text,
                in col text,
                out "column" text,
                out "description" text
              )
              returns setof record
                   as $$
              select cols.column_name::text as "column",
                     pg_catalog.col_description(c.oid, cols.ordinal_position::int)::text as description
                from pg_catalog.pg_class c, information_schema.columns cols
               where cols.table_schema = schema
                 and cols.table_name = relation
                 and cols.column_name = col
                 and cols.table_name = c.relname;
               $$ language SQL;
   #+end_src

   #+name: describe_column comment
   #+begin_src sql-mode
     comment on function describe_column is 'given schema, relation, and column return its one line definition';
   #+end_src

   #+name: build log
   #+begin_src sql-mode
     select 'describe_column function defined and commented' as "build log";
   #+end_src
*** determine_endpoint
   :PROPERTIES:
   :header-args: :tangle ./postgres/initdb/308_fn_determine_endpoint.sql
   :END:
#+BEGIN_SRC sql-mode
create or replace function determine_endpoint() RETURNS TRIGGER as $$
   import json
   from snoopUtils import load_openapi_spec, find_operation_id
   CURRENT_SWAGGER_URL = "https://raw.githubusercontent.com/kubernetes/kubernetes/master/api/openapi-spec/swagger.json"
   if "spec" not in GD:
       GD["spec"] = load_openapi_spec(CURRENT_SWAGGER_URL)
   spec = GD["spec"]
   event = json.loads(TD["new"]["data"])
   if TD["new"]["endpoint"] is None:
       TD["new"]["endpoint"] = find_operation_id(spec, event);
   return "modify";
$$ language plpython3u;
#+END_SRC
*** Grab Past Releases
:PROPERTIES:
:header-args: :tangle ./postgres/initdb/309_fn_grab_past_releases.sql
:END:

#+NAME: grab_past_releases
#+begin_src sql-mode
create function grab_past_releases ()
returns setof text
language plpython3u as $$

import json
import yaml
from urllib.request import urlopen, urlretrieve

def has_open_api (version):
    major = version.split('.')[1]
    return int(major) >= 5 # open api wasn't established until 1.5.0

RELEASES_URL = 'https://raw.githubusercontent.com/cncf/apisnoop/main/resources/coverage/releases.yaml'
past_releases = yaml.safe_load(urlopen(RELEASES_URL))[1:]
versions_with_openapi = [release["version"] for release in past_releases if has_open_api(release["version"])]
return versions_with_openapi
$$;
#+end_src

#+NAME: grab past releases comment
#+begin_src sql-mode
comment on function grab_past_releases is 'return list of versions (X.XX.X) sans latest that have a swagger.json';
#+end_src

#+name: grab past releases build log
#+begin_src sql-mode
select 'grab_past_releases function defined and commented' as "build log";
#+end_src

*** Generate latest coverage json
:PROPERTIES:
:header-args: :tangle ./postgres/initdb/310_fn_generate_latest_coverage_json.sql
:END:

#+begin_src sql-mode
create function generate_latest_coverage_json()
returns json as $$
declare latest_release varchar;
begin
select release into latest_release from audit_event order by release::semver limit 1;
return(
select jsonb_pretty(row_to_json(c)::jsonb) from (
    select open_api.release, open_api.release_date, open_api.spec,
        count(distinct endpoint_coverage.endpoint)  as "total endpoints",
        count(distinct endpoint_coverage.endpoint) filter (where endpoint_coverage.tested is true)  as "tested endpoints",
        cpr."total endpoints" as "total conformance eligible endpoints",
        cpr."total tested" as "tested conformance eligible endpoints",
        cpr."new endpoints" as "new conformance eligible endpoints",
        cpr.tested as "new tested conformance eligible endpoints",
        (select array_agg(source) from (select source from audit_event where release = latest_release group by source) s) as sources,
        (select array_agg(row_to_json(endpoint_coverage)) from endpoint_coverage where release = latest_release and endpoint is not null) as endpoints,
        (select array_agg(row_to_json(audit_event_test)) from audit_event_test where release = latest_release) as tests
    from open_api
    join endpoint_coverage using(release)
    left join conformance.coverage_per_release cpr on(open_api.release::semver = cpr.release::semver)
    where open_api.release = latest_release
    group by open_api.release, open_api.release_date, open_api.spec, cpr."total endpoints", cpr."total tested", cpr."new endpoints", cpr.tested) c);
end;
$$ language plpgsql;
#+end_src

#+NAME: generate latest coverage json comment
#+begin_src sql-mode
comment on function generate_latest_coverage_json is 'helper to create properly formatted json to be output as a  coverage/X.XX.json file';
#+end_src

#+name: Build Log
#+begin_src sql-mode
select 'generate_latest_coverage_json function defined and commented' as "build log";
#+end_src
* Triggers
** Add Endpoint
:PROPERTIES:
:header-args: :tangle ./postgres/initdb/400_trg_add_endpoint.sql
:END:
#+BEGIN_SRC sql-mode
create trigger add_endpoint
before insert on testing.audit_event
for each row
execute procedure determine_endpoint();
#+END_SRC
* Bootstrap Scripts
** Load all our open_api
:PROPERTIES:
   :header-args: :tangle ./postgres/initdb/500_load_all_open_api.sql
   :END:
#+NAME: Load all open api
#+begin_src sql-mode
begin;
select f.*
    from
    (select release from grab_past_releases() as release) r
    , lateral load_open_api(r.release::text) f("build log");
select * from load_open_api() f("build log");
commit;
#+end_src

** Load tests
:PROPERTIES:
:header-args: :tangle ./postgres/initdb/501_load_all_tests.sql
:END:
#+NAME: load tests
#+begin_src sql-mode
begin;
select * from load_tests() f("build log");
commit;
#+end_src

** Load latest audit_events
:PROPERTIES:
:header-args: :tangle ./postgres/initdb/502_load_all_audit_events.sql
:END:
#+NAME: load latest audit events
#+begin_src sql-mode
begin;
select * from load_audit_events() f("build log");
select * from load_audit_events('ci-kubernetes-gce-conformance-latest') f("build log");
select * from load_audit_events('ci-audit-kind-conformance') f("build log");
commit;
#+end_src
** Refresh Materialized Views
:PROPERTIES:
:header-args: :tangle ./postgres/initdb/503_refresh_eligible_endpoint_coverage.sql
:END:
#+BEGIN_SRC sql-mode
begin;
refresh materialized view conformance.eligible_endpoint_coverage;
select 'conformance.eligible_endpoint_coverage re-materialized' as "build log";
commit;
#+END_SRC
** Output untested endpoints
:PROPERTIES:
:header-args: :tangle ./postgres/initdb/504_output_untested_endpoints.sql
:END:
#+BEGIN_SRC sql-mode
begin;


\t
\a
\o '/tmp/untested-endpoints.txt'

with latest_release as (
select release::semver as release
from open_api
order by release::semver desc
limit 1
)

select endpoint
from conformance.new_endpoint ne
        join latest_release on ne.release::semver = latest_release.release
where tested is false;
\o
\a
\t
select 'untested endpoints for '||release||' written to /tmp/untested-endpoints.txt' as "build log"
from open_api
order by release::semver desc
limit 1;
commit;
#+END_SRC

** Output coverage jsons
:PROPERTIES:
:header-args: :tangle ./postgres/initdb/505_output_coverage_jsons.sql
:END:
This is like our generate-json.sql file, but outputting to a tmp folder in the container, for use with prow jobs.
#+NAME: output coverage jsons
#+begin_src sql
begin;
    
-- move this to its own block if it works
CREATE FUNCTION array_distinct(anyarray) RETURNS anyarray AS $f$
  SELECT array_agg(DISTINCT x) FROM unnest($1) t(x);
$f$ LANGUAGE SQL IMMUTABLE;
    
 select (select release from audit_event order by release limit 1) as latest_release
 \gset
 \set output_file '/tmp/coverage/':latest_release'.json'
 \t
 \a
 \o :output_file
   select * from generate_latest_coverage_json();
 \o
 \o '/tmp/coverage/conformance-progress.json'
 select jsonb_pretty(json_agg(json_build_object(
 'release', release,
 'total', json_build_object(
   'endpoints', total_endpoints,
   'tested', total_tested_endpoints,
   'new', new_endpoints,
   'new_with_tests', new_endpoints_promoted_with_tests,
   'old_tested', old_endpoints_covered_by_new_tests,
   'new_tested', new_endpoints_covered_by_new_tests + new_endpoints_covered_by_old_tests,
   'still_untested', endpoints_still_untested_today
 )
))::jsonb) from conformance.progress;
 \o
 \o '/tmp/coverage/conformance-coverage-per-release.json'
 select jsonb_pretty(json_agg(cp)::jsonb) as output_json
   from (
     select * from conformance.coverage_per_release
   )cp;
 \o
 \o '/tmp/coverage/conformance-endpoints.json'
   select jsonb_pretty(json_agg(ce)::jsonb) as output_json from (
   select endpoint,
   first_release as promotion_release,
   case
   when first_conformance_test is not null
   and first_conformance_test::semver < first_release::semver
   then first_release
   else first_conformance_test
   end as tested_release,
   array_distinct(array_agg(test_json.jb order by test_json.jb->>'codename')) as tests
   from           conformance.eligible_endpoint_coverage ec
   left join audit_event using(endpoint)
   left join conformance.test test on (test.codename = audit_event.test)
   left join lateral (
    select 
           jsonb_build_object(
            'testname', testname,
            'codename', test.codename,
            'file', test.file,
            'release', test.release
            ) as jb
            where testname is not null
            group by test.codename, testname
            order by test.codename, testname
   ) test_json on true
   group by endpoint, first_release, first_conformance_test
   order by first_release::semver desc, endpoint) ce;
\o
\o '/tmp/coverage/ineligible_endpoints.json'
  select jsonb_pretty(json_agg(ie)::jsonb)
  from (select * from conformance.ineligible_endpoint order by endpoint) ie ;
\o
\a
\t
commit;
#+end_src
* Scratch


