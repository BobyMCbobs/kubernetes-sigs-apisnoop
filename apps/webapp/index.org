#+TITLE: Webapp Code, Deployment, and Reference Materials
#+TODO: TODO(t) IN-PROGRESS(i) WAITING(w) | DONE(d)

* Introduction 
  A web display for APIsnoop data, given from an APIsnoop GraphQL API.
* App Src
  :PROPERTIES:
  :header-args: :dir './app/src/'
  :END:
** Sapper Plumbing 
   There's a number of files necessary for any sapper project that ties to a graphql endpoint.  We don't do much with them, but they ensure the site actually runs.
*** client.js
    #+NAME: client.js
    #+begin_src js :tangle ./app/src/client.js
      import * as sapper from '@sapper/app';

      sapper.start({
          target: document.querySelector('#sapper')
      });
    #+end_src
*** server.js
    #+NAME: server.js
    #+begin_src js :tangle ./app/src/server.js
      import sirv from 'sirv';
      import polka from 'polka';
      import compression from 'compression';
      import * as sapper from '@sapper/server';

      const { PORT, NODE_ENV } = process.env;
      const dev = NODE_ENV === 'development';

      polka() // You can also use Express
        .use(
          compression({ threshold: 0 }),
          sirv('static', { dev }),
          sapper.middleware()
        )
        .listen(PORT, err => {
          if (err) console.log('error', err);
        });
    #+end_src
*** apollo.js
    Apollo connects our app to our graphql endpoint.  The app is designed to be run in cluster, so the endpoint is to the in-cluster address for hasura
    #+NAME: apollo.js
    #+begin_src js :tangle ./app/src/apollo.js
      import ApolloClient from 'apollo-boost';
      import fetch from 'node-fetch';

      const GQL_ENDPOINT = 'http://hasura:8080/v1/graphql'
      // const GQL_ENDPOINT = 'http://localhost/hasura/v1/graphql';

      export default new ApolloClient({
        uri: GQL_ENDPOINT,
        fetch: fetch
      });
    #+end_src
*** service-worker.js
    Stores assets and cache so site works well in intermittent internet
    #+NAME: service-worker.js
    #+begin_src js :tangle ./app/src/service-worker.js
      import { timestamp, files, shell, routes } from '@sapper/service-worker';

      const ASSETS = `cache${timestamp}`;

      // `shell` is an array of all the files generated by the bundler,
      // `files` is an array of everything in the `static` directory
      const to_cache = shell.concat(files);
      const cached = new Set(to_cache);

      self.addEventListener('install', event => {
        event.waitUntil(
          caches
            .open(ASSETS)
            .then(cache => cache.addAll(to_cache))
            .then(() => {
              self.skipWaiting();
            })
        );
      });

      self.addEventListener('activate', event => {
        event.waitUntil(
          caches.keys().then(async keys => {
            // delete old caches
            for (const key of keys) {
              if (key !== ASSETS) await caches.delete(key);
            }

            self.clients.claim();
          })
        );
      });

      self.addEventListener('fetch', event => {
        if (event.request.method !== 'GET' || event.request.headers.has('range')) return;

        const url = new URL(event.request.url);

        // don't try to handle e.g. data: URIs
        if (!url.protocol.startsWith('http')) return;

        // ignore dev server requests
        if (url.hostname === self.location.hostname && url.port !== self.location.port) return;

        // always serve static files and bundler-generated assets from cache
        if (url.host === self.location.host && cached.has(url.pathname)) {
          event.respondWith(caches.match(event.request));
          return;
        }

        // for pages, you might want to serve a shell `service-worker-index.html` file,
        // which Sapper has generated for you. It's not right for every
        // app, but if it's right for yours then uncomment this section
        /*
          if (url.origin === self.origin && routes.find(route => route.pattern.test(url.pathname))) {
          event.respondWith(caches.match('/service-worker-index.html'));
          return;
          }
        ,*/

        if (event.request.cache === 'only-if-cached') return;

        // for everything else, try the network first, falling back to
        // cache if the user is offline. (If the pages never change, you
        // might prefer a cache-first approach to a network-first one.)
        event.respondWith(
          caches
            .open(`offline${timestamp}`)
            .then(async cache => {
              try {
                const response = await fetch(event.request);
                cache.put(event.request, response.clone());
                return response;
              } catch(err) {
                const response = await cache.match(event.request);
                if (response) return response;

                throw err;
              }
            })
        );
      });

    #+end_src
** Template for our html files
   This is used to build out our basic html page in which the app blooms within the script.  If you want to add meta content to the head of each page, here is where you'd do it.
   #+NAME: template.html
   #+begin_src html :tangle ./app/src/template.html
     <!doctype html>
     <html>
       <head>
         <meta charset='utf-8'>
         <meta name='viewport' content='width=device-width,initial-scale=1.0'>
         <meta name='theme-color' content='#333333'>

         %sapper.base%

         <link rel='stylesheet' href='global.css'>
         <link rel='manifest' href='manifest.json'>
         <link rel='icon' type='image/png' href='favicon.png'>

         <!-- Sapper generates a <style> tag containing critical CSS
              for the current page. CSS for the rest of the app is
              lazily loaded when it precaches secondary pages -->
           %sapper.styles%

           <!-- This contains the contents of the <svelte:head> component, if
                the current page has one -->
             %sapper.head%
       </head>
       <body>
         <!-- The application will be rendered inside this element,
              because `src/client.js` references it -->
         <div id='sapper'>%sapper.html%</div>

         <!-- Sapper creates a <script> tag containing `src/client.js`
              and anything else it needs to hydrate the app and
              initialise the router -->
           %sapper.scripts%
       </body>
     </html>


   #+end_src
** Layout
   :PROPERTIES:
   :header-args: :tangle ./app/src/routes/_layout.svelte
   :END:
   In sapper, you can add a special _layout.svelte_ file to your routes folder that will set a layout for all files in that directory and sub-directories (if there's layout in a subdirectory it will take that one instead)  this lets us design a single overall page with consistent header and footer no matter where in the site we are.
   
   #+NAME: _layout.svelte
   #+begin_src web
     <script>
      import Nav from '../components/Nav.svelte';

     </script>

     <style>
      main {
        position: relative;
        max-width: 1080px;
        margin: auto;
        padding: 2em;
        box-sizing: border-box;
      }
     </style>

     <Nav />
     <main>
       <slot></slot>
     </main>
   #+end_src
** Routes
*** index ('/')
   The home page.  This should show a coverage over time graph and a sunburst beneath it, the sunburst being set to the latest job on sig-release-blocking.
**** index.json.js
     :PROPERTIES:
     :header-args: :tangle ./app/src/routes/index.json.js
     :END:
     #+NAME: index.json.js
     #+begin_src js 
       import client from "../apollo.js";
       import { determineBucketAndJob } from '../lib/helpers.js';
       import {
         ALL_BUCKETS_AND_JOBS_SANS_LIVE,
         ENDPOINTS_TESTS_AND_USERAGENTS,
         STABLE_ENDPOINT_STATS } from '../queries';

       export async function get(req, res) {
         let bucketAndJobsQuery = await client.query({query: ALL_BUCKETS_AND_JOBS_SANS_LIVE});
         let rawBucketsAndJobsPayload = bucketAndJobsQuery.data.bucket_job_swagger;

         let statsQuery = await client.query({query: STABLE_ENDPOINT_STATS});
         let stableEndpointStatsPayload = statsQuery.data.stable_endpoint_stats;

         let {bucket, job} = determineBucketAndJob(rawBucketsAndJobsPayload);

         let endpointsTestsAndUseragentsQuery = await client.query(
           {query: ENDPOINTS_TESTS_AND_USERAGENTS,
            variables: {bucket, job}
           });
         let endpointsTestsAndUseragentsPayload = endpointsTestsAndUseragentsQuery.data;

         const payload = JSON.stringify({
           stableEndpointStatsPayload,
           rawBucketsAndJobsPayload,
           endpointsTestsAndUseragentsPayload
         });

         res.writeHead(200, {
           'Content-Type': 'application/json'
         });
         res.end(payload);
       }
     #+end_src
   
**** index.svelte
     :PROPERTIES:
     :header-args: :tangle ./app/src/routes/index.svelte
     :END:
     
     We want to show the sunburst, the sunburst derives its bucket and endpoints from the store.  We've added the raw bucket and job, but need to also bring in all endpoints for the default bucket and job. 
     #+NAME: index.svelte
     #+begin_src web
       <script context="module">
        export function preload({ params, query }) {
          return this.fetch(`index.json`)
                     .then(r => r.json())
                     .then(payload => ({ payload }));
        }
       </script>

       <script>
        import CoverageOverTimeContainer from '../components/CoverageOverTimeContainer.svelte'; 
        import SunburstContainer from '../components/SunburstContainer.svelte';
        import { isEqual} from 'lodash-es';
        import {
          stableEndpointStats,
          rawBucketsAndJobs,
          endpointsTestsAndUseragents
        } from '../stores';

        export let payload;
        const {
          rawBucketsAndJobsPayload,
          stableEndpointStatsPayload,
          endpointsTestsAndUseragentsPayload
        } = payload;

        rawBucketsAndJobs.update(raw => isEqual(raw, rawBucketsAndJobsPayload)
                                      ? raw
                                      : rawBucketsAndJobsPayload);

        stableEndpointStats.update(stats => isEqual(stats, stableEndpointStatsPayload)
                                          ? stats
                                          : stableEndpointStatsPayload);

        endpointsTestsAndUseragents.update(etu => isEqual(etu, endpointsTestsAndUseragentsPayload)
                                                ? etu
                                                : endpointsTestsAndUseragentsPayload);
       </script>

       <svelte:head>
         <title>APISnoop</title>
       </svelte:head>
       <CoverageOverTimeContainer />
       <SunburstContainer />
     #+end_src
     
*** [...params]
**** [...params].json.js
     :PROPERTIES:
     :header-args: :tangle ./app/src/routes/[...params].json.js
     :END:
     #+NAME: [...params].json.js
     #+begin_src js 
       import client from "../apollo.js";
       import { determineBucketAndJob } from '../lib/helpers.js';
       import {
         ALL_BUCKETS_AND_JOBS_SANS_LIVE,
         ENDPOINTS_TESTS_AND_USERAGENTS,
         STABLE_ENDPOINT_STATS } from '../queries';

       export async function get (req, res, next) {
         let bucketAndJobsQuery = await client.query({query: ALL_BUCKETS_AND_JOBS_SANS_LIVE});
         let rawBucketsAndJobsPayload = bucketAndJobsQuery.data.bucket_job_swagger;

         let statsQuery = await client.query({query: STABLE_ENDPOINT_STATS});
         let stableEndpointStatsPayload = statsQuery.data.stable_endpoint_stats;

         let query = req.query;
         let [bucketParam, jobParam, level, category, operation_id] = req.params.params;
         let {bucket, job} = determineBucketAndJob(rawBucketsAndJobsPayload, bucketParam, jobParam);

         let endpointsTestsAndUseragentsFromQuery = await client.query(
           {query: ENDPOINTS_TESTS_AND_USERAGENTS,
            variables: {bucket, job}
           });
         let endpointsTestsAndUseragentsPayload = endpointsTestsAndUseragentsFromQuery.data

         let allTheThings = {
           bucket,
           bucketParam,
           category,
           endpointsTestsAndUseragentsPayload,
           job,
           jobParam,
           level,
           operation_id,
           query,
           rawBucketsAndJobsPayload,
           stableEndpointStatsPayload
         };

         let payload = JSON.stringify(allTheThings);

         res.writeHead(200, {
           'Content-Type': 'application/json' ,
         });
         res.end(payload);
       };
     #+end_src
     
**** [...params].svelte
     :PROPERTIES:
     :header-args: :tangle ./app/src/routes/[...params].svelte
     :END:
     
    #+NAME: [...params].svelte
    #+begin_src web
      <script context="module">
       import { join } from 'lodash-es';
       export function preload ({ params, query }) {
         let path = join(params.params, '/');
         return this
           .fetch(`${path}.json`)
           .then(r => r.json())
           .then(payload => ({ payload }));
       };
      </script>

      <script>
       import SunburstContainer from '../components/SunburstContainer.svelte';
       import CoverageOverTime from '../components/CoverageOverTime.svelte';
       import { onMount, afterUpdate } from 'svelte';
       import { isEqual } from 'lodash-es';
       import {
         activeFilters,
         endpointsTestsAndUseragents,
         rawBucketsAndJobs,
         stableEndpointStats,
         warnings
       } from '../stores';

       export let payload;
       const  {
         bucket,
         bucketParam,
         category,
         endpointsTestsAndUseragentsPayload,
         job,
         jobParam,
         level,
         operation_id,
         query,
         rawBucketsAndJobsPayload,
         stableEndpointStatsPayload
       } = payload;

       rawBucketsAndJobs.update(raw => isEqual(raw, rawBucketsAndJobsPayload)
                                     ? raw
                                     : rawBucketsAndJobsPayload);

       stableEndpointStats.update(stats => isEqual(stats, stableEndpointStatsPayload)
                                         ? stats
                                         : stableEndpointStatsPayload);

       endpointsTestsAndUseragents.update(etu => isEqual(etu, endpointsTestsAndUseragentsPayload)
                                               ? etu
                                               : endpointsTestsAndUseragentsPayload);

       activeFilters.update(af => ({
         ...af,
         bucket,
         job: job || '',
         level: level || '',
         category: category || '',
         operation_id: operation_id || ''
         ,
         ...query
       }));

       onMount(() => {
         console.log({payload});
         if (bucketParam && bucketParam !== bucket) {
           warnings.update(warnings => ({...warnings, invalidBucket: true}));
         }
         if (jobParam && jobParam !== job) {
           warnings.update(warnings => ({...warnings, invalidJob: true}));
         }
       })
      </script>
      {#if $warnings.invalidBucket}
      <p><strong>Note: </strong><em>Could not find data for <code>{bucketParam}</code>. Displaying latest job for {bucket} instead.</em></p>
      <button on:click={() => $warnings.invalidBucket = false}>Got it</button>
      {/if}
      {#if !$warnings.invalidBucket && $warnings.invalidJob}
      <p><strong>Note: </strong><em>Could not find data for <code>{jobParam}</code>. Displaying latest job for {bucket} instead.</em></p>
      <button on:click={() => $warnings.invalidJob = false}>Got it</button>
      {/if}
      <CoverageOverTime />
      <SunburstContainer />
    #+end_src
   We want to be able to have dynamic url routes that spring from home like '/bucket/job/stable'.  We also want to have all fetches of our data spring from the server instead of the client (as the client won't be able to access the endpoint if it is an internal k8s address).
   
   To facilitiate this, we build a small json api at the root which takes all requests, ddoes any data fetching ncessary, and returns an html page.  All of this will be done on the server, and the client only receives data from the server.

Sapper has a naming convention for files that if they are in brackets they are treated as dynamic, with the name in the brackets mapping to the url params.  So we name our files [...index] which lets us be able to go to a route like '/bucket/job/stable' and we'll get a url params in a list [bucket, job, stable].  Helpful!
** Components
*** CoverageOverTime.svelte
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/CoverageOverTime.svelte
    :END:
    #+begin_src web 
      <script>
       import dayjs from 'dayjs';
       import { isEmpty } from 'lodash-es';
       import { scaleLinear, scaleTime } from 'd3-scale';
       import { prefetch, goto } from '@sapper/app';
       import {
         dates,
         coverage
       } from '../stores/coverage-over-time.js';
       import {
         bucketsAndJobs
       } from '../stores';

       const padding = { top: 20, right: 15, bottom: 20, left: 25 };
       // y is total percentage, from 0 to 100
       const yTicks = [0, 10, 20, 30, 40, 50, 60,70,80,90, 100];

       // Coverage is sorted by timestamp, with oldest at [0]
       // X ticks will be from oldest audit run to today.
       $: xTicks = [
         dayjs($coverage[0].timestamp).subtract(1, 'day'),
         dayjs().subtract(9, 'month'),
         dayjs().subtract(6, 'month'),
         dayjs().subtract(3, 'month'),
         dayjs()
       ];

       let width = 900;
       let height = 600;

       $: activeJob = {};
       $: minX = dayjs($dates[0]);
       $: maxX = dayjs($dates[$dates.length - 1]);
       $: xScale = scaleTime()
         .domain([minX, maxX])
         .range([padding.left, width - padding.right]);
       $: yScale = scaleLinear()
         .domain([Math.min.apply(null, yTicks), Math.max.apply(null, yTicks)])
         .range([height - padding.bottom, padding.top]);
       $: testedPath = `M${$coverage.map(c => `${xScale(c.timestamp)},${yScale(c.percent_tested)}`).join('L')}`;
       $: testedArea = `${testedPath}L${xScale(maxX)}, ${yScale(0)}L${xScale(minX)},${yScale(0)}Z`;
       $: confPath = `M${$coverage.map(c => `${xScale(c.timestamp)},${yScale(c.percent_conf_tested)}`).join('L')}`;
       $: confArea = `${confPath}L${xScale(maxX)}, ${yScale(0)}L${xScale(minX)},${yScale(0)}Z`;
      </script>

      <div class="chart" bind:clientWidth={width} bind:clientHeight={height}>
        <svg>
          <!-- y axis -->
          <g class='axis y-axis' transform="translate(0, {padding.top})">
            {#each yTicks as tick}
            <g class="tick tick-{tick}" transform="translate(0, {yScale(tick) - padding.bottom})">
              <line x2="100%"></line>
              <text y="-4">{tick} {tick === 100 ? ' percent' : ''}</text>
            </g>
            {/each}
          </g>
          <!-- x axis -->
          <g class="axis x-axis">
            {#each xTicks as tick}
            <g class="tick tick-{ tick}" transform="translate({xScale(tick)},{height})">
              <line y1="-{height}" y2="-{padding.bottom}" x1="0" x2="0"></line>
              <text y="-2">{dayjs(tick).format('DD MMM, YY')}</text>
            </g>
            {/each}
          </g>
          <path class='path-area' d={testedArea}></path>
          <path class='path-line' d={testedPath}></path>
          <path class='path-line conf' d={confPath}></path>
          <path class='path-area conf' d={confArea}></path>
          {#each $coverage as point}
          <circle
            cx='{xScale(point.timestamp)}'
            cy='{yScale(point.percent_tested)}'
            r='5'
            class='point'
            on:mouseover={() => {
            prefetch(`coverage/ci-kubernetes-e2e-gci-gce/${point.job}`)
            activeJob = point
            }}
            on:mouseleave={() => activeJob = {}}
            on:click={() => goto(`coverage/${point.bucket}/${point.job}`)}
          />
          <circle
            cx='{xScale(point.timestamp)}'
            cy='{yScale(point.percent_conf_tested)}'
            r='5'
            class='point conf'
            on:mouseover={() => {
            prefetch(`coverage/ci-kubernetes-e2e-gci-gce/${point.job}`)
            activeJob = point
            }}
            on:mouseleave={() => activeJob = {}}
            on:click={() => goto(`coverage/${point.bucket}/${point.job}`)}
          />
          {/each}
          {#if !isEmpty(activeJob)}
          <text
            transform="translate({width/2 + 50},{height - 100})"
            alignment-baseline="middle"
            text-anchor="middle"
            font-size="12"
          >
            <tspan x="0" dy=".6em">{dayjs(activeJob.date).format('DD MMM, YY')}</tspan>
            <tspan x= "0" dy="1.2em">{activeJob.total_endpoints} stable endpoints</tspan>
            <tspan x="0" dy="1.2em">{activeJob.percent_tested}% tested</tspan>
            <tspan x="0" dy="1.2em">{activeJob.percent_conf_tested}% conformance tested</tspan>
          </text>
          {/if}
        </svg>
      </div>

      <style>
       .chart {
         max-width: 900px;
         margin-left: auto;
         margin-right: auto;
       }

       svg {
         position: relative;
         width: 100%;
         height: 450px;
         overflow: visible;
       }

       .tick {
         font-size: .725em;
         font-weight: 200;
       }

       .tick line {
         stroke: #aaa;
         stroke-dasharray: 2;
       }

       .tick text {
         fill: #666;
         text-anchor: start;
       }

       .tick.tick-0 line {
         stroke-dasharray: 0;
       }

       .x-axis .tick text {
         text-anchor: middle;
       }

       .path-line {
         fill: none;
         stroke: rgb(234,226,108);
         stroke-linejoin: round;
         stroke-linecap: round;
         stroke-width: 1;
       }

       .path-line.conf {
         stroke: rgb( 0, 100, 100);
       }

       .path-area {
         fill: rgba(234, 226, 108, 0.2);
       }

       .path-area.conf {
         fill: rgba(0, 100, 100, 0.2);
       }

       circle.point {
         fill: orange;
         fill-opacity: 0.6;
         stroke: rgba(0,0,0,0.5);
         cursor: pointer;
       }

       circle.point.conf {
         fill: green;
       }
      </style>

    #+end_src
*** CoverageOverTimeContainer
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/CoverageOverTimeContainer.svelte
    :END:
    #+NAME: CoverageOverTimeContainer
    #+begin_src web
      <script>
       import SectionHeader from './SectionHeader.svelte';
       import CoverageOverTime from './CoverageOverTime.svelte';
       import { dates, coverage } from '../stores/coverage-over-time.js';
       import { first, last } from 'lodash-es';
       import { releasePrecision } from '../lib/helpers.js';
       import dayjs from 'dayjs';

       $: releases = $coverage
         .map(stat => ({release: stat.release , date: stat.date}))
         .sort((a,b) => new Date(a.date) - new Date(b.date));

       $: latestRelease = last(releases);
       $: latestUpdate = dayjs(latestRelease.date)
         .format('DD MMMM, YYYY');

       $: otherReleases = releases
         .filter(release => (
           release.date !== latestRelease.date
           && release.release !== latestRelease.release))
       $: test = releasePrecision(latestRelease.release, 2)
       $: pastReleaseSpread = () => {
         let uniqRels = [...new Set(otherReleases.map(r => releasePrecision(r.release, 2)))];
         return uniqRels.length > 1
                                ? `last ${uniqRels.length} releases, from ${first(uniqRels)} to ${last(uniqRels)}`
                                : `last release, ${uniqRels[0]}`
       }
      </script>

      <section>
        <SectionHeader title="Kubernetes Test Coverage Over Time">
          <em>Updated on {latestUpdate}</em>
        </SectionHeader>
        <p>
          Below shows the the testing coverage for standard and conformance tests (where coverage is defined as the percentage of kubernetes endpoints hit by at least one test during an e2e test suite run).
          {#if releases.length > 1}
          The data includes the {pastReleaseSpread()} along with the latest test run for {releasePrecision(latestRelease.release, 2)}.
          {:else}
          The data includes the latest test run for {releasePrecision(latestRelease.release, 2)}
          {/if}
        </p>

        <p>The current goal, as reflected in the y-axis,  is to have at least 50% of kubernetes endpoints hit by tests.</p>
        <strong>Click on any data point to see an in-depth look at that release's coverage</strong>
        <CoverageOverTime />
      </section>

      <style>
       section {
         padding: 1rem;
       }
      </style>
    #+end_src
*** Nav
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/Nav.svelte
    :END:
    #+NAME: Nav
    #+begin_src web
      <nav>
        <img src='logo.png' alt="apisnoop logo, a magnifying glass with a 3 color pie chart inside." />
        <a href='/' class='title'>APISnoop</a>
      </nav>

      <style>
       nav {
         background: #9EEBCF; 
         color: #5E2CA5; 
         display: flex;
         align-items: center;
         padding: 0.25em;
       }
       a.title {
         margin: 0;
         font-size: 1.5em;
         color: inherit;
         text-decoration: none;
       }

       img {
         max-height: 2em;
         margin-right: 0.5em;
       }
      </style>


    #+end_src
*** Sunburst Container
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/SunburstContainer.svelte
    :END:
    #+NAME: SunburstContainer
    #+begin_src web 
      <script>
       import Sunburst from './Sunburst.svelte';
       import SunburstHeader from './SunburstHeader.svelte';
       import SunburstStats from './SunburstStats.svelte';
       import Breadcrumb from './Breadcrumb.svelte';
       import TestsList from './TestsList.svelte';
      </script>

      <section id='coverage'>
        <SunburstHeader />
        <Breadcrumb />
        <Sunburst />
        <SunburstStats />
        <TestsList />
      </section>

      <style>
       section {
         display: grid;
         grid-template-columns: 700px 1fr;
       }
       @media (max-width: 667px) {
         section {
           display: flex;
           flex-flow: column;
         }
       }
      </style>
    #+end_src
    
*** SunburstHeader 
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/SunburstHeader.svelte
    :END:
    #+NAME: SunburstHeader
    #+begin_src web 
      <script>
       import dayjs from 'dayjs';
       import { goto } from '@sapper/app';
       import { activeBucketAndJob } from '../stores';

       $: bucket = $activeBucketAndJob.bucket;
       $: job = $activeBucketAndJob.job;
       $: timestamp = dayjs($activeBucketAndJob.timestamp).format('DD MMMM, YYYY');
      </script>

      <header>
        <h2>{bucket}</h2>
        <p>{timestamp}</p>
      </header>

      <style>
       header {
         margin-bottom: 1.5em;
         grid-column: 1;
       }

       h2 {
         padding: 0;
         font-variant-caps: small-caps;
         margin-bottom: 0;
       }

       p {
         margin-top: 0;
         font-variant-caps: small-caps;
         padding-left: 0.25em;
       }
      </style>


    #+end_src
*** Breadcrumb
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/Breadcrumb.svelte
    :END:
    #+NAME: Breadcrumb
    #+begin_src web
      <script>
       import {
         breadcrumb,
         mouseOverPath,
         opIDs
       } from '../stores';
       import {
         levelColours,
         categoryColours,
         endpointColour
       } from '../lib/colours.js';

       $: [level, category, operation_id] = $breadcrumb;
       $: lColour = levelColours[level] || 'white';
       $: cColour = categoryColours[category] || 'white';
       $: eColour = $opIDs[operation_id]
                  ? endpointColour($opIDs[operation_id]) 
                  : 'white';
       $: eTextColour = $opIDs[operation_id]
                      ? $opIDs[operation_id]['tested'] ? endpointColour($opIDs[operation_id]) : 'gray'
                      : 'white';
      </script>

      <div id='breadcrumb'>
        {#if $mouseOverPath.length > 0}
        <p>{#if level}<span style='border-color: {lColour}; background-color: {lColour};'>{level}</span>{/if}{#if category}<span style='background-Color: {cColour}; border-color: {cColour};'>{category}</span>{/if}{#if operation_id}<span style='border-color: {eColour}; color: {eTextColour};'> {operation_id}</span>{/if}</p>
        {/if}
      </div>

      <style>
       div{
         height: 3em;
         grid-column: 1/2;
         margin-bottom: 1em;
       }
       p {
         font-size: 1.3em;
         font-color: aliceblue;
       }
       span {
         margin: 0;
         color: #EEEEEE;
         padding: 0.25em;
         border: 1px solid;
       }
      </style>


    #+end_src
*** Sunburst
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/Sunburst.svelte
    :END:
    
    #+NAME: Sunburst
    #+begin_src web 
      <script>
       import * as d3 from 'd3';
       import {
         compact,
         join
       } from 'lodash-es';
       import {
         activeBucketAndJob,
         activeFilters,
         mouseOverPath,
         zoomedSunburst
       } from '../stores';

       $: activeDepth = determineDepth($activeFilters);

       const format = d3.format(",d")
       const width = 932
       const radius = width / 8
       const arc = d3.arc()
                     .startAngle(d => d.x0)
                     .endAngle(d => d.x1)
                     .padAngle(d => Math.min((d.x1 - d.x0) / 2, 0.005))
                     .padRadius(radius * 1.5)
                     .innerRadius(d => d.y0 * radius)
                     .outerRadius(d => Math.max(d.y0 * radius, d.y1 * radius - 1))

       function determineDepth (filters) {
         // check out depth based on which filters are set.
         let { level, category, operation_id } = filters;
         let setFilters = compact([level, category, operation_id]) // compact will remove falsy values.
         if (setFilters.length === 3) {
           return 'operation_id'
         } else if (setFilters.length === 2) {
           return 'category';
         } else if (setFilters.length === 1) {
           return 'level';
         } else {
           return 'root'
         }
       };

       function depthUp () {
         // reset the activeFilter for whatever is our current depth.  
         // This will cause the sunburst to expand to the next previous filter, going up a level.
         $mouseOverPath = [];
         if (activeDepth === 'root') {
           return null
         } else if (activeDepth === 'operation_id') {
           $activeFilters['operation_id'] = '';
           $activeFilters['category'] === '';
         } else {
           $activeFilters[activeDepth] = '';
         }
         setURL();
       };

       function labelVisible(d) {
         return d.y1 <= 3 && d.y0 >= 1 && (d.y1 - d.y0) * (d.x1 - d.x0) > 0.03;
       }

       function labelTransform(d) {
         const x = (d.x0 + d.x1) / 2 * 180 / Math.PI;
         const y = (d.y0 + d.y1) / 2 * radius;
         return `rotate(${x - 90}) translate(${y},0) rotate(${x < 180 ? 0 : 180})`;
       }

       function mouseOver(d) {
         $mouseOverPath = d.ancestors().reverse().slice(1);
       }

       function mouseLeave () {
         $mouseOverPath = [];
       }

       function clicked (p) {
         // upon clicking of a node, update the active filters and url.
         let {
           bucket,
           job
         } = $activeBucketAndJob;
         let {
           level,
           category,
           operation_id
         } = p.data;
         activeFilters.update(af => ({...af, bucket, job, level, category, operation_id}));
         setURL();
       };

       function setURL () {
         // push state without triggering a reload, using our active filters in order.
         // this assumes that activeFilters were set correctly before calling this function.
         let {
           bucket,
           job,
           level,
           category,
           operation_id
         } = $activeFilters;
         let filterSegments = compact([bucket, job, level, category, operation_id]);
         let urlPath = join(['coverage', ...filterSegments], '/');
         goto(urlPath);
       };

       $: partition = data => {
         const root = d3.hierarchy(data)
                        .sum(d => d.value)
                        .sort((a, b) => (b.data.tested - a.data.tested))
                        .sort((a, b) => (b.data.conf_tested - a.data.tested));
         return d3.partition()
                  .size([2 * Math.PI, root.height + 1])
         (root);
       }
       $: root = partition($zoomedSunburst).each(d=> d.current = d);
       $: nodes = root
         .descendants()
         .slice(1)
         .map((node) => {
           // take node and determine its opacity based on if its visible and active
           let currentOpacity = 1;
           if ($activeFilters.operation_id !== '' && node.data.operation_id !== '') {
             // if you and endpoint and we've filtered to endpoint, fade yrself if you aren't the filtered endpoint.
             currentOpacity = ($activeFilters.operation_id === node.data.name)
                            ? 1
                            : 0.3
           }
           if ($mouseOverPath.length > 0) {
             currentOpacity = ($mouseOverPath.indexOf(node) >= 0 || $activeFilters.operation_id === node.data.name)
                            ? 1
                            : 0.3
           }
           return {...node, currentOpacity};
         })
      </script>

      <div class="chart">
        <svg viewBox="0,0,932,932" style="font: 12px sans-serif;" on:mouseleave={mouseLeave}>
          <g transform="translate({width/2},{width/2})" id='big-g'>
            <g>
              {#each nodes as node}
              <path
                fill={node.data.color}
                fill-opacity={node.currentOpacity}
                d={arc(node.current)}
                on:mouseover={() => mouseOver(node.current)}
                style="cursor: pointer;"
                on:click={()=> clicked(node)} />
              {/each}
            </g>
            <g pointer-events='none' text-anchor='middle' style='user-select: none;'>
              {#each nodes as node}
              <text
                dy='0.35em'
                fill-opacity = {+labelVisible(node.current)}
                transform = {labelTransform(node.current)}
              >
                {node.children ? node.data.name : ''}
              </text>
              {/each}
            </g>
            <circle
              r={radius}
              fill={root.data.color}
              pointer-events="all"
              on:click={depthUp}
            />

            <text
              text-anchor='middle'
              font-size='2em'
              fill='white'
              transform={$activeFilters.category.length > 0 ? "translate(0, -15)" : ""} >
              {$activeFilters.level}
            </text>
            <text
              text-anchor='middle'
              font-size='2em'
              fill='white'
              transform="translate(0,15)">
              {$activeFilters.category}
            </text>
          </g>
        </svg>
      </div>

      <style>
       .chart {
         position: relative;
         grid-column: 1;
       }
      </style>
    #+end_src
    
*** Sunburst Stats
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/SunburstStats.svelte
    :END:
    #+NAME: SunburstStats
    #+begin_src web 
      <script>
       import EndpointCoverageStats from './EndpointCoverageStats.svelte';
       import { isEmpty } from 'lodash-es';
       import { currentDepth, breadcrumb, coverageAtDepth } from '../stores';

       let percentage = (sum, total) => ((sum / total) * 100).toFixed(2);
       $: total = $coverageAtDepth.totalEndpoints;
       $: tested = $coverageAtDepth.testedEndpoints;
       $: confTested = $coverageAtDepth.confTestedEndpoints;
       $: percentTested = `${percentage(tested,total)}%`;
       $: percentConfTested = `${percentage(confTested, total)}%`;
       $: level = $breadcrumb[0] || '';
       $: category= $breadcrumb[1] || '';
       $: endpoint = $breadcrumb[2] || '';
      </script>

      {#if $currentDepth === 'endpoint'}
      <EndpointCoverageStats />
      {:else}
      <div id='coverage-stats'>
        <p class='breadcrumb'>{level} {category}</p>
        <h2> Coverage</h2>
        <ul>
          <li><strong>{total}</strong> total endpoints</li>
          <li> <strong>{percentTested}</strong> tested ({tested} endpoints)</li>
          <li><strong>{percentConfTested}</strong> conformance tested ({confTested} endpoints)</li>
        </ul>
      </div>
      {/if}



      <style>
       div {
         grid-column: 2;
         padding-left: 1em;
         padding-right: 1em;
       }

       h2 {
         margin-bottom: 0;
       }

       p {
         margin-top: 0;
         margin-bottom: 0;
         padding: 0;
         font-weight: 200;
         font-size: 1.3em;
         height: 1.5em;
         font-variant-caps: small-caps;
       }


       ul {
         padding-left: 0;
         list-style-type: none;
       }

       strong {
         font-family: monospace;
       }

      </style>



    #+end_src
*** EndpointCoverageStats
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/EndpointCoverageStats.svelte
    :END:
    #+NAME: EndpointStats
    #+begin_src web
      <script>
       import { endpointCoverage } from '../stores';
       import Icon from 'fa-svelte';
       import { faCheckCircle } from '@fortawesome/free-solid-svg-icons/faCheckCircle';
       import TestTagsList from './TestTagsList.svelte';

       let checkmark = faCheckCircle;

       $: ({
         operation_id,
         tested,
         confTested,
         description,
         path,
         group,
         version,
         kind
       } = $endpointCoverage);
      </script>


      <div id='coverage-stats'>
        <p class='path'>{path}</p>
        <h2>{operation_id}</h2>

        <dl id='endpoint-details'>
          <dt>description</dt><dd>{description}</dd>
          {#if group}<dt>group</dt><dd>{group}</dd>{/if}
          {#if version}<dt>version</dt><dd>{version}</dd>{/if}
          {#if kind}<dt>kind</dt><dd>{kind}</dd>{/if}
        </dl>

        {#if tested}
        <p class='stat'> <span><Icon class='success check' icon={checkmark} /></span> Tested!</p>
        {:else}
        <p class='stat'> <span><Icon class='check fail' icon={checkmark} /></span> Untested</p>
        {/if}

        {#if confTested}
        <p class='stat'> <span><Icon class='check success' icon={checkmark} /></span> Conformance Tested</p>
        {:else}
        <p class='stat'> <span><Icon class='check fail' icon={checkmark} /></span> No Conformance Tests</p>
        {/if}

        <TestTagsList />

      </div>

      <style>
       div#coverage-stats {
         grid-column: 2;
         padding-left: 1em;
         padding-right: 1em;
       }

       h2 {
         margin-bottom: 1em;
       }

       p.path {
         margin-top: 0;
         margin-bottom: 0;
         padding: 0;
         font-weight: 200;
         font-size: 1.3em;
         font-variant-caps: small-caps;
       }

       p.stat {
         display: flex;
         align-items: center;
         font-size: 1.3em;
         margin: 0;
         font-style: italic;
         font-weight: 200;
       }

       div :global(.check) {
         font-size: 1.3em;
         padding-right: 0.25em;
         margin-top: 0.1em;
       }
       div :global(.success) {
         color: rgba(60, 180, 75, 1);
       }

       div :global(.fail) {
         color: rgba(233, 233, 233, 1);
       }

       dl {
         display: grid;
         font-size: 0.85em;
         grid-template-columns: 5rem 1fr;
         grid-template-rows: 1fr 1fr 1fr;
         width: 90%;
       }

       dt {
         border: 1px solid black;
         border-top: none;
         border-right: none;
         display: flex;
         justify-content: center;
         align-items: center;
         padding: 0;
         margin: 0;
         background: #CCCCCC;
       }

       dd {
         border: 1px solid black;
         border-top: none;
         display: inloine;
         padding: 0;
         padding-left: 1em;
         margin: 0;
         font-family: monospace;
       }

       dt:first-of-type , dd:first-of-type {
         border-top: 1px solid black;
       }






      </style>


    #+end_src
    
*** TestTagsList
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/TestTagsList.svelte
    :END:
    #+begin_src web
      <script>
       import {
         activeFilters,
         testTagsForEndpoint
       } from '../stores';
       import { goto, stores } from '@sapper/app';
       import { updateQueryParams } from '../lib/helpers.js';

       const { page} = stores();

       function handleClick (tag) {
         let queryParams = updateQueryParams($page, {test_tags: [tag]});
         let url = `${$page.path}${queryParams}#tests`;

         activeFilters.update(af => ({...af, test_tags: [tag]}))
         document.getElementById('tests').scrollIntoView();

         goto(url)
           .then(() => {
             document.getElementById('tests').scrollIntoView();
           });
       };
      </script>


      {#if $testTagsForEndpoint.length > 0}
      <div id='test-tags'>
        <ul>
          {#each $testTagsForEndpoint as testTag}
          <li role='button' on:click={() => handleClick(testTag)}>{testTag}</li>
          {/each}
        </ul>
      </div>
      {/if}


      <style>
       li {
         cursor: pointer;
       }
      </style>


    #+end_src
*** Tests List
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/TestsList.svelte
    :END:
    
    #+begin_src web
<script>
 import { 
        activeFilters,
        breadcrumb,
        testsForEndpoint,
        testTagsForEndpoint,
        filteredTests
 } from '../stores';
 import { goto, stores } from '@sapper/app';
 import { updateQueryParams } from '../lib/helpers.js';
 import { isEmpty} from 'lodash-es';

 const { page } = stores();


 $: isActiveTag = (tag) => $activeFilters.test_tags.includes(tag);
 $: endpoint = $breadcrumb[2] || 'this Endpoint';

 function toggleFilter (tag) {
     let testTags = $activeFilters.test_tags;
     let activeFilter = isActiveTag(tag);
     testTags = activeFilter
                  ? testTags.filter(t => t !== tag)
                  : testTags.concat(tag);
     let queryParams = updateQueryParams($page, {test_tags: [...testTags]});
     let url = `${$page.path}${queryParams}#tests`;
     activeFilters.update(af => ({...af, test_tags: testTags}))
     document.getElementById('tests').scrollIntoView();
     goto(url)
         .then(() => {
             document.getElementById('tests').scrollIntoView();
         });
 };

</script>

{#if $testsForEndpoint.length > 0 }
    <div id='tests'>
        <h2>Tests for {$breadcrumb[2]}</h2>
        <div class='tag-filter'>
        <p>filter by test tag:</p>
        <ul>
        {#each $testTagsForEndpoint as testTag}
        <li class:active={isActiveTag(testTag)} on:click={() => toggleFilter(testTag)}>{testTag}</li>
        {/each}
        </ul>
        </div>
        <ul id='tests'>
            {#each $filteredTests as fTest}
                <li>{fTest.test}</li>
            {/each}
        </ul>
    </div>
{/if}


<style>

 div#tests {
     min-height: 100vh;
 }

 div.tag-filter {
     padding: 0.55em;
     border: 1px solid #cccccc;
     font-size: 0.9em;
 }

 div.tag-filter p {
     font-variant-caps: small-caps;
     font-weight: 800;
 }

 div.tag-filter ul {
     display: flex;
     flex-wrap: wrap;
     list-style-type: none;
     padding-left: 0;
 }

 div.tag-filter li {
     margin: 0.25em;
     background: #f4f4f4;
     cursor: pointer;
     font-weight: 200;
 }

 div.tag-filter li.active {
     font-weight: 500;
     background: #96ccff;
     color: #001B44;
 }
</style>


    
    #+end_src
*** Section Header
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/SectionHeader.svelte
    :END:
    This is to set consistent styling and spacing for each part of our homepage 
    I will be an h2 tag with particular styling, plus slots for explanatory text and timestamps and what not.
    #+NAME: Section Header
    #+begin_src web 
      <script>
      export let title;
      </script>

      <header>
        <h2>{title}</h2>
        <slot></slot>
      </header>

      <style>
       h2 {
         font-size: 1.66rem;
         font-weight: 300;
         margin: 0;
         padding: 0;
       }
      </style>
    #+end_src
    
    
    
** Queries
   :PROPERTIES:
   :header-args: :tangle ./app/src/queries/index.js
   :END:
   These are graphql queries to our postgres db.  At this moment, there is not alot of graphql magic going on, they map pretty direct to the underlying postgres sql statement.
   
   We use apollo boost for our graphql connection
   
   #+NAME: import apollo-boost
   #+begin_src js
     import { gql } from 'apollo-boost';

   #+end_src
   
*** Endpoints Tests and Useragents
    #+NAME: ENDPOINTS_TESTS_AND_USERAGENTS
    #+begin_src js
      export const ENDPOINTS_TESTS_AND_USERAGENTS = gql`
      query ENDPOINTS_TESTS_AND_USERAGENTS($bucket: String, $job: String) {
        endpoints: endpoint_coverage(where: {bucket: {_eq: $bucket}, job: {_eq: $job}}) {
          operation_id
          level
          category
          conf_tested
          tested
          hit
          details {
            description
            path
            k8s_group
            k8s_kind
          }
        }
        tests(where: {bucket: {_eq: $bucket}, job: {_eq: $job}}) {
          test
          test_tags
          operation_ids
        }
        useragents(where: {bucket: {_eq: $bucket}, job: {_eq: $job}}) {
          useragent
          operation_ids
        }
      }
      `
    #+end_src
*** All Buckets and Jobs, Sans Live    
    #+NAME: ALL_BUCKETS_AND_JOBS_SANS_LIVE
    #+begin_src js
      // All buckets and jobs available in db that are not 'live'
      export const ALL_BUCKETS_AND_JOBS_SANS_LIVE = gql`
      {
        bucket_job_swagger(where: {bucket: {_neq: "apisnoop"}}) {
          bucket
          job
          job_timestamp
        }
      }
      `;
    #+end_src
*** Stable Endpoint Stats    
    #+NAME: STABLE_ENDPOINT_STATS
    #+begin_src js
      export const STABLE_ENDPOINT_STATS = gql`
      query STABLE_ENDPOINT_STATS {
        stable_endpoint_stats(where: {job: {_neq: "live"}}) {
          conf_hits
          conf_hits_increase
          date
          job
          percent_conf_tested
          percent_conf_tested_increase
          percent_tested
          percent_tested_increase
          release
          test_hits
          test_hits_increase
          total_endpoints
        }
      }
      `;
    #+end_src
** Stores
*** index
    :PROPERTIES:
    :header-args: :tangle ./app/src/stores/index.js
    :END:
    #+NAME: stores/index
    #+begin_src js
      import { writable, derived } from 'svelte/store';
      import client from '../apollo.js';
      import {
        hitByMatchingItems,
        hitByMatchingTestTags,
        isValidRegex,
        toBoolean
      } from '../lib/helpers.js';

      import {
        compact,
        concat,
        isArray,
        isEmpty,
        flattenDeep,
        groupBy,
        intersection,
        keyBy,
        map,
        mapValues,
        orderBy,
        sortBy,
        take,
        uniq
      } from 'lodash-es';

      import {
        levelColours,
        categoryColours,
        endpointColour
      } from '../lib/colours.js';

      // Based on url query params, any filters being set.
      export const activeFilters = writable({
        test_tags: [],
        hide_tested: "false",
        hide_conf_tested: "false",
        hide_untested: "false",
        useragent: '',
        tests_match: '',
        test_tags_match: '',
        bucket: '',
        job: '',
        level: '',
        category: '',
        operation_id: ''
      })

      export const mouseOverPath = writable([]);
      export const stableEndpointStats = writable([]);

      export const breadcrumb = derived(
        [activeFilters, mouseOverPath],
        ([$active, $mouse], set) => {
          let mouseCrumbs = $mouse.map(m => m.data.name);
          let activeAndMouseCrumbs = compact(uniq([$active.level, $active.category, $active.operation_id, ...mouseCrumbs]));
          let crumbs = [];
          // if length is 4, it means we are zoomed into an endpoint, and hovering over a different endpoint.
          if (activeAndMouseCrumbs.length === 4) {
            // if that's the case, we want to show the one we are hovered on.
            crumbs = activeAndMouseCrumbs.filter(crumb => crumb !== $active.operation_id);
          } else {
            crumbs = take(compact(uniq([$active.level, $active.category, $active.operation_id, ...mouseCrumbs])), 3);
          }
          set(crumbs)
        }
      );

      export const warnings = writable({
        invalidBucket: false,
        invalidJob: false,
        invalidLevel: false,
        invalidCategory: false,
        invalidEndpoint: false
      })

      // Buckets and Jobs
      export const rawBucketsAndJobs = writable([]);

      export const bucketsAndJobs = derived(
        rawBucketsAndJobs,
        ($raw, set) => {
          if ($raw.length === 0) {
            set([]);
          } else {
            let buckets = groupBy($raw, 'bucket');
            let bjs = mapValues(buckets, (allJobs) => {
              let jobs = allJobs
                  .sort((a,b) => new Date(b.job_timestamp) > new Date(a.job_timestamp))
                  .map(j => ({
                    job: j.job,
                    timestamp: j.job_timestamp
                  }));

              let [latestJob] = jobs;

              return {
                latestJob,
                jobs
              };
            });
            set(bjs);
          };
        }
      );

      export const defaultBucketAndJob = derived(
        bucketsAndJobs,
        ($bjs, set) => {
          if ($bjs.length === 0) {
            set({
              bucket: '',
              job: '',
              timestamp: ''
            });
          } else {
            let releaseBlocking = 'ci-kubernetes-e2e-gci-gce';
            let defaultBucket = Object.keys($bjs).includes(releaseBlocking)
                ? releaseBlocking
                : Object.keys($bjs)[0];

            set({
              bucket: defaultBucket,
              job: $bjs[defaultBucket].latestJob.job,
              timestamp: $bjs[defaultBucket].latestJob.job_timestamp
            });
          };
        }
      );

      export const activeBucketAndJob = derived(
        [activeFilters, defaultBucketAndJob, bucketsAndJobs],
        ([$filters, $default, $all], set) => {
          let base = {
            bucket: '',
            job: '',
            timestamp: ''
          };
          if ($default.bucket === '') {
            set({...base});
          } else if ($filters.bucket === '') {
            set({
              ...base,
              bucket: $default.bucket,
              job: $default.job,
              timestamp: $default.timestamp
            });
          } else {
            let timestamp = $all[$filters.bucket]['jobs'].find(job => job.job === $filters.job)['timestamp'];
            set({
              ...base,
              bucket: $filters.bucket,
              job: $filters.job,
              timestamp: timestamp
            });
          };
        });

      // All our data, for the active bucket and job. 
      export const endpointsTestsAndUseragents = writable({endpoints: '', tests: '', useragents: ''});
      export const endpoints = derived(endpointsTestsAndUseragents, $etu => $etu.endpoints);
      export const allTestsAndTags = derived(endpointsTestsAndUseragents, $etu => $etu.tests);
      export const allUseragents = derived(endpointsTestsAndUseragents, $etu => $etu.useragents);
      // Based on the url params, the exact [level, category, endpoint] we are focused on.
      export const activePath = writable([]);

      export const opIDs = derived(endpoints, ($ep, set) => {
        if ($ep.length > 0) {
          set(keyBy($ep, 'operation_id'));
        } else {
          set([]);
        }
      });

      export const filteredEndpoints = derived(
        [activeFilters, endpoints, allUseragents, allTestsAndTags],
        ([$af, $ep, $ua, $tt], set) => {
          if ($ep.length === 0) {
            set([]);
          } else {
            let endpoints = $ep
                .filter(ep => toBoolean($af.hide_tested) ? (ep.tested === false || ep.conf_tested === true) : ep)
                .filter(ep => toBoolean($af.hide_conf_tested) ? ep.conf_tested === false : ep)
                .filter(ep => toBoolean($af.hide_untested) ? ep.tested === true : ep)
                .filter(ep => ($af.useragent.length > 0 && isValidRegex($af.useragent) && $ua)
                        ? hitByMatchingItems($ua, 'useragent', $af.useragent, ep)
                        : ep)
                .filter(ep => ($af.tests_match.length > 0 && isValidRegex($af.tests_match) && $tt)
                        ? hitByMatchingItems($tt, 'test', $af.tests_match, ep)
                        : ep)
                .filter(ep => ($af.test_tags_match.length > 0 && isValidRegex($af.test_tags_match) && $tt)
                        ? hitByMatchingTestTags($tt, $af.test_tags_match, ep)
                        : ep);
            set(endpoints)
          }
        });

      export const groupedEndpoints = derived(filteredEndpoints, ($ep, set) => {
        if ($ep.length > 0) {
          let endpointsByLevel = groupBy($ep, 'level')
          set(mapValues(endpointsByLevel, endpointsInLevel => {
            let endpointsByCategory = groupBy(endpointsInLevel, 'category')
            return mapValues(endpointsByCategory, endpointsInCategory => {
              return endpointsInCategory.map (endpoint => {
                return {
                  ...endpoint,
                  name: endpoint.operation_id,
                  value: 1,
                  color: endpointColour(endpoint)
                };
              });
            });
          }));
        } else {
          set({});
        }
      });


      export const sunburst = derived(groupedEndpoints, ($gep, set) => {
        if (!isEmpty($gep)) {
          var sunburst = {
            name: 'root',
            color: 'white',
            children: map($gep, (endpointsByCategoryAndOpID, level) => {
              return {
                name: level,
                color: levelColours[level] || levelColours['unused'],
                level: level,
                category: '',
                operation_id: '',
                children: map(endpointsByCategoryAndOpID, (endpointsByOpID, category) => {
                  return {
                    name: category,
                    level: level,
                    category: category,
                    operation_id: '',
                    color: categoryColours[category] ||  'rgba(183, 28, 28, 1)', // basic color so things compile right.
                    children: sortBy(endpointsByOpID, [
                      (endpoint) => endpoint.testHits > 0,
                      (endpoint) => endpoint.conformanceHits > 0
                    ])
                  };
                })
              };
            })
          };
          sunburst.children = orderBy(sunburst.children, 'name', 'desc');
          set(sunburst)
        } else {
          set({})
        }
      });

      export const zoomedSunburst = derived(
        [sunburst, activeFilters],
        ([$sunburst, $filters], set) => {
          let level = $filters.level;
          let category = $filters.category
          if (category) {
            let sunburstAtLevel = $sunburst.children.find(child => child.name === level);
            let sunburstAtCategory = sunburstAtLevel.children.find(child => child.name === category);
            set(sunburstAtCategory);
          } else if (!category && level) {
            let sunburstAtLevel = $sunburst.children.find(child => child.name === level);
            set(sunburstAtLevel);
          } else {
            set($sunburst)
          }
        })

      export const currentDepth = derived(breadcrumb, ($breadcrumb, set) => {
        let depths = ['root', 'level', 'category', 'endpoint']
        let depth = $breadcrumb.length;
        set(depths[depth])
      });

      export const coverageAtDepth = derived([breadcrumb, currentDepth, filteredEndpoints], ([$bc, $depth, $eps], set) => {
        let eps;
        if (isEmpty($eps)) {
          set({})
          return;
        } else if ($bc.length === 0) {
          eps = $eps;
        } else if ($bc.length === 1) {
          eps = $eps.filter(ep => ep.level === $bc[0])
        } else if ($bc.length === 2) {
          eps = $eps.filter(ep => ep.level === $bc[0] && ep.category === $bc[1])
        } else if ($bc.length === 3) {
          eps = $eps.filter(ep => ep.level === $bc[0] && ep.category === $bc[1] && ep.operation_id === $bc[2])
        } else {
          eps = $eps;
        }
        let totalEndpoints = eps.length;
        let testedEndpoints = eps.filter(ep => ep.tested).length;
        let confTestedEndpoints = eps.filter(ep => ep.conf_tested).length;
        set({
          totalEndpoints,
          testedEndpoints,
          confTestedEndpoints
        });
      });

      export const endpointCoverage = derived([breadcrumb, currentDepth, filteredEndpoints], ([$bc, $cd, $eps], set) => {
        let endpoint;
        let opId;
        let defaultCoverage = {
          tested: '',
          operation_id : '',
          confTested: '',
          description: '',
          path: '',
          group: '',
          version: '',
          kind: ''
        };
        if (isEmpty($eps) || $cd !== 'endpoint') {
          set(defaultCoverage);
        } else {
          opId = $bc[2]
          endpoint = $eps.find(ep => ep.operation_id === opId)
          let {
            tested,
            conf_tested: confTested,
            operation_id,
            details : {
              path,
              description,
              k8s_group: group,
              k8s_version: version,
              k8s_kind: kind
            }
          } = endpoint;
          set({
            tested,
            confTested,
            operation_id,
            path,
            description,
            group,
            version,
            kind
          });
        }
      });

      export const testsForEndpoint = derived(
        [allTestsAndTags, breadcrumb, currentDepth],
        ([$tt, $ap, $cd], set) => {
          if (isEmpty($tt) || $cd !== 'endpoint') {
            set([]);
          } else {
            let opID = $ap[2];
            let tests = $tt
                .filter(t => t.operation_ids.includes(opID))
            set(tests);
          }
        }
      );


      export const testTagsForEndpoint = derived(
        [allTestsAndTags, breadcrumb, currentDepth],
        ([$tt, $ap, $cd], set) => {
          if (isEmpty($tt) || $cd !== 'endpoint') {
            set([]);
          } else {
            let opID = $ap[2];
            let testTags = $tt
                .filter(t => t.operation_ids.includes(opID))
                .map(t => t.test_tags);
            let testTagsUniq = uniq(flattenDeep(testTags))
            set(testTagsUniq);
          }
        }
      );

      export const validTestTagFilters = derived(
        [activeFilters, testTagsForEndpoint],
        ([$af, $tt], set) => {
          if ($af.test_tags.length === 0 || $tt.length === 0) {
            set([]);
          } else {
            let validFilters = isArray($af.test_tags)
                ? $af.test_tags.filter(f => $tt.includes(f))
                : [$af.test_tags].filter(f => $tt.includes(f));
            set(validFilters);
          }
        });

      export const filteredTests = derived(
        [testsForEndpoint, validTestTagFilters],
        ([$t, $vf]) => {
          let tests;
          if ($vf.length === 0) {
            tests = $t; 
          } else {
            tests = $t.filter(test => {
              return intersection(test.test_tags, $vf).length > 0;
            });
          }
          return tests;
        });


    #+end_src
*** CoverageOverTime
    :PROPERTIES:
    :header-args: :tangle ./app/src/stores/coverage-over-time.js
    :END:
    #+NAME: coverage-over-time.js
    #+begin_src js
      import dayjs from 'dayjs';
      import { derived }  from 'svelte/store';
      import {
        findKey,
        flatten,
        sortBy
      } from 'lodash-es';
      import {
        bucketsAndJobs,
        defaultBucketAndJob,
        stableEndpointStats
      } from './index.js';


      export const dates = derived(
        [bucketsAndJobs, defaultBucketAndJob],
        ([$bjs, $default], set) => {
          if ($bjs.length === 0) {
            set([])
          } else {
            // let bucket = $default.bucket;
            let buckets = Object.keys($bjs);
            let allJobs = buckets.reduce((acc, cur) => {
              let jobs = sortBy($bjs[cur]['jobs'], 'timestamp');
              return [...acc, ...jobs];
            }, []);

            allJobs = sortBy(allJobs,'timestamp');
            set(allJobs.map(job => job.timestamp));
          }
        }
      );

      export const coverage = derived(
        [defaultBucketAndJob, stableEndpointStats, bucketsAndJobs],
        ([$default, $stats, $bjs], set) => {
          if ($default.bucket === '') {
            set([]);
          } else {
            let coverageStats = $stats
                .filter(stat => stat.job !== 'live')
                .map(stat => {
                  let bucket = findKey($bjs, (o) => o.jobs.map(job => job.job).includes(stat.job))
                  return {
                    ...stat,
                    bucket,
                    timestamp: dayjs(stat.date)
                  };
                });
            coverageStats = sortBy(coverageStats, 'timestamp');
            set(coverageStats);
          }
        }
      );



    #+end_src
** Utility Functions (/lib/)
*** helpers
    :PROPERTIES:
    :header-args: :tangle ./app/src/lib/helpers.js
    :END:
   #+NAME: helpers
   #+begin_src js
     import {
       forEach,
       trimEnd,
       groupBy,
       mapValues,
       trimStart,
       flatten,
       uniq
     } from 'lodash-es';

     export const updateQueryParams = (page, query) => {
       // given a sapper page store, and new queries
       // construct a url string with old and new queries.
       let newQueries = {
         ...page.query,
         ...query
       };

       let queryStrings = {};
       forEach(newQueries, (v, k) => {
         queryStrings[k] = trimStart(v.reduce((acc, cur) => `${acc}${k}=${cur}&`, ''), '&');
       });

       let queryNames = Object.keys(queryStrings);
       let fullQueryString = trimEnd(queryNames.reduce((acc, cur) => `${acc}${queryStrings[cur]}`, '?'), '&');
       return fullQueryString;
     };

     export const toBoolean = (str) => {
       str = str.toString().toLowerCase();
       let truths = ["true", "t", "yes", "1", "truth"]
       return truths.includes(str)
     }

     export const isValidRegex = (regex) => {
       try {
         new RegExp(regex);
       } catch (e) {
         return false;
       }
       return true;
     };

     export const hitByMatchingItems = (items, key,  regex, endpoint) => {
       // given an array of objects, items, a key to compare, and the regex to match.
       // return true if endpoint is hit by any item whose key value matches the regex.
       regex = new RegExp(regex);
       let matchingItems = items.filter(ua => regex.test(ua[key]));
       let endpointsHitByItems = uniq(flatten(matchingItems.map(item => item.operation_ids)));
       return endpointsHitByItems.includes(endpoint.operation_id);
     };

     export const hitByMatchingTestTags = (tests, regex, endpoint) => {
       // given an array of tests, each containing an array of test_tags, and the regex to match.
       // filter tests by those with at least one tag that matches regex filter.
       // return true if endpoint is hit by any of these filtered tests.
       regex = new RegExp(regex);
       let matchingTests = tests.filter(test => test.test_tags.some((tag) => regex.test(tag)));
       let endpointsHitByTests = uniq(flatten(matchingTests.map(test => test.operation_ids)));
       return endpointsHitByTests.includes(endpoint.operation_id);
     };

     export const determineBucketAndJob = (bucketsAndJobs, bucketParam, jobParam) => {
       let bucket;
       let job;
       let buckets = groupBy(bucketsAndJobs, 'bucket');
       let bj = mapValues(buckets, (allJobs) => {
         let jobs = allJobs
             .sort((a,b) => new Date(b.job_timestamp) > new Date(a.job_timestamp))
             .map(j => ({job: j.job, timestamp: j.job_timestamp}));
         let [latestJob] = allJobs.map(j => ({job: j.job, timestamp: j.job_timestamp}));
         return {
           latestJob,
           jobs
         };
       });

       let releaseBlocking = 'ci-kubernetes-e2e-gci-gce';
       let defaultBucket = Object.keys(bj).includes(releaseBlocking)
           ? releaseBlocking
           : Object.keys(bj)[0];
       let defaultJob = bj[defaultBucket]['latestJob'].job;

       if (!bucketParam) {
         bucket = defaultBucket;
         job = defaultJob;
       } else if (bucketParam && !jobParam) {
         bucket = isValidBucket(bucketParam, bj)
           ? bucketParam
           : defaultBucket;
         job = bj[bucket]['latestJob'].job
       } else {
         bucket = isValidBucket(bucketParam, bj)
           ? bucketParam
           : defaultBucket;
         job = isValidJob(bj[bucket], jobParam)
           ? jobParam
           : bj[bucket]['latestJob'].job
       }
       return {
         bucket,
         job
       };
     }

     function isValidBucket (bucket, bjs) {
       return Object.keys(bjs).includes(bucket);
     }

     function isValidJob  (bucket, job) {
       let jobs = bucket.jobs.map(job => job.job);
       return jobs.includes(job);
     }

   #+end_src
**** releasePrecision
     #+NAME: releasePrecision
     #+begin_src js
       // SemverString Number -> SemVerString
       // SemverString : Numbers separated by points, representing a software release
       // Given SemverString s and number n, return string of n level specificity
       export const releasePrecision = (s , n) => s.split('.').slice(0,n).join('.');
     #+end_src
** Routes
** Stores
** Queries
** Utility Functions (lib)
** Components
* Building the App
** Dockerfile
#+begin_src dockerfile :tangle ./app/Dockerfile
FROM node:slim

RUN addgroup --system --gid 1001 appuser \
    &&  adduser --system --uid 1001 --ingroup appuser appuser

COPY . /webapp

RUN chown -R appuser:appuser /webapp

USER appuser

WORKDIR /webapp

RUN npm install

EXPOSE 3000
# EXPOSE 10000

# RUN npm run build
# USER root

# CMD ["npm", "start"]
CMD ["npm", "run", "dev"]
#+end_src

** cloudbuild.yaml
#+begin_src yaml :tangle ./app/cloudbuild.yaml
steps:
  - name: gcr.io/cloud-builders/docker
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/webapp:$_GIT_TAG',
           '--build-arg', 'IMAGE_ARG=gcr.io/$PROJECT_ID/webapp:$_GIT_TAG',
           '.']
substitutions:
  _GIT_TAG: '12345'
images:
  - 'gcr.io/$PROJECT_ID/webapp:$_GIT_TAG'
options:
  substitution_option: 'ALLOW_LOOSE'
#+end_src

* Deployment
** deployment.yaml
#+begin_src yaml :tangle ./deployment/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  replicas: 1
  selector:
    matchLabels:
      io.apisnoop.webapp: webapp
  template:
    metadata:
      labels:
        io.apisnoop.webapp: webapp
    spec:
      restartPolicy: Always
      containers:
      - name: webapp
        image: "gcr.io/k8s-staging-apisnoop/webapp:v20200211-0.9.34-1-g24cf96f"
        ports:
        - containerPort: 3000
#+end_src

** ingress.yaml
#+begin_src yaml :tangle ./deployment/ingress.yaml
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: webapp-ingress
  annotations:
    nginx.ingress.kubernetes.io/server-alias: "apisnoop.local.ii.coop, apisnoop.local.ii.nz, apisnoop.local.sharing.io"
  # annotations:
  #   nginx.ingress.kubernetes.io/app-root: /
  # annotations:
  #   nginx.ingress.kubernetes.io/rewrite-target: /$2
spec:
  rules:
  - host: apisnoop.localho.st
    http:
      paths:
      - path: /
        backend:
          serviceName: webapp
          servicePort: 3000
#+end_src

** kustomization.yaml
#+begin_src yaml :tangle ./deployment/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
  - deployment.yaml
  - service.yaml
  - ingress.yaml
# TODO set ingress to apisnoop.local.sharing.io 
#+end_src

** service.yaml
#+begin_src yaml :tangle ./deployment/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: webapp
spec:
  selector:
    io.apisnoop.webapp: webapp
  ports:
  - name: "3000"
    port: 3000
    targetPort: 3000
#+end_src

* Footnotes
** Scratch sql
   #+begin_src sql-mode
   select bucket from bucket_job_swagger; 
   #+end_src

   #+RESULTS:
   #+begin_src sql-mode
             bucket           
   ---------------------------
    ci-kubernetes-e2e-gci-gce
    apisnoop
   (2 rows)

   #+end_src
