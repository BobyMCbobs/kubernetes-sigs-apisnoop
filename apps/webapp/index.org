#+TITLE: Webapp Code, Deployment, and Reference Materials
#+TODO: TODO(t) IN-PROGRESS(i) WAITING(w) | DONE(d)

* Introduction 
  A web display for APIsnoop data, given from an APIsnoop GraphQL API.
* App Src
  :PROPERTIES:
  :header-args: :dir './app/src/'
  :END:
** Sapper Plumbing 
   There's a number of files necessary for any sapper project that ties to a graphql endpoint.  We don't do much with them, but they ensure the site actually runs.
*** client.js
    #+NAME: client.js
    #+begin_src js :tangle ./app/src/client.js
      import * as sapper from '@sapper/app';

      sapper.start({
          target: document.querySelector('#sapper')
      });
    #+end_src
*** server.js
    #+NAME: server.js
    #+begin_src js :tangle ./app/src/server.js
      import sirv from 'sirv';
      import polka from 'polka';
      import compression from 'compression';
      import * as sapper from '@sapper/server';

      const { PORT, NODE_ENV } = process.env;
      const dev = NODE_ENV === 'development';

      polka() // You can also use Express
        .use(
          compression({ threshold: 0 }),
          sirv('static', { dev }),
          sapper.middleware()
        )
        .listen(PORT, err => {
          if (err) console.log('error', err);
        });
    #+end_src
*** apollo.js
    Apollo connects our app to our graphql endpoint.  The app is designed to be run in cluster, so the endpoint is to the in-cluster address for hasura
    #+NAME: apollo.js
    #+begin_src js :tangle ./app/src/apollo.js
      import ApolloClient from 'apollo-boost';
      import fetch from 'node-fetch';

      const GQL_ENDPOINT = 'http://hasura:8080/v1/graphql'
      // const GQL_ENDPOINT = 'http://localhost/hasura/v1/graphql';

      export default new ApolloClient({
        uri: GQL_ENDPOINT,
        fetch: fetch
      });
    #+end_src
*** service-worker.js
    Stores assets and cache so site works well in intermittent internet
    #+NAME: service-worker.js
    #+begin_src js :tangle ./app/src/service-worker.js
      import { timestamp, files, shell, routes } from '@sapper/service-worker';

      const ASSETS = `cache${timestamp}`;

      // `shell` is an array of all the files generated by the bundler,
      // `files` is an array of everything in the `static` directory
      const to_cache = shell.concat(files);
      const cached = new Set(to_cache);

      self.addEventListener('install', event => {
        event.waitUntil(
          caches
            .open(ASSETS)
            .then(cache => cache.addAll(to_cache))
            .then(() => {
              self.skipWaiting();
            })
        );
      });

      self.addEventListener('activate', event => {
        event.waitUntil(
          caches.keys().then(async keys => {
            // delete old caches
            for (const key of keys) {
              if (key !== ASSETS) await caches.delete(key);
            }

            self.clients.claim();
          })
        );
      });

      self.addEventListener('fetch', event => {
        if (event.request.method !== 'GET' || event.request.headers.has('range')) return;

        const url = new URL(event.request.url);

        // don't try to handle e.g. data: URIs
        if (!url.protocol.startsWith('http')) return;

        // ignore dev server requests
        if (url.hostname === self.location.hostname && url.port !== self.location.port) return;

        // always serve static files and bundler-generated assets from cache
        if (url.host === self.location.host && cached.has(url.pathname)) {
          event.respondWith(caches.match(event.request));
          return;
        }

        // for pages, you might want to serve a shell `service-worker-index.html` file,
        // which Sapper has generated for you. It's not right for every
        // app, but if it's right for yours then uncomment this section
        /*
          if (url.origin === self.origin && routes.find(route => route.pattern.test(url.pathname))) {
          event.respondWith(caches.match('/service-worker-index.html'));
          return;
          }
        ,*/

        if (event.request.cache === 'only-if-cached') return;

        // for everything else, try the network first, falling back to
        // cache if the user is offline. (If the pages never change, you
        // might prefer a cache-first approach to a network-first one.)
        event.respondWith(
          caches
            .open(`offline${timestamp}`)
            .then(async cache => {
              try {
                const response = await fetch(event.request);
                cache.put(event.request, response.clone());
                return response;
              } catch(err) {
                const response = await cache.match(event.request);
                if (response) return response;

                throw err;
              }
            })
        );
      });

    #+end_src
** Template for our html files
   This is used to build out our basic html page in which the app blooms within the script.  If you want to add meta content to the head of each page, here is where you'd do it.
   #+NAME: template.html
   #+begin_src html :tangle ./app/src/template.html
     <!doctype html>
     <html>
       <head>
         <meta charset='utf-8'>
         <meta name='viewport' content='width=device-width,initial-scale=1.0'>
         <meta name='theme-color' content='#333333'>

         %sapper.base%

         <link rel='stylesheet' href='global.css'>
         <link rel='manifest' href='manifest.json'>
         <link rel='icon' type='image/png' href='favicon.png'>

         <!-- Sapper generates a <style> tag containing critical CSS
              for the current page. CSS for the rest of the app is
              lazily loaded when it precaches secondary pages -->
           %sapper.styles%

           <!-- This contains the contents of the <svelte:head> component, if
                the current page has one -->
             %sapper.head%
       </head>
       <body>
         <!-- The application will be rendered inside this element,
              because `src/client.js` references it -->
         <div id='sapper'>%sapper.html%</div>

         <!-- Sapper creates a <script> tag containing `src/client.js`
              and anything else it needs to hydrate the app and
              initialise the router -->
           %sapper.scripts%
       </body>
     </html>


   #+end_src
** Routes
*** index /
   The home page.  This should show a coverage over time graph and a sunburst beneath it, the sunburst being set to the latest job on sig-release-blocking.
**** index.json.js
     :PROPERTIES:
     :header-args: :tangle ./app/src/routes/index.json.js
     :END:
     #+NAME: index.json.js
     #+begin_src js 
       import client from "../apollo.js";
       import { determineBucketAndJob } from '../lib/helpers.js';
       import {
         ALL_BUCKETS_AND_JOBS_SANS_LIVE,
         STABLE_ENDPOINT_STATS } from '../queries';

       export async function get(req, res) {
         let bucketAndJobsQuery = await client.query({query: ALL_BUCKETS_AND_JOBS_SANS_LIVE});
         let rawBucketsAndJobsPayload = bucketAndJobsQuery.data.bucket_job_swagger;

         let statsQuery = await client.query({query: STABLE_ENDPOINT_STATS});
         let stableEndpointStatsPayload = statsQuery.data.stable_endpoint_stats;

         const payload = JSON.stringify({
           stableEndpointStatsPayload,
           rawBucketsAndJobsPayload
         });

         res.writeHead(200, {
           'Content-Type': 'application/json'
         });
         res.end(payload);
       }
     #+end_src
   
**** index.svelte
     :PROPERTIES:
     :header-args: :tangle ./app/src/routes/index.svelte
     :END:
     #+NAME: index.svelte
     #+begin_src web
       <script context="module">
        export function preload({ params, query }) {
          return this.fetch(`index.json`).then(r => r.json()).then(payload => {
            return { payload };
          });
        }
       </script>

       <script>
        import CoverageOverTime from '../components/CoverageOverTime.svelte'; 
        import { isEqual} from 'lodash-es';
        export let payload;
        import {
          stableEndpointStats,
          rawBucketsAndJobs,
        } from '../stores';

        rawBucketsAndJobs.update(raw => isEqual(raw, payload.rawBucketsAndJobsPayload)
                                      ? raw
                                      : payload.rawBucketsAndJobsPayload);

        stableEndpointStats.update(stats => isEqual(stats, payload.stableEndpointStatsPayload)
                                          ? stats
                                          : payload.stableEndpointStatsPayload);
       </script>

       <svelte:head>
         <title>APISnoop</title>
       </svelte:head>
       <CoverageOverTime />
       <h1>You got a webpage</h1>


     #+end_src
     
*** [...params]
**** [...index].json.js
     :PROPERTIES:
     :header-args: :tangle ./app/src/routes/[...index].json.js
     :END:
     #+NAME: [...index].json.js
     #+begin_src js 
       import client from "../apollo.js";
       // import { determineBucketAndJob } from '../lib/helpers.js';
       // import { ALL_BUCKETS_AND_JOBS_SANS_LIVE, STABLE_ENDPOINT_STATS } from '../queries';

       export async function get(req, res) {
         // let bucketAndJobsQuery = await client.query({query: ALL_BUCKETS_AND_JOBS_SANS_LIVE});
         // let statsQuery = await client.query({query: STABLE_ENDPOINT_STATS});
         // let rawBucketsAndJobsPayload = bucketAndJobsQuery.data.bucket_job_swagger;
         // let stableEndpointStatsPayload = statsQuery.data.stable_endpoint_stats;
         // let statsAndBucketsAndJob = {stableEndpointStatsPayload, rawBucketsAndJobsPayload}
         let params = req.params.index;
         const payload = JSON.stringify(params);

         res.writeHead(200, {
           'Content-Type': 'application/json'
         });
         res.end(payload);
       }
     #+end_src
     
   
    
**** [...index].svelte
     :PROPERTIES:
     :header-args: :tangle ./app/src/routes/[...index].svelte
     :END:
     
    #+NAME: [...index].svelte
    #+begin_src web
      <script context="module">
       import { join } from 'lodash-es';
       export function preload ({ params, query }) {
         let path = join(params.coverage, '/');
         return this
           .fetch(`/${path}.json`)
           .then(r => r.json())
           .then(payload => ({ payload }));
       };
      </script>

      <script>
       import { onMount, afterUpdate } from 'svelte';
       export let payload;

       onMount(() => console.log('mount', payload));
       afterUpdate(() => console.log('mount', payload));
      </script>

      <h1>Web Page is Getting There</h1>


    #+end_src
   We want to be able to have dynamic url routes that spring from home like '/bucket/job/stable'.  We also want to have all fetches of our data spring from the server instead of the client (as the client won't be able to access the endpoint if it is an internal k8s address).
   
   To facilitiate this, we build a small json api at the root which takes all requests, ddoes any data fetching ncessary, and returns an html page.  All of this will be done on the server, and the client only receives data from the server.

Sapper has a naming convention for files that if they are in brackets they are treated as dynamic, with the name in the brackets mapping to the url params.  So we name our files [...index] which lets us be able to go to a route like '/bucket/job/stable' and we'll get a url params in a list [bucket, job, stable].  Helpful!
** Components
*** CoverageOverTime.svelte
    :PROPERTIES:
    :header-args: :tangle ./app/src/components/CoverageOverTime.svelte
    :END:
    #+begin_src web 
      <script>
       import dayjs from 'dayjs';
       import { isEmpty } from 'lodash-es';
       import { scaleLinear, scaleTime } from 'd3-scale';
       import { afterUpdate } from 'svelte';
       import { prefetch, goto } from '@sapper/app';
       import {
         dates,
         coverage
       } from '../stores/coverage-over-time.js';
       import {
         bucketsAndJobs
       } from '../stores';

       const padding = { top: 20, right: 15, bottom: 20, left: 25 };
       // y is total percentage, from 0 to 100
       const yTicks = [0, 10, 20, 30, 40, 50, 60,70,80,90, 100];

       // Coverage is sorted by timestamp, with oldest at [0]
       // X ticks will be from oldest audit run to today.
       $: xTicks = [
         dayjs($coverage[0].timestamp).subtract(1, 'day'),
         dayjs().subtract(9, 'month'),
         dayjs().subtract(6, 'month'),
         dayjs().subtract(3, 'month'),
         dayjs()
       ];

       let width = 900;
       let height = 600;

       $: activeJob = {};
       $: minX = dayjs($dates[0]);
       $: maxX = dayjs($dates[$dates.length - 1]);
       $: xScale = scaleTime()
         .domain([minX, maxX])
         .range([padding.left, width - padding.right]);
       $: yScale = scaleLinear()
         .domain([Math.min.apply(null, yTicks), Math.max.apply(null, yTicks)])
         .range([height - padding.bottom, padding.top]);
       $: testedPath = `M${$coverage.map(c => `${xScale(c.timestamp)},${yScale(c.percent_tested)}`).join('L')}`;
       $: testedArea = `${testedPath}L${xScale(maxX)}, ${yScale(0)}L${xScale(minX)},${yScale(0)}Z`;
       $: confPath = `M${$coverage.map(c => `${xScale(c.timestamp)},${yScale(c.percent_conf_tested)}`).join('L')}`;
       $: confArea = `${confPath}L${xScale(maxX)}, ${yScale(0)}L${xScale(minX)},${yScale(0)}Z`;

       afterUpdate(()=> console.log({coverage: $coverage}));
      </script>

      <h1>Coverage Over Time</h1>

      <div class="chart" bind:clientWidth={width} bind:clientHeight={height}>
        <svg>
          <!-- y axis -->
          <g class='axis y-axis' transform="translate(0, {padding.top})">
            {#each yTicks as tick}
            <g class="tick tick-{tick}" transform="translate(0, {yScale(tick) - padding.bottom})">
              <line x2="100%"></line>
              <text y="-4">{tick} {tick === 100 ? ' percent' : ''}</text>
            </g>
            {/each}
          </g>
          <!-- x axis -->
          <g class="axis x-axis">
            {#each xTicks as tick}
            <g class="tick tick-{ tick}" transform="translate({xScale(tick)},{height})">
              <line y1="-{height}" y2="-{padding.bottom}" x1="0" x2="0"></line>
              <text y="-2">{dayjs(tick).format('DD MMM, YY')}</text>
            </g>
            {/each}
          </g>
          <path class='path-area' d={testedArea}></path>
          <path class='path-line' d={testedPath}></path>
          <path class='path-line conf' d={confPath}></path>
          <path class='path-area conf' d={confArea}></path>
          {#each $coverage as point}
          <circle
            cx='{xScale(point.timestamp)}'
            cy='{yScale(point.percent_tested)}'
            r='5'
            class='point'
            on:mouseover={() => {
            prefetch(`coverage/ci-kubernetes-e2e-gci-gce/${point.job}`)
            activeJob = point
            }}
            on:mouseleave={() => activeJob = {}}
            on:click={() => goto(`coverage/${point.bucket}/${point.job}`)}
          />
          <circle
            cx='{xScale(point.timestamp)}'
            cy='{yScale(point.percent_conf_tested)}'
            r='5'
            class='point conf'
            on:mouseover={() => {
            prefetch(`coverage/ci-kubernetes-e2e-gci-gce/${point.job}`)
            activeJob = point
            }}
            on:mouseleave={() => activeJob = {}}
            on:click={() => goto(`coverage/${point.bucket}/${point.job}`)}
          />
          {/each}
          {#if !isEmpty(activeJob)}
          <text
            transform="translate({width/2 + 50},{height - 100})"
            alignment-baseline="middle"
            text-anchor="middle"
            font-size="12"
          >
            <tspan x="0" dy=".6em">{dayjs(activeJob.date).format('DD MMM, YY')}</tspan>
            <tspan x= "0" dy="1.2em">{activeJob.total_endpoints} stable endpoints</tspan>
            <tspan x="0" dy="1.2em">{activeJob.percent_tested}% tested</tspan>
            <tspan x="0" dy="1.2em">{activeJob.percent_conf_tested}% conformance tested</tspan>
          </text>
          {/if}
        </svg>
      </div>

      <style>
       .chart, h2, p {
         max-width: 900px;
         margin-left: auto;
         margin-right: auto;
       }

       svg {
         position: relative;
         width: 100%;
         height: 450px;
         overflow: visible;
       }

       .tick {
         font-size: .725em;
         font-weight: 200;
       }

       .tick line {
         stroke: #aaa;
         stroke-dasharray: 2;
       }

       .tick text {
         fill: #666;
         text-anchor: start;
       }

       .tick.tick-0 line {
         stroke-dasharray: 0;
       }

       .x-axis .tick text {
         text-anchor: middle;
       }

       .path-line {
         fill: none;
         stroke: rgb(234,226,108);
         stroke-linejoin: round;
         stroke-linecap: round;
         stroke-width: 1;
       }

       .path-line.conf {
         stroke: rgb( 0, 100, 100);
       }

       .path-area {
         fill: rgba(234, 226, 108, 0.2);
       }

       .path-area.conf {
         fill: rgba(0, 100, 100, 0.2);
       }

       circle.point {
         fill: orange;
         fill-opacity: 0.6;
         stroke: rgba(0,0,0,0.5);
         cursor: pointer;
       }
       circle.point.conf {
         fill: green;
       }

       rect.tooltip {
         fill: white;
         stroke: black;
       }
      </style>

    #+end_src
*** Sunburst
** Queries
   :PROPERTIES:
   :header-args: :tangle ./app/src/queries/index.js
   :END:
   
   #+NAME: Queries
   #+begin_src js 
     import { gql } from 'apollo-boost';
     export const ENDPOINTS_USERAGENTS_AND_TESTS = gql`
     query ENDPOINTS_TESTS_AND_USERAGENTS($bucket: String, $job: String) {
       endpoints: endpoint_coverage(where: {bucket: {_eq: $bucket}, job: {_eq: $job}}) {
         operation_id
         level
         category
         conf_tested
         tested
         hit
         details {
           description
           path
           k8s_group
           k8s_kind
         }
       }
       tests(where: {bucket: {_eq: $bucket}, job: {_eq: $job}}) {
         test
         test_tags
         operation_ids
       }
       useragents(where: {bucket: {_eq: $bucket}, job: {_eq: $job}}) {
         useragent
         operation_ids
       }
     }
     `

     export const ENDPOINTS_TESTS_AND_USERAGENTS = gql`
     query ENDPOINTS_TESTS_AND_USERAGENTS($bucket: String, $job: String) {
       endpoints: endpoint_coverage(where: {bucket: {_eq: $bucket}, job: {_eq: $job}}) {
         operation_id
         level
         category
         conf_tested
         tested
         hit
         details {
           description
           path
           k8s_group
           k8s_kind
         }
       }
       tests(where: {bucket: {_eq: $bucket}, job: {_eq: $job}}) {
         test
         test_tags
         operation_ids
       }
       useragents(where: {bucket: {_eq: $bucket}, job: {_eq: $job}}) {
         useragent
         operation_ids
       }
     }
     `


     // All buckets and jobs available in db that are not 'live'
     export const ALL_BUCKETS_AND_JOBS_SANS_LIVE = gql`
     {
       bucket_job_swagger(where: {bucket: {_neq: "apisnoop"}}) {
         bucket
         job
         job_timestamp
       }
     }
     `;

     export const STABLE_ENDPOINT_STATS = gql`
     query STABLE_ENDPOINT_STATS {
       stable_endpoint_stats(where: {job: {_neq: "live"}}) {
         conf_hits
         date
         job
         percent_conf_tested
         percent_tested
         test_hits
         total_endpoints
       }
     }
     `;
   
   #+end_src
** Stores
*** index
    :PROPERTIES:
    :header-args: :tangle ./app/src/stores/index.js
    :END:
    #+NAME: stores/index
    #+begin_src js
      import { writable, derived } from 'svelte/store';
      import client from '../apollo.js';
      import {
        hitByMatchingItems,
        hitByMatchingTestTags,
        isValidRegex,
        toBoolean
      } from '../lib/helpers.js';

      import {
        compact,
        concat,
        isArray,
        isEmpty,
        flattenDeep,
        groupBy,
        intersection,
        keyBy,
        map,
        mapValues,
        orderBy,
        sortBy,
        take,
        uniq
      } from 'lodash-es';

      import {
        levelColours,
        categoryColours,
        endpointColour
      } from '../lib/colours.js';

      // Based on url query params, any filters being set.
      export const activeFilters = writable({
        test_tags: [],
        hide_tested: "false",
        hide_conf_tested: "false",
        hide_untested: "false",
        useragent: '',
        tests_match: '',
        test_tags_match: '',
        bucket: '',
        job: '',
        level: '',
        category: '',
        operation_id: ''
      })

      export const mouseOverPath = writable([]);
      export const stableEndpointStats = writable([]);

      export const breadcrumb = derived(
        [activeFilters, mouseOverPath],
        ([$active, $mouse], set) => {
          let mouseCrumbs = $mouse.map(m => m.data.name);
          let activeAndMouseCrumbs = compact(uniq([$active.level, $active.category, $active.operation_id, ...mouseCrumbs]));
          let crumbs = [];
          // if length is 4, it means we are zoomed into an endpoint, and hovering over a different endpoint.
          if (activeAndMouseCrumbs.length === 4) {
            // if that's the case, we want to show the one we are hovered on.
            crumbs = activeAndMouseCrumbs.filter(crumb => crumb !== $active.operation_id);
          } else {
            crumbs = take(compact(uniq([$active.level, $active.category, $active.operation_id, ...mouseCrumbs])), 3);
          }
          set(crumbs)
        }
      );

      export const warnings = writable({
        invalidBucket: false,
        invalidJob: false,
        invalidLevel: false,
        invalidCategory: false,
        invalidEndpoint: false
      })

      // Buckets and Jobs
      export const rawBucketsAndJobs = writable([]);

      export const bucketsAndJobs = derived(
        rawBucketsAndJobs,
        ($raw, set) => {
          if ($raw.length === 0) {
            set([]);
          } else {
            let buckets = groupBy($raw, 'bucket');
            let bjs = mapValues(buckets, (allJobs) => {
              let jobs = allJobs
                  .sort((a,b) => new Date(b.job_timestamp) > new Date(a.job_timestamp))
                  .map(j => ({
                    job: j.job,
                    timestamp: j.job_timestamp
                  }));

              let [latestJob] = jobs;

              return {
                latestJob,
                jobs
              };
            });
            set(bjs);
          };
        }
      );

      export const defaultBucketAndJob = derived(
        bucketsAndJobs,
        ($bjs, set) => {
          if ($bjs.length === 0) {
            set({
              bucket: '',
              job: '',
              timestamp: ''
            });
          } else {
            let releaseBlocking = 'ci-kubernetes-e2e-gci-gce';
            let defaultBucket = Object.keys($bjs).includes(releaseBlocking)
                ? releaseBlocking
                : Object.keys($bjs)[0];

            set({
              bucket: defaultBucket,
              job: $bjs[defaultBucket].latestJob.job,
              timestamp: $bjs[defaultBucket].latestJob.job_timestamp
            });
          };
        }
      );

      export const activeBucketAndJob = derived(
        [activeFilters, defaultBucketAndJob, bucketsAndJobs],
        ([$filters, $default, $all], set) => {
          let base = {
            bucket: '',
            job: '',
            timestamp: ''
          };
          if ($default.bucket === '') {
            set({...base});
          } else if ($filters.bucket === '') {
            set({
              ...base,
              bucket: $default.bucket,
              job: $default.job,
              timestamp: $default.timestamp
            });
          } else {
            let timestamp = $all[$filters.bucket]['jobs'].find(job => job.job === $filters.job)['timestamp'];
            set({
              ...base,
              bucket: $filters.bucket,
              job: $filters.job,
              timestamp: timestamp
            });
          };
        });

      // All our data, for the active bucket and job. 
      export const endpointsTestsAndUseragents = writable({endpoints: '', tests: '', useragents: ''});
      export const endpoints = derived(endpointsTestsAndUseragents, $etu => $etu.endpoints);
      export const allTestsAndTags = derived(endpointsTestsAndUseragents, $etu => $etu.tests);
      export const allUseragents = derived(endpointsTestsAndUseragents, $etu => $etu.useragents);
      // Based on the url params, the exact [level, category, endpoint] we are focused on.
      export const activePath = writable([]);

      export const opIDs = derived(endpoints, ($ep, set) => {
        if ($ep.length > 0) {
          set(keyBy($ep, 'operation_id'));
        } else {
          set([]);
        }
      });

      export const filteredEndpoints = derived(
        [activeFilters, endpoints, allUseragents, allTestsAndTags],
        ([$af, $ep, $ua, $tt], set) => {
          if ($ep.length === 0) {
            set([]);
          } else {
            let endpoints = $ep
                .filter(ep => toBoolean($af.hide_tested) ? (ep.tested === false || ep.conf_tested === true) : ep)
                .filter(ep => toBoolean($af.hide_conf_tested) ? ep.conf_tested === false : ep)
                .filter(ep => toBoolean($af.hide_untested) ? ep.tested === true : ep)
                .filter(ep => ($af.useragent.length > 0 && isValidRegex($af.useragent) && $ua)
                        ? hitByMatchingItems($ua, 'useragent', $af.useragent, ep)
                        : ep)
                .filter(ep => ($af.tests_match.length > 0 && isValidRegex($af.tests_match) && $tt)
                        ? hitByMatchingItems($tt, 'test', $af.tests_match, ep)
                        : ep)
                .filter(ep => ($af.test_tags_match.length > 0 && isValidRegex($af.test_tags_match) && $tt)
                        ? hitByMatchingTestTags($tt, $af.test_tags_match, ep)
                        : ep);
            set(endpoints)
          }
        });

      export const groupedEndpoints = derived(filteredEndpoints, ($ep, set) => {
        if ($ep.length > 0) {
          let endpointsByLevel = groupBy($ep, 'level')
          set(mapValues(endpointsByLevel, endpointsInLevel => {
            let endpointsByCategory = groupBy(endpointsInLevel, 'category')
            return mapValues(endpointsByCategory, endpointsInCategory => {
              return endpointsInCategory.map (endpoint => {
                return {
                  ...endpoint,
                  name: endpoint.operation_id,
                  value: 1,
                  color: endpointColour(endpoint)
                };
              });
            });
          }));
        } else {
          set({});
        }
      });


      export const sunburst = derived(groupedEndpoints, ($gep, set) => {
        if (!isEmpty($gep)) {
          var sunburst = {
            name: 'root',
            color: 'white',
            children: map($gep, (endpointsByCategoryAndOpID, level) => {
              return {
                name: level,
                color: levelColours[level] || levelColours['unused'],
                level: level,
                category: '',
                operation_id: '',
                children: map(endpointsByCategoryAndOpID, (endpointsByOpID, category) => {
                  return {
                    name: category,
                    level: level,
                    category: category,
                    operation_id: '',
                    color: categoryColours[category] ||  'rgba(183, 28, 28, 1)', // basic color so things compile right.
                    children: sortBy(endpointsByOpID, [
                      (endpoint) => endpoint.testHits > 0,
                      (endpoint) => endpoint.conformanceHits > 0
                    ])
                  };
                })
              };
            })
          };
          sunburst.children = orderBy(sunburst.children, 'name', 'desc');
          set(sunburst)
        } else {
          set({})
        }
      });

      export const zoomedSunburst = derived(
        [sunburst, activeFilters],
        ([$sunburst, $filters], set) => {
          let level = $filters.level;
          let category = $filters.category
          if (category) {
            let sunburstAtLevel = $sunburst.children.find(child => child.name === level);
            let sunburstAtCategory = sunburstAtLevel.children.find(child => child.name === category);
            set(sunburstAtCategory);
          } else if (!category && level) {
            let sunburstAtLevel = $sunburst.children.find(child => child.name === level);
            set(sunburstAtLevel);
          } else {
            set($sunburst)
          }
        })

      export const currentDepth = derived(breadcrumb, ($breadcrumb, set) => {
        let depths = ['root', 'level', 'category', 'endpoint']
        let depth = $breadcrumb.length;
        set(depths[depth])
      });

      export const coverageAtDepth = derived([breadcrumb, currentDepth, filteredEndpoints], ([$bc, $depth, $eps], set) => {
        let eps;
        if (isEmpty($eps)) {
          set({})
          return;
        } else if ($bc.length === 0) {
          eps = $eps;
        } else if ($bc.length === 1) {
          eps = $eps.filter(ep => ep.level === $bc[0])
        } else if ($bc.length === 2) {
          eps = $eps.filter(ep => ep.level === $bc[0] && ep.category === $bc[1])
        } else if ($bc.length === 3) {
          eps = $eps.filter(ep => ep.level === $bc[0] && ep.category === $bc[1] && ep.operation_id === $bc[2])
        } else {
          eps = $eps;
        }
        let totalEndpoints = eps.length;
        let testedEndpoints = eps.filter(ep => ep.tested).length;
        let confTestedEndpoints = eps.filter(ep => ep.conf_tested).length;
        set({
          totalEndpoints,
          testedEndpoints,
          confTestedEndpoints
        });
      });

      export const endpointCoverage = derived([breadcrumb, currentDepth, filteredEndpoints], ([$bc, $cd, $eps], set) => {
        let endpoint;
        let opId;
        let defaultCoverage = {
          tested: '',
          operation_id : '',
          confTested: '',
          description: '',
          path: '',
          group: '',
          version: '',
          kind: ''
        };
        if (isEmpty($eps) || $cd !== 'endpoint') {
          set(defaultCoverage);
        } else {
          opId = $bc[2]
          endpoint = $eps.find(ep => ep.operation_id === opId)
          let {
            tested,
            conf_tested: confTested,
            operation_id,
            details : {
              path,
              description,
              k8s_group: group,
              k8s_version: version,
              k8s_kind: kind
            }
          } = endpoint;
          set({
            tested,
            confTested,
            operation_id,
            path,
            description,
            group,
            version,
            kind
          });
        }
      });

      export const testsForEndpoint = derived(
        [allTestsAndTags, breadcrumb, currentDepth],
        ([$tt, $ap, $cd], set) => {
          if (isEmpty($tt) || $cd !== 'endpoint') {
            set([]);
          } else {
            let opID = $ap[2];
            let tests = $tt
                .filter(t => t.operation_ids.includes(opID))
            set(tests);
          }
        }
      );


      export const testTagsForEndpoint = derived(
        [allTestsAndTags, breadcrumb, currentDepth],
        ([$tt, $ap, $cd], set) => {
          if (isEmpty($tt) || $cd !== 'endpoint') {
            set([]);
          } else {
            let opID = $ap[2];
            let testTags = $tt
                .filter(t => t.operation_ids.includes(opID))
                .map(t => t.test_tags);
            let testTagsUniq = uniq(flattenDeep(testTags))
            set(testTagsUniq);
          }
        }
      );

      export const validTestTagFilters = derived(
        [activeFilters, testTagsForEndpoint],
        ([$af, $tt], set) => {
          if ($af.test_tags.length === 0 || $tt.length === 0) {
            set([]);
          } else {
            let validFilters = isArray($af.test_tags)
                ? $af.test_tags.filter(f => $tt.includes(f))
                : [$af.test_tags].filter(f => $tt.includes(f));
            set(validFilters);
          }
        });

      export const filteredTests = derived(
        [testsForEndpoint, validTestTagFilters],
        ([$t, $vf]) => {
          let tests;
          if ($vf.length === 0) {
            tests = $t; 
          } else {
            tests = $t.filter(test => {
              return intersection(test.test_tags, $vf).length > 0;
            });
          }
          return tests;
        });


    #+end_src
*** CoverageOverTime
    :PROPERTIES:
    :header-args: :tangle ./app/src/stores/coverage-over-time.js
    :END:
    #+NAME: coverage-over-time.js
    #+begin_src js
      import dayjs from 'dayjs';
      import { derived }  from 'svelte/store';
      import {
        findKey,
        flatten,
        sortBy
      } from 'lodash-es';
      import {
        bucketsAndJobs,
        defaultBucketAndJob,
        stableEndpointStats
      } from './index.js';


      export const dates = derived(
        [bucketsAndJobs, defaultBucketAndJob],
        ([$bjs, $default], set) => {
          if ($bjs.length === 0) {
            set([])
          } else {
            // let bucket = $default.bucket;
            let buckets = Object.keys($bjs);
            let allJobs = buckets.reduce((acc, cur) => {
              let jobs = sortBy($bjs[cur]['jobs'], 'timestamp');
              return [...acc, ...jobs];
            }, []);

            allJobs = sortBy(allJobs,'timestamp');
            set(allJobs.map(job => job.timestamp));
          }
        }
      );

      export const coverage = derived(
        [defaultBucketAndJob, stableEndpointStats, bucketsAndJobs],
        ([$default, $stats, $bjs], set) => {
          if ($default.bucket === '') {
            set([]);
          } else {
            let coverageStats = $stats
                .filter(stat => stat.job !== 'live')
                .map(stat => {
                  let bucket = findKey($bjs, (o) => o.jobs.map(job => job.job).includes(stat.job))
                  console.log({bucket});
                  return {
                    ...stat,
                    bucket,
                    timestamp: dayjs(stat.date)
                  };
                });
            coverageStats = sortBy(coverageStats, 'timestamp');
            set(coverageStats);
          }
        }
      );



    #+end_src
** Utility Functions (/lib/)
*** helpers
    :PROPERTIES:
    :header-args: :tangle ./app/src/lib/helpers.js
    :END:
   #+NAME: helpers
   #+begin_src js
import {
  forEach,
  trimEnd,
  groupBy,
  mapValues,
  trimStart,
  flatten,
  uniq
} from 'lodash-es';

export const updateQueryParams = (page, query) => {
  // given a sapper page store, and new queries
  // construct a url string with old and new queries.
  let newQueries = {
    ...page.query,
    ...query
  };

  let queryStrings = {};
  forEach(newQueries, (v, k) => {
    queryStrings[k] = trimStart(v.reduce((acc, cur) => `${acc}${k}=${cur}&`, ''), '&');
  });

  let queryNames = Object.keys(queryStrings);
  let fullQueryString = trimEnd(queryNames.reduce((acc, cur) => `${acc}${queryStrings[cur]}`, '?'), '&');
  return fullQueryString;
};

export const toBoolean = (str) => {
  str = str.toString().toLowerCase();
  let truths = ["true", "t", "yes", "1", "truth"]
  return truths.includes(str)
}

export const isValidRegex = (regex) => {
  try {
    new RegExp(regex);
  } catch (e) {
    return false;
  }
  return true;
};

export const hitByMatchingItems = (items, key,  regex, endpoint) => {
  // given an array of objects, items, a key to compare, and the regex to match.
  // return true if endpoint is hit by any item whose key value matches the regex.
  regex = new RegExp(regex);
  let matchingItems = items.filter(ua => regex.test(ua[key]));
  let endpointsHitByItems = uniq(flatten(matchingItems.map(item => item.operation_ids)));
  return endpointsHitByItems.includes(endpoint.operation_id);
};

export const hitByMatchingTestTags = (tests, regex, endpoint) => {
  // given an array of tests, each containing an array of test_tags, and the regex to match.
  // filter tests by those with at least one tag that matches regex filter.
  // return true if endpoint is hit by any of these filtered tests.
  regex = new RegExp(regex);
  let matchingTests = tests.filter(test => test.test_tags.some((tag) => regex.test(tag)));
  let endpointsHitByTests = uniq(flatten(matchingTests.map(test => test.operation_ids)));
  return endpointsHitByTests.includes(endpoint.operation_id);
};

export const determineBucketAndJob = (bucketsAndJobs, bucketParam, jobParam) => {
  let bucket;
  let job;
  let buckets = groupBy(bucketsAndJobs, 'bucket');
  let bj = mapValues(buckets, (allJobs) => {
    let jobs = allJobs
        .sort((a,b) => new Date(b.job_timestamp) > new Date(a.job_timestamp))
        .map(j => ({job: j.job, timestamp: j.job_timestamp}));
    let [latestJob] = allJobs.map(j => ({job: j.job, timestamp: j.job_timestamp}));
    return {
      latestJob,
      jobs
    };
  });

  let releaseBlocking = 'ci-kubernetes-e2e-gci-gce';
  let defaultBucket = Object.keys(bj).includes(releaseBlocking)
      ? releaseBlocking
      : Object.keys(bj)[0];
  let defaultJob = bj[defaultBucket]['latestJob'].job;

  if (!bucketParam) {
    bucket = defaultBucket;
    job = defaultJob;
  } else if (bucketParam && !jobParam) {
    bucket = isValidBucket(bucketParam, bj)
      ? bucketParam
      : defaultBucket;
    job = bj[bucket]['latestJob'].job
  } else {
    bucket = isValidBucket(bucketParam, bj)
      ? bucketParam
      : defaultBucket;
    job = isValidJob(bj[bucket], jobParam)
      ? jobParam
      : bj[bucket]['latestJob'].job
  }
  return {
    bucket,
    job
  };
}

function isValidBucket (bucket, bjs) {
  return Object.keys(bjs).includes(bucket);
}

function isValidJob  (bucket, job) {
  let jobs = bucket.jobs.map(job => job.job);
  return jobs.includes(job);
}
   
   #+end_src
   
*** colours
    :PROPERTIES:
    :header-args: :tangle ./app/src/lib/colours.js
    :END:
    
    #+NAME: Colours
    #+begin_src js
      import {
        inRange,
        parseInt,
        words
      } from 'lodash-es';

      export const GRAY = 'rgba(244, 244, 244, 1)';

      export const levelColours = {
        alpha: 'rgba(230, 25, 75, 1)',
        beta: 'rgba(0, 130, 200, 1)',
        stable: 'rgba(60, 180, 75, 1)',
        unused: 'rgba(244, 244, 244, 1)'
      };


      export const categoryColours = {
        admissionregistration: 'rgba(183, 28, 28, 1)',
        apiextensions: 'rgba(49, 27, 146, 1)',
        apiregistration: 'rgba(1, 87, 155, 1)',
        apis: 'rgba(27, 94, 32, 1)',
        apps: 'rgba(245, 127, 23, 1)',
        authentication: 'rgba(191, 54, 12, 1)',
        authorization: 'rgba(156, 39, 176, 1)',
        autoscaling: 'rgba(33, 150, 243, 1)',
        batch: 'rgba(0, 150, 136, 1)',
        certificates: 'rgba(205, 220, 57, 1)',
        core: 'rgba(255, 152, 0, 1)',
        discovery: 'rgba(136, 14, 79, 1)',
        events: 'rgba(136, 14, 79, 1)',
        extensions: 'rgba(26, 35, 126, 1)',
        logs: 'rgba(0, 96, 100, 1)',
        networking: 'rgba(51, 105, 30, 1)',
        node: 'rgba(53, 105, 30, 1)',
        policy: 'rgba(255, 111, 0, 1)',
        rbacAuthorization: 'rgba(244, 67, 54, 1)',
        scheduling: 'rgba(103, 58, 183, 1)',
        settings: 'rgba(3, 169, 244, 1)',
        storage: 'rgba(255, 215, 0, 1)',
        version: 'rgba(255, 235, 59, 1)',
        auditregistration: 'rgba(255, 87, 34, 1)',
        coordination: 'rgba(74, 20, 140, 1)'
      };

      export function endpointColour (endpoint) {
        let endpointColor = categoryColours[endpoint.category]
        if (!endpoint.tested) {
          return GRAY;
        } else if (!endpoint.conf_tested) {
          return fadeColour(endpointColor, 0.75);
        } else {
          return endpointColor;
        }
      };

      export function fadeColour (colour, desiredOpacity) {
        let rgbaPattern = /rgba\([0-9]{1,3},[0-9]{1,3},[0-9]{1,3},(1|0\.[0-9])\)/g
        let rgbaIsValid = rgbaPattern.test(colour.replace(/\s+/g, ''));
        let opacityIsValid = inRange(parseInt(desiredOpacity), 0, 1.1);
        if (!rgbaIsValid) {
          console.log('color given to fadeColour does not match rgba pattern: ', colour);
          return `rgba(244,244,244,1)`
        } else if (!opacityIsValid) {
          console.log('opacity is not valid: ', desiredOpacity);
          return `rgba(244,244,244,1)`
        } else {
          let rgba = words(colour);
          let c = {
            red: rgba[1],
            green: rgba[2],
            blue: rgba[3]
          };
          return `rgba(${c.red}, ${c.green}, ${c.blue}, ${desiredOpacity})`
        };
      };

    #+end_src
** Routes
** Stores
** Queries
** Utility Functions (lib)
** Components
* Building the App
** Dockerfile
#+begin_src dockerfile :tangle ./app/Dockerfile
FROM node:slim

RUN addgroup --system --gid 1001 appuser \
    &&  adduser --system --uid 1001 --ingroup appuser appuser

COPY . /webapp

RUN chown -R appuser:appuser /webapp

USER appuser

WORKDIR /webapp

RUN npm install

EXPOSE 3000
# EXPOSE 10000

# RUN npm run build
# USER root

# CMD ["npm", "start"]
CMD ["npm", "run", "dev"]
#+end_src

** cloudbuild.yaml
#+begin_src yaml :tangle ./app/cloudbuild.yaml
steps:
  - name: gcr.io/cloud-builders/docker
    args: ['build', '-t', 'gcr.io/$PROJECT_ID/webapp:$_GIT_TAG',
           '--build-arg', 'IMAGE_ARG=gcr.io/$PROJECT_ID/webapp:$_GIT_TAG',
           '.']
substitutions:
  _GIT_TAG: '12345'
images:
  - 'gcr.io/$PROJECT_ID/webapp:$_GIT_TAG'
options:
  substitution_option: 'ALLOW_LOOSE'
#+end_src

* Deployment
** deployment.yaml
#+begin_src yaml :tangle ./deployment/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp
spec:
  replicas: 1
  selector:
    matchLabels:
      io.apisnoop.webapp: webapp
  template:
    metadata:
      labels:
        io.apisnoop.webapp: webapp
    spec:
      restartPolicy: Always
      containers:
      - name: webapp
        image: "gcr.io/k8s-staging-apisnoop/webapp:v20200211-0.9.34-1-g24cf96f"
        ports:
        - containerPort: 3000
#+end_src

** ingress.yaml
#+begin_src yaml :tangle ./deployment/ingress.yaml
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: webapp-ingress
  annotations:
    nginx.ingress.kubernetes.io/server-alias: "apisnoop.local.ii.coop, apisnoop.local.ii.nz, apisnoop.local.sharing.io"
  # annotations:
  #   nginx.ingress.kubernetes.io/app-root: /
  # annotations:
  #   nginx.ingress.kubernetes.io/rewrite-target: /$2
spec:
  rules:
  - host: apisnoop.localho.st
    http:
      paths:
      - path: /
        backend:
          serviceName: webapp
          servicePort: 3000
#+end_src

** kustomization.yaml
#+begin_src yaml :tangle ./deployment/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
  - deployment.yaml
  - service.yaml
  - ingress.yaml
# TODO set ingress to apisnoop.local.sharing.io 
#+end_src

** service.yaml
#+begin_src yaml :tangle ./deployment/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: webapp
spec:
  selector:
    io.apisnoop.webapp: webapp
  ports:
  - name: "3000"
    port: 3000
    targetPort: 3000
#+end_src

* Footnotes
